/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const twgl = __webpack_require__(5);
const functions_1 = __webpack_require__(1);
const Board_1 = __webpack_require__(2);
// TODO: Make it owned bu the app?
exports.canvas = document.getElementsByTagName("canvas")[0];
exports.gl = exports.canvas.getContext("webgl");
let programInfo;
let textures;
function init() {
    twgl.resizeCanvasToDisplaySize(exports.canvas, window.devicePixelRatio);
    const program = twgl.createProgramFromSources(exports.gl, [
        `
			uniform mat4 u_worldViewProjection;
			uniform vec3 u_lightWorldPos;
			uniform mat4 u_world;
			uniform mat4 u_model;
			uniform mat4 u_viewInverse;
			uniform mat4 u_worldInverseTranspose;
			uniform vec4 u_position;

			attribute vec4 position;
			attribute vec3 normal;
			attribute vec3 texCoord;

			varying vec4 v_position;
			varying vec3 v_normal;
			varying vec3 v_texCoord;
			varying vec3 v_surfaceToLight;
			varying vec3 v_surfaceToView;

			void main() {
				v_position = u_worldViewProjection * ((u_model * position) + u_position);
				v_normal = (u_worldInverseTranspose * u_model * vec4(normal, 0)).xyz;
				v_texCoord = texCoord;
				v_surfaceToLight = u_lightWorldPos - (u_world * position).xyz;
				v_surfaceToView = (u_viewInverse[3] - (u_world * position)).xyz;
				gl_Position = v_position;
			}
		`,
        `
			precision mediump float;

			varying vec4 v_position;
			varying vec3 v_normal;
			varying vec3 v_texCoord;
			varying vec3 v_surfaceToLight;
			varying vec3 v_surfaceToView;

			uniform vec4 u_lightColor;
			uniform vec4 u_ambient;
			uniform vec4 u_specular;
			uniform float u_shininess;
			uniform float u_specularFactor;
			uniform samplerCube u_diffuseMap;

			vec4 lit(float l ,float h, float m) {
				return vec4(
					1.0,
					max(l, 0.0),
					(l > 0.0) ? pow(max(0.0, h), m) : 0.0,
					1.0
				);
			}

			void main() {
				vec4 diffuseColor = textureCube(u_diffuseMap, normalize(v_texCoord));
				vec3 a_normal = normalize(v_normal);
				vec3 surfaceToLight = normalize(v_surfaceToLight);
				vec3 surfaceToView = normalize(v_surfaceToView);
				vec3 halfVector = normalize(surfaceToLight + surfaceToView);
				vec4 litR = lit(
					dot(a_normal, surfaceToLight),
					dot(a_normal, halfVector),
					u_shininess
				);
				vec4 outColor = vec4(
					(u_lightColor * (
						diffuseColor * litR.y + diffuseColor * u_ambient +
						u_specular * litR.z * u_specularFactor
					)).rgb,
					diffuseColor.a
				);
				gl_FragColor = outColor;
			}
		`,
    ]);
    exports.gl.enable(exports.gl.DEPTH_TEST);
    exports.gl.enable(exports.gl.CULL_FACE);
    textures = twgl.createTextures(exports.gl, {
        earth: {
            target: exports.gl.TEXTURE_CUBE_MAP,
            src: "graphics/earth.jpg",
        },
        globe: {
            target: exports.gl.TEXTURE_CUBE_MAP,
            src: "graphics/globe.jpg",
        },
        eye: {
            target: exports.gl.TEXTURE_CUBE_MAP,
            src: "graphics/eye.jpg",
        },
        oneBall: {
            target: exports.gl.TEXTURE_CUBE_MAP,
            src: "graphics/1-ball.jpg",
        },
        thirteenBall: {
            target: exports.gl.TEXTURE_CUBE_MAP,
            src: "graphics/13-ball.jpg",
        },
        volley: {
            target: exports.gl.TEXTURE_CUBE_MAP,
            src: "graphics/volley.jpg",
        },
        tennis: {
            target: exports.gl.TEXTURE_CUBE_MAP,
            src: "graphics/tennis.jpg",
        },
        soccer: {
            target: exports.gl.TEXTURE_CUBE_MAP,
            src: "graphics/soccer.jpg",
        },
        animator: {
            target: exports.gl.TEXTURE_CUBE_MAP,
            src: "graphics/animator.jpg",
        },
        jupiter: {
            target: exports.gl.TEXTURE_CUBE_MAP,
            src: "graphics/jupiter.jpg",
        },
        poke: {
            target: exports.gl.TEXTURE_CUBE_MAP,
            src: "graphics/poke.png",
        },
        balance: {
            target: exports.gl.TEXTURE_CUBE_MAP,
            src: "graphics/balance.jpg",
        },
        basket: {
            target: exports.gl.TEXTURE_CUBE_MAP,
            src: "graphics/basket.jpg",
        },
    });
    programInfo = program && twgl.createProgramInfoFromProgram(exports.gl, program);
    exports.gl.viewport(0, 0, exports.gl.canvas.width, exports.gl.canvas.height);
    exports.gl.useProgram(programInfo.program);
    twgl.setBuffersAndAttributes(exports.gl, programInfo, bufferInfo);
    const aspect = exports.gl.canvas.clientWidth / exports.gl.canvas.clientHeight;
    const boardWidth = Board_1.Board.size.x + 2;
    const boardHeight = Board_1.Board.size.y + 2;
    const halfVisibleWidth = Math.max(boardWidth, boardWidth * aspect) / 2;
    const halfVisibleHeight = Math.max(boardHeight, boardHeight / aspect) / 2;
    const zNear = 0.5;
    const zFar = 30;
    const projection = twgl.m4.ortho(-halfVisibleWidth, halfVisibleWidth, -halfVisibleHeight, halfVisibleHeight, zNear, zFar);
    const eye = [1, 4, 12];
    const target = [0, 0, 0];
    const up = [0, 1, 0];
    const camera = twgl.m4.lookAt(eye, target, up);
    const view = twgl.m4.inverse(camera);
    const viewProjection = twgl.m4.multiply(projection, view);
    const world = twgl.m4.rotationY(0);
    twgl.setUniforms(programInfo, {
        u_lightWorldPos: [-4, 8, 10],
        u_lightColor: [1, 0.8, 0.8, 1],
        u_ambient: [0.5, 0.5, 0.5, 1],
        u_specular: [0.5, 0.5, 0.5, 1],
        u_shininess: 50,
        u_specularFactor: 1,
        u_viewInverse: camera,
        u_world: world,
        u_worldInverseTranspose: twgl.m4.transpose(twgl.m4.inverse(world)),
        u_worldViewProjection: twgl.m4.multiply(viewProjection, world),
    });
    clear();
}
exports.init = init;
const ballArrays = functions_1.meshToWebglArrays(functions_1.makeTesselatedSphereMesh(0.4, 8));
const bufferInfo = twgl.createBufferInfoFromArrays(exports.gl, ballArrays);
function clear() {
    exports.gl.clear(exports.gl.COLOR_BUFFER_BIT | exports.gl.DEPTH_BUFFER_BIT);
}
exports.clear = clear;
function draw(color, position) {
    const model = twgl.m4.multiply(twgl.m4.rotationY(new Date().getTime() / 1000), twgl.m4.rotationX(new Date().getTime() / 1341));
    twgl.setUniforms(programInfo, {
        u_model: model,
        u_diffuseMap: textures[Object.keys(textures)[color % Object.keys(textures).length]],
        u_position: [position.x, position.y, 0, 0],
    });
    twgl.drawBufferInfo(exports.gl, bufferInfo);
}
exports.draw = draw;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Coord3_1 = __webpack_require__(6);
function* waitMs(duration) {
    let elapsedTime = 0;
    while (elapsedTime < duration) {
        const deltaTime = yield;
        elapsedTime += deltaTime;
    }
    return elapsedTime;
}
exports.waitMs = waitMs;
function* range(from, to) {
    for (let i = from; i < to; ++i) {
        yield i;
    }
}
exports.range = range;
function randomElement(array) {
    return array[Math.floor(Math.random() * array.length)];
}
exports.randomElement = randomElement;
// http://stackoverflow.com/questions/2450954/how-to-randomize-a-javascript-array
function fisherYatesArrayShuffle(myArray) {
    let i = myArray.length;
    if (i === 0) {
        return;
    }
    while (--i) {
        const j = Math.floor(Math.random() * (i + 1));
        const tempi = myArray[i];
        const tempj = myArray[j];
        myArray[i] = tempj;
        myArray[j] = tempi;
    }
}
exports.fisherYatesArrayShuffle = fisherYatesArrayShuffle;
function makeTesselatedCubeMesh(tesselation) {
    function makeSide(uAxis, vAxis, normal) {
        const vertices = [];
        const indices = [];
        for (let v = 0; v <= tesselation; ++v) {
            const vFactor = v / tesselation;
            for (let u = 0; u <= tesselation; ++u) {
                const uFactor = u / tesselation;
                const position = Coord3_1.Coord3.add(Coord3_1.Coord3.add(uAxis.scaled(-1 + 2 * uFactor), vAxis.scaled(-1 + 2 * vFactor)), normal);
                vertices.push({
                    position,
                    normal,
                    texCoord: position.normalized(),
                });
            }
        }
        for (let v = 0; v < tesselation; ++v) {
            for (let u = 0; u < tesselation; ++u) {
                const i = u + v * (tesselation + 1);
                indices.push(i, i + 1, i + (tesselation + 1));
                indices.push(i + 1, i + 1 + (tesselation + 1), i + (tesselation + 1));
            }
        }
        return {
            vertices,
            indices,
        };
    }
    const sideArguments = [
        {
            uAxis: new Coord3_1.Coord3({ x: 0, y: 1, z: 0 }),
            vAxis: new Coord3_1.Coord3({ x: 0, y: 0, z: 1 }),
            normal: new Coord3_1.Coord3({ x: 1, y: 0, z: 0 }),
        },
        {
            uAxis: new Coord3_1.Coord3({ x: 0, y: -1, z: 0 }),
            vAxis: new Coord3_1.Coord3({ x: 0, y: 0, z: 1 }),
            normal: new Coord3_1.Coord3({ x: -1, y: 0, z: 0 }),
        },
        {
            uAxis: new Coord3_1.Coord3({ x: -1, y: 0, z: 0 }),
            vAxis: new Coord3_1.Coord3({ x: 0, y: 0, z: 1 }),
            normal: new Coord3_1.Coord3({ x: 0, y: 1, z: 0 }),
        },
        {
            uAxis: new Coord3_1.Coord3({ x: 1, y: 0, z: 0 }),
            vAxis: new Coord3_1.Coord3({ x: 0, y: 0, z: 1 }),
            normal: new Coord3_1.Coord3({ x: 0, y: -1, z: 0 }),
        },
        {
            uAxis: new Coord3_1.Coord3({ x: 1, y: 0, z: 0 }),
            vAxis: new Coord3_1.Coord3({ x: 0, y: 1, z: 0 }),
            normal: new Coord3_1.Coord3({ x: 0, y: 0, z: 1 }),
        },
        {
            uAxis: new Coord3_1.Coord3({ x: 1, y: 0, z: 0 }),
            vAxis: new Coord3_1.Coord3({ x: 0, y: -1, z: 0 }),
            normal: new Coord3_1.Coord3({ x: 0, y: 0, z: -1 }),
        },
    ];
    return mergeMeshes(sideArguments.map(({ uAxis, vAxis, normal }) => makeSide(uAxis, vAxis, normal)));
}
exports.makeTesselatedCubeMesh = makeTesselatedCubeMesh;
function mergeMeshes(meshes) {
    let indexStart = 0;
    return meshes.reduce((soFar, current) => {
        soFar.vertices.push(...current.vertices);
        soFar.indices.push(...current.indices.map(index => index + indexStart));
        indexStart += current.vertices.length;
        return soFar;
    }, {
        vertices: [],
        indices: [],
    });
}
function makeTesselatedSphereMesh(radius, tesselation) {
    const mesh = makeTesselatedCubeMesh(tesselation);
    mesh.vertices = mesh.vertices.map(vertex => {
        const normalizedPosition = vertex.position.normalized();
        return {
            position: normalizedPosition.scaled(radius),
            normal: normalizedPosition,
            texCoord: vertex.texCoord,
        };
    });
    return mesh;
}
exports.makeTesselatedSphereMesh = makeTesselatedSphereMesh;
// function coord2ToTwglVec2(coord: Coord2): Array<number> {
// 	return [coord.x, coord.y];
// }
function coord3ToTwglVec3(coord) {
    return [coord.x, coord.y, coord.z];
}
function meshToWebglArrays(mesh) {
    return {
        position: {
            numComponents: 3,
            data: mesh.vertices
                .map(vertex => vertex.position)
                .map(coord3ToTwglVec3)
                .reduce((soFar, current) => {
                soFar.push(...current);
                return soFar;
            }, []),
        },
        normal: {
            numComponents: 3,
            data: mesh.vertices
                .map(vertex => vertex.normal)
                .map(coord3ToTwglVec3)
                .reduce((soFar, current) => {
                soFar.push(...current);
                return soFar;
            }, []),
        },
        texCoord: {
            numComponents: 3,
            data: mesh.vertices
                .map(vertex => vertex.texCoord)
                .map(coord3ToTwglVec3)
                .reduce((soFar, current) => {
                soFar.push(...current);
                return soFar;
            }, []),
        },
        indices: { numComponents: 3, data: mesh.indices },
    };
}
exports.meshToWebglArrays = meshToWebglArrays;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Coord2_1 = __webpack_require__(7);
const Piece_1 = __webpack_require__(8);
const functions_1 = __webpack_require__(1);
const Renderer = __webpack_require__(0);
class Board {
    constructor(options) {
        this.gameMode = options.gameMode;
        this.frameCoroutine = this.makeFrameCoroutine();
        this.pickedPiece = undefined;
        this.pieces = [];
        this.queuedPiece = new Piece_1.Piece({
            color: this.randomColor(),
        });
        this.queuedPiece.setPicked(true);
        Renderer.canvas.addEventListener("click", event => {
            const aspect = Renderer.canvas.clientWidth / Renderer.canvas.clientHeight;
            const boardWidth = Board.size.x + 2;
            const boardHeight = Board.size.y + 2;
            const visibleWidth = Math.max(boardWidth, boardWidth * aspect);
            const visibleHeight = Math.max(boardHeight, boardHeight / aspect);
            const mouseWorldCoordX = (event.offsetX / Renderer.canvas.clientWidth - 0.5) * visibleWidth;
            const mouseWorldCoordY = -(event.offsetY / Renderer.canvas.clientHeight - 0.5) * visibleHeight;
            const x = Math.floor(mouseWorldCoordX + Board.size.x / 2);
            const y = Math.floor(mouseWorldCoordY + Board.size.y / 2);
            if (x >= 0 && x < Board.size.x && y >= 0 && y < Board.size.y) {
                this.pick(Board.coordToIndex(new Coord2_1.Coord2({ x, y })));
            }
        });
    }
    static xyToIndex(x, y) {
        return x + y * Board.size.x;
    }
    static coordToIndex(coord) {
        return Board.xyToIndex(coord.x, coord.y);
    }
    static indexToCoord(index) {
        return new Coord2_1.Coord2({
            x: index % Board.size.x,
            y: Math.floor(index / Board.size.x),
        });
    }
    pick(index) {
        const piece = this.pieces[index];
        if (piece && !this.pickedPiece) {
            this.pickedPiece = piece;
            this.pickedPiece.setPicked(true);
        }
    }
    addPiece(color) {
        const pieceAddOrder = Array.from(functions_1.range(0, Board.size.x * Board.size.y)).sort((a, b) => {
            // Meassure from center.
            const center = new Coord2_1.Coord2({
                x: (Board.size.x - 1) / 2,
                y: (Board.size.y - 1) / 2,
            });
            // With a small offset to make it deterministic.
            center.x += 0.1;
            center.x += 0.2;
            // Order by distance.
            const A = Coord2_1.Coord2.distance(Board.indexToCoord(a), center);
            const B = Coord2_1.Coord2.distance(Board.indexToCoord(b), center);
            return A - B;
        });
        for (const index of pieceAddOrder) {
            if (!this.pieces[index]) {
                this.pieces[index] = new Piece_1.Piece({
                    color,
                });
                return true;
            }
        }
        return false;
    }
    randomColorFromExisting() {
        const possibleColors = Array.from(new Set(this.pieces.filter(piece => !!piece).map(piece => piece.color)));
        return functions_1.randomElement(possibleColors);
    }
    randomColor() {
        const possibleColors = Array.from(functions_1.range(0, Board.numColors));
        return functions_1.randomElement(possibleColors);
    }
    *makeFrameCoroutine() {
        const gameFlowCoroutine = this.gameFlowCoroutine();
        // Run the gameflow and pieces coroutines concurrently.
        for (;;) {
            const deltaTime = yield;
            const pieceCoroutines = this.pieces
                .filter(piece => !!piece)
                .map(piece => piece.frameCoroutine);
            const allCoroutines = [
                gameFlowCoroutine,
                this.queuedPiece.frameCoroutine,
                ...pieceCoroutines,
            ];
            allCoroutines.forEach(coroutine => coroutine.next(deltaTime));
        }
    }
    *gameFlowCoroutine() {
        // Give the player a chance to see the queued piece.
        yield* functions_1.waitMs(1000);
        yield* this.initializationCoroutine();
        // Normal gameplay.
        for (;;) {
            if (this.pickedPiece) {
                // Give the player a chance to compare the pieces visually.
                yield* functions_1.waitMs(1000);
                if (this.pickedPiece.color == this.queuedPiece.color) {
                    // The player found a pair.
                    // Remove the picked piece from the board.
                    this.pieces = this.pieces.map(piece => (piece != this.pickedPiece ? piece : undefined));
                    // Notify the game mode.
                    this.gameMode.onUnlockedPair(this);
                    if (this.pieces.filter(piece => !!piece).length < 2) {
                        this.gameMode.onWin(this);
                    }
                }
                else {
                    // Punish player.
                    const addedPieceSuccessfully = this.addPiece(this.queuedPiece.color);
                    // Detect game over.
                    if (!addedPieceSuccessfully) {
                        this.gameMode.onGameOver(this);
                        // TODO: Clear board animation.
                        break;
                    }
                }
                // TODO: Should not queue up same color twice in a row.
                // Queue up a new piece.
                this.queuedPiece = new Piece_1.Piece({
                    color: this.randomColorFromExisting(),
                });
                this.queuedPiece.setPicked(true);
                // Reset the picked piece.
                this.pickedPiece.setPicked(false);
                this.pickedPiece = undefined;
            }
            yield;
        }
    }
    *initializationCoroutine() {
        // Add initial pieces.
        for (let i = 0; i < Board.size.x * Board.size.y * 0.75; ++i) {
            const color = this.randomColor();
            this.addPiece(color);
            yield* functions_1.waitMs(100);
        }
    }
    draw() {
        Renderer.clear();
        this.queuedPiece.draw(Coord2_1.Coord2.add(Board.size.scaled(0.5), new Coord2_1.Coord2({ x: 0.5, y: 0.5 })));
        for (let i = 0; i < Board.size.x * Board.size.y; ++i) {
            const piece = this.pieces[i];
            if (piece) {
                piece.draw(Coord2_1.Coord2.add(Coord2_1.Coord2.add(Board.indexToCoord(i), Board.size.scaled(-0.5)), new Coord2_1.Coord2({ x: 0.5, y: 0.5 })));
            }
        }
    }
}
Board.size = new Coord2_1.Coord2({ x: 4, y: 4 });
Board.numColors = 13;
exports.Board = Board;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const App_1 = __webpack_require__(4);
const app = new App_1.App();
try {
    app.startGame();
}
catch (error) {
    console.error("Could not start game.", error);
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Renderer = __webpack_require__(0);
const GameMode1p_1 = __webpack_require__(9);
class App {
    constructor() {
        this.gameMode = new GameMode1p_1.GameMode1p();
        this.lastRenderTime = 0;
    }
    startGame() {
        return __awaiter(this, void 0, void 0, function* () {
            // Set up the renderer.
            this.startRenderLoop();
        });
    }
    startRenderLoop() {
        Renderer.init();
        const requestAnimFrame = (() => {
            return (window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                (callback => {
                    window.setTimeout(callback, 1000 / 60, new Date().getTime());
                }));
        })();
        // Start the loop.
        // TODO: Convert to generator?
        const loop = (currentTime) => {
            this.render(currentTime);
            requestAnimFrame(loop);
        };
        requestAnimFrame(loop);
    }
    render(currentTime) {
        // Calculate delta time. Cap it to make debugging easier.
        const deltaTime = Math.min(currentTime - this.lastRenderTime, 100);
        this.lastRenderTime = currentTime;
        // // Draw the board background.
        // this.context.fillStyle = "rgba(0, 0, 0, 1)";
        // this.context.fillRect(0, 0, this.getWidth(), this.getHeight());
        // Boards and avatars.
        this.gameMode.frameCoroutine.next(deltaTime);
        this.gameMode.draw();
        // FPS counter.
        // this.context.fillStyle = "black";
        // this.context.font = "16px Palatino";
        // this.context.fillText("FPS: " + Math.floor(1000/deltaTime), 10, 20);
    }
}
exports.App = App;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * @license twgl.js 4.4.0 Copyright (c) 2015, Gregg Tavares All Rights Reserved.
 * Available via the MIT license.
 * see: http://github.com/greggman/twgl.js for details
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["twgl"] = factory();
	else
		root["twgl"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 9);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.copyExistingProperties = copyExistingProperties;
exports.copyNamedProperties = copyNamedProperties;
exports.isBuffer = isBuffer;
exports.isRenderbuffer = isRenderbuffer;
exports.isShader = isShader;
exports.isTexture = isTexture;
exports.isSampler = isSampler;
exports.warn = exports.error = void 0;

var _globalObject = _interopRequireDefault(__webpack_require__(2));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Copyright 2015, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Copy named properties
 *
 * @param {string[]} names names of properties to copy
 * @param {object} src object to copy properties from
 * @param {object} dst object to copy properties to
 */
function copyNamedProperties(names, src, dst) {
  names.forEach(function (name) {
    var value = src[name];

    if (value !== undefined) {
      dst[name] = value;
    }
  });
}
/**
 * Copies properties from source to dest only if a matching key is in dest
 *
 * @param {Object.<string, ?>} src the source
 * @param {Object.<string, ?>} dst the dest
 */


function copyExistingProperties(src, dst) {
  Object.keys(dst).forEach(function (key) {
    if (dst.hasOwnProperty(key) && src.hasOwnProperty(key)) {
      dst[key] = src[key];
    }
  });
}

var error = _globalObject.default.console && _globalObject.default.console.error && typeof _globalObject.default.console.error === "function" ? _globalObject.default.console.error.bind(_globalObject.default.console) : function () {};
exports.error = error;
var warn = _globalObject.default.console && _globalObject.default.console.warn && typeof _globalObject.default.console.warn === "function" ? _globalObject.default.console.warn.bind(_globalObject.default.console) : function () {};
exports.warn = warn;
var repBuffer;

function isBuffer(gl, t) {
  if (!repBuffer) {
    repBuffer = gl.createBuffer();
  }

  return t instanceof repBuffer.constructor;
}

var repRenderbuffer;

function isRenderbuffer(gl, t) {
  if (!repRenderbuffer) {
    repRenderbuffer = gl.createRenderbuffer();
  }

  return t instanceof repRenderbuffer.constructor;
}

var repShader;

function isShader(gl, t) {
  if (!repShader) {
    repShader = gl.createShader(gl.VERTEX_SHADER);
  }

  return t instanceof repShader.constructor;
}

var repTexture;

function isTexture(gl, t) {
  if (!repTexture) {
    repTexture = gl.createTexture();
  }

  return t instanceof repTexture.constructor;
}

var repSampler;

function isSampler(gl, t) {
  if (!repSampler) {
    if (gl.createSampler) {
      repSampler = gl.createSampler();
    } else {
      return false; // it can't be a sampler if this is not WebGL2
    }
  }

  return t instanceof repSampler.constructor;
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getGLTypeForTypedArray = getGLTypeForTypedArray;
exports.getGLTypeForTypedArrayType = getGLTypeForTypedArrayType;
exports.getTypedArrayTypeForGLType = getTypedArrayTypeForGLType;
exports.isArrayBuffer = void 0;

var _globalObject = _interopRequireDefault(__webpack_require__(2));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Copyright 2015, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Low level shader typed array related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibily they are available at both `twgl.typedArray` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/typedArray
 */
// make sure we don't see a global gl
var gl = undefined; // eslint-disable-line

/* DataType */

var BYTE = 0x1400;
var UNSIGNED_BYTE = 0x1401;
var SHORT = 0x1402;
var UNSIGNED_SHORT = 0x1403;
var INT = 0x1404;
var UNSIGNED_INT = 0x1405;
var FLOAT = 0x1406;
var UNSIGNED_SHORT_4_4_4_4 = 0x8033;
var UNSIGNED_SHORT_5_5_5_1 = 0x8034;
var UNSIGNED_SHORT_5_6_5 = 0x8363;
var HALF_FLOAT = 0x140B;
var UNSIGNED_INT_2_10_10_10_REV = 0x8368;
var UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;
var UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;
var FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
var UNSIGNED_INT_24_8 = 0x84FA;
var glTypeToTypedArray = {};
{
  var tt = glTypeToTypedArray;
  tt[BYTE] = Int8Array;
  tt[UNSIGNED_BYTE] = Uint8Array;
  tt[SHORT] = Int16Array;
  tt[UNSIGNED_SHORT] = Uint16Array;
  tt[INT] = Int32Array;
  tt[UNSIGNED_INT] = Uint32Array;
  tt[FLOAT] = Float32Array;
  tt[UNSIGNED_SHORT_4_4_4_4] = Uint16Array;
  tt[UNSIGNED_SHORT_5_5_5_1] = Uint16Array;
  tt[UNSIGNED_SHORT_5_6_5] = Uint16Array;
  tt[HALF_FLOAT] = Uint16Array;
  tt[UNSIGNED_INT_2_10_10_10_REV] = Uint32Array;
  tt[UNSIGNED_INT_10F_11F_11F_REV] = Uint32Array;
  tt[UNSIGNED_INT_5_9_9_9_REV] = Uint32Array;
  tt[FLOAT_32_UNSIGNED_INT_24_8_REV] = Uint32Array;
  tt[UNSIGNED_INT_24_8] = Uint32Array;
}
/**
 * Get the GL type for a typedArray
 * @param {ArrayBuffer|ArrayBufferView} typedArray a typedArray
 * @return {number} the GL type for array. For example pass in an `Int8Array` and `gl.BYTE` will
 *   be returned. Pass in a `Uint32Array` and `gl.UNSIGNED_INT` will be returned
 * @memberOf module:twgl/typedArray
 */

function getGLTypeForTypedArray(typedArray) {
  if (typedArray instanceof Int8Array) {
    return BYTE;
  } // eslint-disable-line


  if (typedArray instanceof Uint8Array) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line


  if (typedArray instanceof Uint8ClampedArray) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line


  if (typedArray instanceof Int16Array) {
    return SHORT;
  } // eslint-disable-line


  if (typedArray instanceof Uint16Array) {
    return UNSIGNED_SHORT;
  } // eslint-disable-line


  if (typedArray instanceof Int32Array) {
    return INT;
  } // eslint-disable-line


  if (typedArray instanceof Uint32Array) {
    return UNSIGNED_INT;
  } // eslint-disable-line


  if (typedArray instanceof Float32Array) {
    return FLOAT;
  } // eslint-disable-line


  throw "unsupported typed array type";
}
/**
 * Get the GL type for a typedArray type
 * @param {ArrayBufferViewType} typedArrayType a typedArray constructor
 * @return {number} the GL type for type. For example pass in `Int8Array` and `gl.BYTE` will
 *   be returned. Pass in `Uint32Array` and `gl.UNSIGNED_INT` will be returned
 * @memberOf module:twgl/typedArray
 */


function getGLTypeForTypedArrayType(typedArrayType) {
  if (typedArrayType === Int8Array) {
    return BYTE;
  } // eslint-disable-line


  if (typedArrayType === Uint8Array) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line


  if (typedArrayType === Uint8ClampedArray) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line


  if (typedArrayType === Int16Array) {
    return SHORT;
  } // eslint-disable-line


  if (typedArrayType === Uint16Array) {
    return UNSIGNED_SHORT;
  } // eslint-disable-line


  if (typedArrayType === Int32Array) {
    return INT;
  } // eslint-disable-line


  if (typedArrayType === Uint32Array) {
    return UNSIGNED_INT;
  } // eslint-disable-line


  if (typedArrayType === Float32Array) {
    return FLOAT;
  } // eslint-disable-line


  throw "unsupported typed array type";
}
/**
 * Get the typed array constructor for a given GL type
 * @param {number} type the GL type. (eg: `gl.UNSIGNED_INT`)
 * @return {function} the constructor for a the corresponding typed array. (eg. `Uint32Array`).
 * @memberOf module:twgl/typedArray
 */


function getTypedArrayTypeForGLType(type) {
  var CTOR = glTypeToTypedArray[type];

  if (!CTOR) {
    throw "unknown gl type";
  }

  return CTOR;
}

var isArrayBuffer = _globalObject.default.SharedArrayBuffer ? function isArrayBufferOrSharedArrayBuffer(a) {
  return a && a.buffer && (a.buffer instanceof ArrayBuffer || a.buffer instanceof _globalObject.default.SharedArrayBuffer);
} : function isArrayBuffer(a) {
  return a && a.buffer && a.buffer instanceof ArrayBuffer;
};
exports.isArrayBuffer = isArrayBuffer;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
var global = typeof global !== 'undefined' // eslint-disable-line
? global // eslint-disable-line
: typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {};
exports.default = global;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.add = add;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.distance = distance;
exports.distanceSq = distanceSq;
exports.divide = divide;
exports.divScalar = divScalar;
exports.dot = dot;
exports.lerp = lerp;
exports.length = length;
exports.lengthSq = lengthSq;
exports.mulScalar = mulScalar;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.setDefaultType = setDefaultType;
exports.subtract = subtract;

/*
 * Copyright 2015, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 *
 * Vec3 math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new Vec3. In other words you can do this
 *
 *     var v = v3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.
 *
 * or
 *
 *     var v3 = v3.create();
 *     v3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any vector as the destination. So for example
 *
 *     v3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 * @module twgl/v3
 */
var VecType = Float32Array;
/**
 * A JavaScript array with 3 values or a Float32Array with 3 values.
 * When created by the library will create the default type which is `Float32Array`
 * but can be set by calling {@link module:twgl/v3.setDefaultType}.
 * @typedef {(number[]|Float32Array)} Vec3
 * @memberOf module:twgl/v3
 */

/**
 * Sets the type this library creates for a Vec3
 * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`
 * @return {constructor} previous constructor for Vec3
 */

function setDefaultType(ctor) {
  var oldType = VecType;
  VecType = ctor;
  return oldType;
}
/**
 * Creates a vec3; may be called with x, y, z to set initial values.
 * @return {Vec3} the created vector
 * @memberOf module:twgl/v3
 */


function create(x, y, z) {
  var dst = new VecType(3);

  if (x) {
    dst[0] = x;
  }

  if (y) {
    dst[1] = y;
  }

  if (z) {
    dst[2] = z;
  }

  return dst;
}
/**
 * Adds two vectors; assumes a and b have the same dimension.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..
 * @memberOf module:twgl/v3
 */


function add(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] + b[0];
  dst[1] = a[1] + b[1];
  dst[2] = a[2] + b[2];
  return dst;
}
/**
 * Subtracts two vectors.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..
 * @memberOf module:twgl/v3
 */


function subtract(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] - b[0];
  dst[1] = a[1] - b[1];
  dst[2] = a[2] - b[2];
  return dst;
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient t, returns
 * (1 - t) * a + t * b.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {number} t Interpolation coefficient.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..
 * @memberOf module:twgl/v3
 */


function lerp(a, b, t, dst) {
  dst = dst || new VecType(3);
  dst[0] = (1 - t) * a[0] + t * b[0];
  dst[1] = (1 - t) * a[1] + t * b[1];
  dst[2] = (1 - t) * a[2] + t * b[2];
  return dst;
}
/**
 * Mutiplies a vector by a scalar.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {number} k The scalar.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..
 * @return {module:twgl/v3.Vec3} dst.
 * @memberOf module:twgl/v3
 */


function mulScalar(v, k, dst) {
  dst = dst || new VecType(3);
  dst[0] = v[0] * k;
  dst[1] = v[1] * k;
  dst[2] = v[2] * k;
  return dst;
}
/**
 * Divides a vector by a scalar.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {number} k The scalar.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..
 * @return {module:twgl/v3.Vec3} dst.
 * @memberOf module:twgl/v3
 */


function divScalar(v, k, dst) {
  dst = dst || new VecType(3);
  dst[0] = v[0] / k;
  dst[1] = v[1] / k;
  dst[2] = v[2] / k;
  return dst;
}
/**
 * Computes the cross product of two vectors; assumes both vectors have
 * three entries.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..
 * @return {module:twgl/v3.Vec3} The vector a cross b.
 * @memberOf module:twgl/v3
 */


function cross(a, b, dst) {
  dst = dst || new VecType(3);
  var t1 = a[2] * b[0] - a[0] * b[2];
  var t2 = a[0] * b[1] - a[1] * b[0];
  dst[0] = a[1] * b[2] - a[2] * b[1];
  dst[1] = t1;
  dst[2] = t2;
  return dst;
}
/**
 * Computes the dot product of two vectors; assumes both vectors have
 * three entries.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @return {number} dot product
 * @memberOf module:twgl/v3
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the length of vector
 * @param {module:twgl/v3.Vec3} v vector.
 * @return {number} length of vector.
 * @memberOf module:twgl/v3
 */


function length(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}
/**
 * Computes the square of the length of vector
 * @param {module:twgl/v3.Vec3} v vector.
 * @return {number} square of the length of vector.
 * @memberOf module:twgl/v3
 */


function lengthSq(v) {
  return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
}
/**
 * Computes the distance between 2 points
 * @param {module:twgl/v3.Vec3} a vector.
 * @param {module:twgl/v3.Vec3} b vector.
 * @return {number} distance between a and b
 * @memberOf module:twgl/v3
 */


function distance(a, b) {
  var dx = a[0] - b[0];
  var dy = a[1] - b[1];
  var dz = a[2] - b[2];
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}
/**
 * Computes the square of the distance between 2 points
 * @param {module:twgl/v3.Vec3} a vector.
 * @param {module:twgl/v3.Vec3} b vector.
 * @return {number} square of the distance between a and b
 * @memberOf module:twgl/v3
 */


function distanceSq(a, b) {
  var dx = a[0] - b[0];
  var dy = a[1] - b[1];
  var dz = a[2] - b[2];
  return dx * dx + dy * dy + dz * dz;
}
/**
 * Divides a vector by its Euclidean length and returns the quotient.
 * @param {module:twgl/v3.Vec3} a The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..
 * @return {module:twgl/v3.Vec3} The normalized vector.
 * @memberOf module:twgl/v3
 */


function normalize(a, dst) {
  dst = dst || new VecType(3);
  var lenSq = a[0] * a[0] + a[1] * a[1] + a[2] * a[2];
  var len = Math.sqrt(lenSq);

  if (len > 0.00001) {
    dst[0] = a[0] / len;
    dst[1] = a[1] / len;
    dst[2] = a[2] / len;
  } else {
    dst[0] = 0;
    dst[1] = 0;
    dst[2] = 0;
  }

  return dst;
}
/**
 * Negates a vector.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..
 * @return {module:twgl/v3.Vec3} -v.
 * @memberOf module:twgl/v3
 */


function negate(v, dst) {
  dst = dst || new VecType(3);
  dst[0] = -v[0];
  dst[1] = -v[1];
  dst[2] = -v[2];
  return dst;
}
/**
 * Copies a vector.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..
 * @return {module:twgl/v3.Vec3} A copy of v.
 * @memberOf module:twgl/v3
 */


function copy(v, dst) {
  dst = dst || new VecType(3);
  dst[0] = v[0];
  dst[1] = v[1];
  dst[2] = v[2];
  return dst;
}
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..
 * @return {module:twgl/v3.Vec3} The vector of products of entries of a and
 *     b.
 * @memberOf module:twgl/v3
 */


function multiply(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] * b[0];
  dst[1] = a[1] * b[1];
  dst[2] = a[2] * b[2];
  return dst;
}
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created..
 * @return {module:twgl/v3.Vec3} The vector of quotients of entries of a and
 *     b.
 * @memberOf module:twgl/v3
 */


function divide(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] / b[0];
  dst[1] = a[1] / b[1];
  dst[2] = a[2] / b[2];
  return dst;
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.isWebGL1 = isWebGL1;
exports.isWebGL2 = isWebGL2;
exports.glEnumToString = void 0;

/*
 * Copyright 2017, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Gets the gl version as a number
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {number} version of gl
 */
//function getVersionAsNumber(gl) {
//  return parseFloat(gl.getParameter(gl.VERSION).substr(6));
//}

/**
 * Check if context is WebGL 2.0
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {bool} true if it's WebGL 2.0
 * @memberOf module:twgl
 */
function isWebGL2(gl) {
  // This is the correct check but it's slow
  //  return gl.getParameter(gl.VERSION).indexOf("WebGL 2.0") === 0;
  // This might also be the correct check but I'm assuming it's slow-ish
  // return gl instanceof WebGL2RenderingContext;
  return !!gl.texStorage2D;
}
/**
 * Check if context is WebGL 1.0
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {bool} true if it's WebGL 1.0
 * @memberOf module:twgl
 */


function isWebGL1(gl) {
  // This is the correct check but it's slow
  // const version = getVersionAsNumber(gl);
  // return version <= 1.0 && version > 0.0;  // because as of 2016/5 Edge returns 0.96
  // This might also be the correct check but I'm assuming it's slow-ish
  // return gl instanceof WebGLRenderingContext;
  return !gl.texStorage2D;
}
/**
 * Gets a string for WebGL enum
 *
 * Note: Several enums are the same. Without more
 * context (which function) it's impossible to always
 * give the correct enum. As it is, for matching values
 * it gives all enums. Checking the WebGL2RenderingContext
 * that means
 *
 *      0     = ZERO | POINT | NONE | NO_ERROR
 *      1     = ONE | LINES | SYNC_FLUSH_COMMANDS_BIT
 *      32777 = BLEND_EQUATION_RGB | BLEND_EQUATION_RGB
 *      36662 = COPY_READ_BUFFER | COPY_READ_BUFFER_BINDING
 *      36663 = COPY_WRITE_BUFFER | COPY_WRITE_BUFFER_BINDING
 *      36006 = FRAMEBUFFER_BINDING | DRAW_FRAMEBUFFER_BINDING
 *
 * It's also not useful for bits really unless you pass in individual bits.
 * In other words
 *
 *     const bits = gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT;
 *     twgl.glEnumToString(gl, bits);  // not going to work
 *
 * Note that some enums only exist on extensions. If you
 * want them to show up you need to pass the extension at least
 * once. For example
 *
 *     const ext = gl.getExtension('WEBGL_compressed_texture_s3tc`);
 *     if (ext) {
 *        twgl.glEnumToString(ext, 0);  // just prime the function
 *
 *        ..later..
 *
 *        const internalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
 *        console.log(twgl.glEnumToString(gl, internalFormat));
 *
 * Notice I didn't have to pass the extension the second time. This means
 * you can have place that generically gets an enum for texture formats for example.
 * and as long as you primed the function with the extensions
 *
 * If you're using `twgl.addExtensionsToContext` to enable your extensions
 * then twgl will automatically get the extension's enums.
 *
 * @param {WebGLRenderingContext|Extension} gl A WebGLRenderingContext or any extension object
 * @param {number} value the value of the enum you want to look up.
 * @memberOf module:twgl
 */


var glEnumToString = function () {
  var haveEnumsForType = {};
  var enums = {};

  function addEnums(gl) {
    var type = gl.constructor.name;

    if (!haveEnumsForType[type]) {
      for (var key in gl) {
        if (typeof gl[key] === 'number') {
          var existing = enums[gl[key]];
          enums[gl[key]] = existing ? "".concat(existing, " | ").concat(key) : key;
        }
      }

      haveEnumsForType[type] = true;
    }
  }

  return function glEnumToString(gl, value) {
    addEnums(gl);
    return enums[value] || "0x" + value.toString(16);
  };
}();

exports.glEnumToString = glEnumToString;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.createAttributeSetters = createAttributeSetters;
exports.createProgram = createProgram;
exports.createProgramFromScripts = createProgramFromScripts;
exports.createProgramFromSources = createProgramFromSources;
exports.createProgramInfo = createProgramInfo;
exports.createProgramInfoFromProgram = createProgramInfoFromProgram;
exports.createUniformSetters = createUniformSetters;
exports.createUniformBlockSpecFromProgram = createUniformBlockSpecFromProgram;
exports.createUniformBlockInfoFromProgram = createUniformBlockInfoFromProgram;
exports.createUniformBlockInfo = createUniformBlockInfo;
exports.createTransformFeedback = createTransformFeedback;
exports.createTransformFeedbackInfo = createTransformFeedbackInfo;
exports.bindTransformFeedbackInfo = bindTransformFeedbackInfo;
exports.setAttributes = setAttributes;
exports.setBuffersAndAttributes = setBuffersAndAttributes;
exports.setUniforms = setUniforms;
exports.setUniformBlock = setUniformBlock;
exports.setBlockUniforms = setBlockUniforms;
exports.bindUniformBlock = bindUniformBlock;

var utils = _interopRequireWildcard(__webpack_require__(4));

var helper = _interopRequireWildcard(__webpack_require__(0));

var _globalObject = _interopRequireDefault(__webpack_require__(2));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/*
 * Copyright 2015, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Low level shader program related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibily they are available at both `twgl.programs` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/programs
 */
var error = helper.error;
var warn = helper.warn;
var getElementById = _globalObject.default && _globalObject.default.document && _globalObject.default.document.getElementById ? _globalObject.default.document.getElementById.bind(_globalObject.default.document) : function () {
  return null;
};
var FLOAT = 0x1406;
var FLOAT_VEC2 = 0x8B50;
var FLOAT_VEC3 = 0x8B51;
var FLOAT_VEC4 = 0x8B52;
var INT = 0x1404;
var INT_VEC2 = 0x8B53;
var INT_VEC3 = 0x8B54;
var INT_VEC4 = 0x8B55;
var BOOL = 0x8B56;
var BOOL_VEC2 = 0x8B57;
var BOOL_VEC3 = 0x8B58;
var BOOL_VEC4 = 0x8B59;
var FLOAT_MAT2 = 0x8B5A;
var FLOAT_MAT3 = 0x8B5B;
var FLOAT_MAT4 = 0x8B5C;
var SAMPLER_2D = 0x8B5E;
var SAMPLER_CUBE = 0x8B60;
var SAMPLER_3D = 0x8B5F;
var SAMPLER_2D_SHADOW = 0x8B62;
var FLOAT_MAT2x3 = 0x8B65;
var FLOAT_MAT2x4 = 0x8B66;
var FLOAT_MAT3x2 = 0x8B67;
var FLOAT_MAT3x4 = 0x8B68;
var FLOAT_MAT4x2 = 0x8B69;
var FLOAT_MAT4x3 = 0x8B6A;
var SAMPLER_2D_ARRAY = 0x8DC1;
var SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;
var SAMPLER_CUBE_SHADOW = 0x8DC5;
var UNSIGNED_INT = 0x1405;
var UNSIGNED_INT_VEC2 = 0x8DC6;
var UNSIGNED_INT_VEC3 = 0x8DC7;
var UNSIGNED_INT_VEC4 = 0x8DC8;
var INT_SAMPLER_2D = 0x8DCA;
var INT_SAMPLER_3D = 0x8DCB;
var INT_SAMPLER_CUBE = 0x8DCC;
var INT_SAMPLER_2D_ARRAY = 0x8DCF;
var UNSIGNED_INT_SAMPLER_2D = 0x8DD2;
var UNSIGNED_INT_SAMPLER_3D = 0x8DD3;
var UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;
var UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;
var TEXTURE_2D = 0x0DE1;
var TEXTURE_CUBE_MAP = 0x8513;
var TEXTURE_3D = 0x806F;
var TEXTURE_2D_ARRAY = 0x8C1A;
var typeMap = {};
/**
 * Returns the corresponding bind point for a given sampler type
 */

function getBindPointForSamplerType(gl, type) {
  return typeMap[type].bindPoint;
} // This kind of sucks! If you could compose functions as in `var fn = gl[name];`
// this code could be a lot smaller but that is sadly really slow (T_T)


function floatSetter(gl, location) {
  return function (v) {
    gl.uniform1f(location, v);
  };
}

function floatArraySetter(gl, location) {
  return function (v) {
    gl.uniform1fv(location, v);
  };
}

function floatVec2Setter(gl, location) {
  return function (v) {
    gl.uniform2fv(location, v);
  };
}

function floatVec3Setter(gl, location) {
  return function (v) {
    gl.uniform3fv(location, v);
  };
}

function floatVec4Setter(gl, location) {
  return function (v) {
    gl.uniform4fv(location, v);
  };
}

function intSetter(gl, location) {
  return function (v) {
    gl.uniform1i(location, v);
  };
}

function intArraySetter(gl, location) {
  return function (v) {
    gl.uniform1iv(location, v);
  };
}

function intVec2Setter(gl, location) {
  return function (v) {
    gl.uniform2iv(location, v);
  };
}

function intVec3Setter(gl, location) {
  return function (v) {
    gl.uniform3iv(location, v);
  };
}

function intVec4Setter(gl, location) {
  return function (v) {
    gl.uniform4iv(location, v);
  };
}

function uintSetter(gl, location) {
  return function (v) {
    gl.uniform1ui(location, v);
  };
}

function uintArraySetter(gl, location) {
  return function (v) {
    gl.uniform1uiv(location, v);
  };
}

function uintVec2Setter(gl, location) {
  return function (v) {
    gl.uniform2uiv(location, v);
  };
}

function uintVec3Setter(gl, location) {
  return function (v) {
    gl.uniform3uiv(location, v);
  };
}

function uintVec4Setter(gl, location) {
  return function (v) {
    gl.uniform4uiv(location, v);
  };
}

function floatMat2Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix2fv(location, false, v);
  };
}

function floatMat3Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix3fv(location, false, v);
  };
}

function floatMat4Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix4fv(location, false, v);
  };
}

function floatMat23Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix2x3fv(location, false, v);
  };
}

function floatMat32Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix3x2fv(location, false, v);
  };
}

function floatMat24Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix2x4fv(location, false, v);
  };
}

function floatMat42Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix4x2fv(location, false, v);
  };
}

function floatMat34Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix3x4fv(location, false, v);
  };
}

function floatMat43Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix4x3fv(location, false, v);
  };
}

function samplerSetter(gl, type, unit, location) {
  var bindPoint = getBindPointForSamplerType(gl, type);
  return utils.isWebGL2(gl) ? function (textureOrPair) {
    var texture;
    var sampler;

    if (helper.isTexture(gl, textureOrPair)) {
      texture = textureOrPair;
      sampler = null;
    } else {
      texture = textureOrPair.texture;
      sampler = textureOrPair.sampler;
    }

    gl.uniform1i(location, unit);
    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(bindPoint, texture);
    gl.bindSampler(unit, sampler);
  } : function (texture) {
    gl.uniform1i(location, unit);
    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(bindPoint, texture);
  };
}

function samplerArraySetter(gl, type, unit, location, size) {
  var bindPoint = getBindPointForSamplerType(gl, type);
  var units = new Int32Array(size);

  for (var ii = 0; ii < size; ++ii) {
    units[ii] = unit + ii;
  }

  return utils.isWebGL2(gl) ? function (textures) {
    gl.uniform1iv(location, units);
    textures.forEach(function (textureOrPair, index) {
      gl.activeTexture(gl.TEXTURE0 + units[index]);
      var texture;
      var sampler;

      if (helper.isTexture(gl, textureOrPair)) {
        texture = textureOrPair;
        sampler = null;
      } else {
        texture = textureOrPair.texture;
        sampler = textureOrPair.sampler;
      }

      gl.bindSampler(unit, sampler);
      gl.bindTexture(bindPoint, texture);
    });
  } : function (textures) {
    gl.uniform1iv(location, units);
    textures.forEach(function (texture, index) {
      gl.activeTexture(gl.TEXTURE0 + units[index]);
      gl.bindTexture(bindPoint, texture);
    });
  };
}

typeMap[FLOAT] = {
  Type: Float32Array,
  size: 4,
  setter: floatSetter,
  arraySetter: floatArraySetter
};
typeMap[FLOAT_VEC2] = {
  Type: Float32Array,
  size: 8,
  setter: floatVec2Setter
};
typeMap[FLOAT_VEC3] = {
  Type: Float32Array,
  size: 12,
  setter: floatVec3Setter
};
typeMap[FLOAT_VEC4] = {
  Type: Float32Array,
  size: 16,
  setter: floatVec4Setter
};
typeMap[INT] = {
  Type: Int32Array,
  size: 4,
  setter: intSetter,
  arraySetter: intArraySetter
};
typeMap[INT_VEC2] = {
  Type: Int32Array,
  size: 8,
  setter: intVec2Setter
};
typeMap[INT_VEC3] = {
  Type: Int32Array,
  size: 12,
  setter: intVec3Setter
};
typeMap[INT_VEC4] = {
  Type: Int32Array,
  size: 16,
  setter: intVec4Setter
};
typeMap[UNSIGNED_INT] = {
  Type: Uint32Array,
  size: 4,
  setter: uintSetter,
  arraySetter: uintArraySetter
};
typeMap[UNSIGNED_INT_VEC2] = {
  Type: Uint32Array,
  size: 8,
  setter: uintVec2Setter
};
typeMap[UNSIGNED_INT_VEC3] = {
  Type: Uint32Array,
  size: 12,
  setter: uintVec3Setter
};
typeMap[UNSIGNED_INT_VEC4] = {
  Type: Uint32Array,
  size: 16,
  setter: uintVec4Setter
};
typeMap[BOOL] = {
  Type: Uint32Array,
  size: 4,
  setter: intSetter,
  arraySetter: intArraySetter
};
typeMap[BOOL_VEC2] = {
  Type: Uint32Array,
  size: 8,
  setter: intVec2Setter
};
typeMap[BOOL_VEC3] = {
  Type: Uint32Array,
  size: 12,
  setter: intVec3Setter
};
typeMap[BOOL_VEC4] = {
  Type: Uint32Array,
  size: 16,
  setter: intVec4Setter
};
typeMap[FLOAT_MAT2] = {
  Type: Float32Array,
  size: 16,
  setter: floatMat2Setter
};
typeMap[FLOAT_MAT3] = {
  Type: Float32Array,
  size: 36,
  setter: floatMat3Setter
};
typeMap[FLOAT_MAT4] = {
  Type: Float32Array,
  size: 64,
  setter: floatMat4Setter
};
typeMap[FLOAT_MAT2x3] = {
  Type: Float32Array,
  size: 24,
  setter: floatMat23Setter
};
typeMap[FLOAT_MAT2x4] = {
  Type: Float32Array,
  size: 32,
  setter: floatMat24Setter
};
typeMap[FLOAT_MAT3x2] = {
  Type: Float32Array,
  size: 24,
  setter: floatMat32Setter
};
typeMap[FLOAT_MAT3x4] = {
  Type: Float32Array,
  size: 48,
  setter: floatMat34Setter
};
typeMap[FLOAT_MAT4x2] = {
  Type: Float32Array,
  size: 32,
  setter: floatMat42Setter
};
typeMap[FLOAT_MAT4x3] = {
  Type: Float32Array,
  size: 48,
  setter: floatMat43Setter
};
typeMap[SAMPLER_2D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D
};
typeMap[SAMPLER_CUBE] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP
};
typeMap[SAMPLER_3D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_3D
};
typeMap[SAMPLER_2D_SHADOW] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D
};
typeMap[SAMPLER_2D_ARRAY] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY
};
typeMap[SAMPLER_2D_ARRAY_SHADOW] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY
};
typeMap[SAMPLER_CUBE_SHADOW] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP
};
typeMap[INT_SAMPLER_2D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D
};
typeMap[INT_SAMPLER_3D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_3D
};
typeMap[INT_SAMPLER_CUBE] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP
};
typeMap[INT_SAMPLER_2D_ARRAY] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY
};
typeMap[UNSIGNED_INT_SAMPLER_2D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D
};
typeMap[UNSIGNED_INT_SAMPLER_3D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_3D
};
typeMap[UNSIGNED_INT_SAMPLER_CUBE] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP
};
typeMap[UNSIGNED_INT_SAMPLER_2D_ARRAY] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY
};

function floatAttribSetter(gl, index) {
  return function (b) {
    gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
    gl.enableVertexAttribArray(index);
    gl.vertexAttribPointer(index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);

    if (b.divisor !== undefined) {
      gl.vertexAttribDivisor(index, b.divisor);
    }
  };
}

function intAttribSetter(gl, index) {
  return function (b) {
    gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
    gl.enableVertexAttribArray(index);
    gl.vertexAttribIPointer(index, b.numComponents || b.size, b.type || gl.INT, b.stride || 0, b.offset || 0);

    if (b.divisor !== undefined) {
      gl.vertexAttribDivisor(index, b.divisor);
    }
  };
}

function matAttribSetter(gl, index, typeInfo) {
  var defaultSize = typeInfo.size;
  var count = typeInfo.count;
  return function (b) {
    gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
    var numComponents = b.size || b.numComponents || defaultSize;
    var size = numComponents / count;
    var type = b.type || gl.FLOAT;
    var typeInfo = typeMap[type];
    var stride = typeInfo.size * numComponents;
    var normalize = b.normalize || false;
    var offset = b.offset || 0;
    var rowOffset = stride / count;

    for (var i = 0; i < count; ++i) {
      gl.enableVertexAttribArray(index + i);
      gl.vertexAttribPointer(index + i, size, type, normalize, stride, offset + rowOffset * i);

      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index + i, b.divisor);
      }
    }
  };
}

var attrTypeMap = {};
attrTypeMap[FLOAT] = {
  size: 4,
  setter: floatAttribSetter
};
attrTypeMap[FLOAT_VEC2] = {
  size: 8,
  setter: floatAttribSetter
};
attrTypeMap[FLOAT_VEC3] = {
  size: 12,
  setter: floatAttribSetter
};
attrTypeMap[FLOAT_VEC4] = {
  size: 16,
  setter: floatAttribSetter
};
attrTypeMap[INT] = {
  size: 4,
  setter: intAttribSetter
};
attrTypeMap[INT_VEC2] = {
  size: 8,
  setter: intAttribSetter
};
attrTypeMap[INT_VEC3] = {
  size: 12,
  setter: intAttribSetter
};
attrTypeMap[INT_VEC4] = {
  size: 16,
  setter: intAttribSetter
};
attrTypeMap[UNSIGNED_INT] = {
  size: 4,
  setter: intAttribSetter
};
attrTypeMap[UNSIGNED_INT_VEC2] = {
  size: 8,
  setter: intAttribSetter
};
attrTypeMap[UNSIGNED_INT_VEC3] = {
  size: 12,
  setter: intAttribSetter
};
attrTypeMap[UNSIGNED_INT_VEC4] = {
  size: 16,
  setter: intAttribSetter
};
attrTypeMap[BOOL] = {
  size: 4,
  setter: intAttribSetter
};
attrTypeMap[BOOL_VEC2] = {
  size: 8,
  setter: intAttribSetter
};
attrTypeMap[BOOL_VEC3] = {
  size: 12,
  setter: intAttribSetter
};
attrTypeMap[BOOL_VEC4] = {
  size: 16,
  setter: intAttribSetter
};
attrTypeMap[FLOAT_MAT2] = {
  size: 4,
  setter: matAttribSetter,
  count: 2
};
attrTypeMap[FLOAT_MAT3] = {
  size: 9,
  setter: matAttribSetter,
  count: 3
};
attrTypeMap[FLOAT_MAT4] = {
  size: 16,
  setter: matAttribSetter,
  count: 4
}; // make sure we don't see a global gl

var gl = undefined; // eslint-disable-line

/**
 * Error Callback
 * @callback ErrorCallback
 * @param {string} msg error message.
 * @param {number} [lineOffset] amount to add to line number
 * @memberOf module:twgl
 */

function addLineNumbers(src, lineOffset) {
  lineOffset = lineOffset || 0;
  ++lineOffset;
  return src.split("\n").map(function (line, ndx) {
    return ndx + lineOffset + ": " + line;
  }).join("\n");
}

var spaceRE = /^[ \t]*\n/;
/**
 * Loads a shader.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {string} shaderSource The shader source.
 * @param {number} shaderType The type of shader.
 * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors.
 * @return {WebGLShader} The created shader.
 */

function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {
  var errFn = opt_errorCallback || error; // Create the shader object

  var shader = gl.createShader(shaderType); // Remove the first end of line because WebGL 2.0 requires
  // #version 300 es
  // as the first line. No whitespace allowed before that line
  // so
  //
  // <script>
  // #version 300 es
  // </script>
  //
  // Has one line before it which is invalid according to GLSL ES 3.00
  //

  var lineOffset = 0;

  if (spaceRE.test(shaderSource)) {
    lineOffset = 1;
    shaderSource = shaderSource.replace(spaceRE, '');
  } // Load the shader source


  gl.shaderSource(shader, shaderSource); // Compile the shader

  gl.compileShader(shader); // Check the compile status

  var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

  if (!compiled) {
    // Something went wrong during compilation; get the error
    var lastError = gl.getShaderInfoLog(shader);
    errFn(addLineNumbers(shaderSource, lineOffset) + "\n*** Error compiling shader: " + lastError);
    gl.deleteShader(shader);
    return null;
  }

  return shader;
}
/**
 * @typedef {Object} ProgramOptions
 * @property {function(string)} [errorCallback] callback for errors
 * @property {Object.<string,number>} [attribLocations] a attribute name to location map
 * @property {(module:twgl.BufferInfo|Object.<string,module:twgl.AttribInfo>|string[])} [transformFeedbackVaryings] If passed
 *   a BufferInfo will use the attribs names inside. If passed an object of AttribInfos will use the names from that object. Otherwise
 *   you can pass an array of names.
 * @property {number} [transformFeedbackMode] the mode to pass `gl.transformFeedbackVaryings`. Defaults to `SEPARATE_ATTRIBS`.
 * @memberOf module:twgl
 */

/**
 * Gets the program options based on all these optional arguments
 * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {module:twgl.ProgramOptions} an instance of ProgramOptions based on the arguments pased on
 */


function getProgramOptions(opt_attribs, opt_locations, opt_errorCallback) {
  var transformFeedbackVaryings;

  if (typeof opt_locations === 'function') {
    opt_errorCallback = opt_locations;
    opt_locations = undefined;
  }

  if (typeof opt_attribs === 'function') {
    opt_errorCallback = opt_attribs;
    opt_attribs = undefined;
  } else if (opt_attribs && !Array.isArray(opt_attribs)) {
    // If we have an errorCallback we can just return this object
    // Otherwise we need to construct one with default errorCallback
    if (opt_attribs.errorCallback) {
      return opt_attribs;
    }

    var opt = opt_attribs;
    opt_errorCallback = opt.errorCallback;
    opt_attribs = opt.attribLocations;
    transformFeedbackVaryings = opt.transformFeedbackVaryings;
  }

  var options = {
    errorCallback: opt_errorCallback || error,
    transformFeedbackVaryings: transformFeedbackVaryings
  };

  if (opt_attribs) {
    var attribLocations = {};

    if (Array.isArray(opt_attribs)) {
      opt_attribs.forEach(function (attrib, ndx) {
        attribLocations[attrib] = opt_locations ? opt_locations[ndx] : ndx;
      });
    } else {
      attribLocations = opt_attribs;
    }

    options.attribLocations = attribLocations;
  }

  return options;
}

var defaultShaderType = ["VERTEX_SHADER", "FRAGMENT_SHADER"];

function getShaderTypeFromScriptType(scriptType) {
  if (scriptType.indexOf("frag") >= 0) {
    return gl.FRAGMENT_SHADER;
  } else if (scriptType.indexOf("vert") >= 0) {
    return gl.VERTEX_SHADER;
  }

  return undefined;
}

function deleteShaders(gl, shaders) {
  shaders.forEach(function (shader) {
    gl.deleteShader(shader);
  });
}
/**
 * Creates a program, attaches (and/or compiles) shaders, binds attrib locations, links the
 * program and calls useProgram.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgram(gl, [vs, fs], options);
 *     twgl.createProgram(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLShader[]|string[]} shaders The shaders to attach, or element ids for their source, or strings that contain their source
 * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error.
 * @memberOf module:twgl/programs
 */


function createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {
  var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  var realShaders = [];
  var newShaders = [];

  for (var ndx = 0; ndx < shaders.length; ++ndx) {
    var shader = shaders[ndx];

    if (typeof shader === 'string') {
      var elem = getElementById(shader);
      var src = elem ? elem.text : shader;
      var type = gl[defaultShaderType[ndx]];

      if (elem && elem.type) {
        type = getShaderTypeFromScriptType(elem.type) || type;
      }

      shader = loadShader(gl, src, type, progOptions.errorCallback);
      newShaders.push(shader);
    }

    if (helper.isShader(gl, shader)) {
      realShaders.push(shader);
    }
  }

  if (realShaders.length !== shaders.length) {
    progOptions.errorCallback("not enough shaders for program");
    deleteShaders(gl, newShaders);
    return null;
  }

  var program = gl.createProgram();
  realShaders.forEach(function (shader) {
    gl.attachShader(program, shader);
  });

  if (progOptions.attribLocations) {
    Object.keys(progOptions.attribLocations).forEach(function (attrib) {
      gl.bindAttribLocation(program, progOptions.attribLocations[attrib], attrib);
    });
  }

  var varyings = progOptions.transformFeedbackVaryings;

  if (varyings) {
    if (varyings.attribs) {
      varyings = varyings.attribs;
    }

    if (!Array.isArray(varyings)) {
      varyings = Object.keys(varyings);
    }

    gl.transformFeedbackVaryings(program, varyings, progOptions.transformFeedbackMode || gl.SEPARATE_ATTRIBS);
  }

  gl.linkProgram(program); // Check the link status

  var linked = gl.getProgramParameter(program, gl.LINK_STATUS);

  if (!linked) {
    // something went wrong with the link
    var lastError = gl.getProgramInfoLog(program);
    progOptions.errorCallback("Error in program linking:" + lastError);
    gl.deleteProgram(program);
    deleteShaders(gl, newShaders);
    return null;
  }

  return program;
}
/**
 * Loads a shader from a script tag.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {string} scriptId The id of the script tag.
 * @param {number} [opt_shaderType] The type of shader. If not passed in it will
 *     be derived from the type of the script tag.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors.
 * @return {WebGLShader?} The created shader or null if error.
 */


function createShaderFromScript(gl, scriptId, opt_shaderType, opt_errorCallback) {
  var shaderSource = "";
  var shaderScript = getElementById(scriptId);

  if (!shaderScript) {
    throw "*** Error: unknown script element" + scriptId;
  }

  shaderSource = shaderScript.text;
  var shaderType = opt_shaderType || getShaderTypeFromScriptType(shaderScript.type);

  if (!shaderType) {
    throw "*** Error: unknown shader type";
  }

  return loadShader(gl, shaderSource, shaderType, opt_errorCallback);
}
/**
 * Creates a program from 2 script tags.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_options);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderScriptIds Array of ids of the script
 *        tags for the shaders. The first is assumed to be the
 *        vertex shader, the second the fragment shader.
 * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
 * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram} The created program.
 * @memberOf module:twgl/programs
 */


function createProgramFromScripts(gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {
  var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  var shaders = [];

  for (var ii = 0; ii < shaderScriptIds.length; ++ii) {
    var shader = createShaderFromScript(gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], progOptions.errorCallback);

    if (!shader) {
      return null;
    }

    shaders.push(shader);
  }

  return createProgram(gl, shaders, progOptions);
}
/**
 * Creates a program from 2 sources.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_options);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
 * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram} The created program.
 * @memberOf module:twgl/programs
 */


function createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
  var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  var shaders = [];

  for (var ii = 0; ii < shaderSources.length; ++ii) {
    var shader = loadShader(gl, shaderSources[ii], gl[defaultShaderType[ii]], progOptions.errorCallback);

    if (!shader) {
      return null;
    }

    shaders.push(shader);
  }

  return createProgram(gl, shaders, progOptions);
}
/**
 * Returns true if attribute/uniform is a reserved/built in
 *
 * It makes no sense to me why GL returns these because it's
 * illegal to call `gl.getUniformLocation` and `gl.getAttribLocation`
 * with names that start with `gl_` (and `webgl_` in WebGL)
 *
 * I can only assume they are there because they might count
 * when computing the number of uniforms/attributes used when you want to
 * know if you are near the limit. That doesn't really make sense
 * to me but the fact that these get returned are in the spec.
 *
 * @param {WebGLActiveInfo} info As returned from `gl.getActiveUniform` or
 *    `gl.getActiveAttrib`.
 * @return {bool} true if it's reserved
 */


function isBuiltIn(info) {
  var name = info.name;
  return name.startsWith("gl_") || name.startsWith("webgl_");
}
/**
 * Creates setter functions for all uniforms of a shader
 * program.
 *
 * @see {@link module:twgl.setUniforms}
 *
 * @param {WebGLProgram} program the program to create setters for.
 * @returns {Object.<string, function>} an object with a setter by name for each uniform
 * @memberOf module:twgl/programs
 */


function createUniformSetters(gl, program) {
  var textureUnit = 0;
  /**
   * Creates a setter for a uniform of the given program with it's
   * location embedded in the setter.
   * @param {WebGLProgram} program
   * @param {WebGLUniformInfo} uniformInfo
   * @returns {function} the created setter.
   */

  function createUniformSetter(program, uniformInfo) {
    var location = gl.getUniformLocation(program, uniformInfo.name);
    var isArray = uniformInfo.size > 1 && uniformInfo.name.substr(-3) === "[0]";
    var type = uniformInfo.type;
    var typeInfo = typeMap[type];

    if (!typeInfo) {
      throw "unknown type: 0x" + type.toString(16); // we should never get here.
    }

    var setter;

    if (typeInfo.bindPoint) {
      // it's a sampler
      var unit = textureUnit;
      textureUnit += uniformInfo.size;

      if (isArray) {
        setter = typeInfo.arraySetter(gl, type, unit, location, uniformInfo.size);
      } else {
        setter = typeInfo.setter(gl, type, unit, location, uniformInfo.size);
      }
    } else {
      if (typeInfo.arraySetter && isArray) {
        setter = typeInfo.arraySetter(gl, location);
      } else {
        setter = typeInfo.setter(gl, location);
      }
    }

    setter.location = location;
    return setter;
  }

  var uniformSetters = {};
  var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

  for (var ii = 0; ii < numUniforms; ++ii) {
    var uniformInfo = gl.getActiveUniform(program, ii);

    if (isBuiltIn(uniformInfo)) {
      continue;
    }

    var name = uniformInfo.name; // remove the array suffix.

    if (name.substr(-3) === "[0]") {
      name = name.substr(0, name.length - 3);
    }

    var setter = createUniformSetter(program, uniformInfo);
    uniformSetters[name] = setter;
  }

  return uniformSetters;
}
/**
 * @typedef {Object} TransformFeedbackInfo
 * @property {number} index index of transform feedback
 * @property {number} type GL type
 * @property {number} size 1 - 4
 * @memberOf module:twgl
 */

/**
 * Create TransformFeedbackInfo for passing to bind/unbindTransformFeedbackInfo.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program an existing WebGLProgram.
 * @return {Object<string, module:twgl.TransformFeedbackInfo>}
 * @memberOf module:twgl
 */


function createTransformFeedbackInfo(gl, program) {
  var info = {};
  var numVaryings = gl.getProgramParameter(program, gl.TRANSFORM_FEEDBACK_VARYINGS);

  for (var ii = 0; ii < numVaryings; ++ii) {
    var varying = gl.getTransformFeedbackVarying(program, ii);
    info[varying.name] = {
      index: ii,
      type: varying.type,
      size: varying.size
    };
  }

  return info;
}
/**
 * Binds buffers for transform feedback.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {(module:twgl.ProgramInfo|Object<string, module:twgl.TransformFeedbackInfo>)} transformFeedbackInfo A ProgramInfo or TransformFeedbackInfo.
 * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.
 * @memberOf module:twgl
 */


function bindTransformFeedbackInfo(gl, transformFeedbackInfo, bufferInfo) {
  if (transformFeedbackInfo.transformFeedbackInfo) {
    transformFeedbackInfo = transformFeedbackInfo.transformFeedbackInfo;
  }

  if (bufferInfo.attribs) {
    bufferInfo = bufferInfo.attribs;
  }

  for (var name in bufferInfo) {
    var varying = transformFeedbackInfo[name];

    if (varying) {
      var buf = bufferInfo[name];

      if (buf.offset) {
        gl.bindBufferRange(gl.TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer, buf.offset, buf.size);
      } else {
        gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer);
      }
    }
  }
}
/**
 * Unbinds buffers afetr transform feedback.
 *
 * Buffers can not be bound to 2 bind points so if you try to bind a buffer used
 * in a transform feedback as an ARRAY_BUFFER for an attribute it will fail.
 *
 * This function unbinds all buffers that were bound with {@link module:twgl.bindTransformFeedbackInfo}.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {(module:twgl.ProgramInfo|Object<string, module:twgl.TransformFeedbackInfo>)} transformFeedbackInfo A ProgramInfo or TransformFeedbackInfo.
 * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.
 */


function unbindTransformFeedbackInfo(gl, transformFeedbackInfo, bufferInfo) {
  if (transformFeedbackInfo.transformFeedbackInfo) {
    transformFeedbackInfo = transformFeedbackInfo.transformFeedbackInfo;
  }

  if (bufferInfo.attribs) {
    bufferInfo = bufferInfo.attribs;
  }

  for (var name in bufferInfo) {
    var varying = transformFeedbackInfo[name];

    if (varying) {
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, varying.index, null);
    }
  }
}
/**
 * Creates a transform feedback and sets the buffers
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}
 * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.
 * @return {WebGLTransformFeedback} the created transform feedback
 * @memberOf module:twgl
 */


function createTransformFeedback(gl, programInfo, bufferInfo) {
  var tf = gl.createTransformFeedback();
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);
  gl.useProgram(programInfo.program);
  bindTransformFeedbackInfo(gl, programInfo, bufferInfo);
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null); // This is only needed because of a bug in Chrome 56. Will remove
  // when chrome fixes it.

  unbindTransformFeedbackInfo(gl, programInfo, bufferInfo);
  return tf;
}
/**
 * @typedef {Object} UniformData
 * @property {number} type The WebGL type enum for this uniform
 * @property {number} size The number of elements for this uniform
 * @property {number} blockNdx The block index this uniform appears in
 * @property {number} offset The byte offset in the block for this uniform's value
 * @memberOf module:twgl
 */

/**
 * The specification for one UniformBlockObject
 *
 * @typedef {Object} BlockSpec
 * @property {number} index The index of the block.
 * @property {number} size The size in bytes needed for the block
 * @property {number[]} uniformIndices The indices of the uniforms used by the block. These indices
 *    correspond to entries in a UniformData array in the {@link module:twgl.UniformBlockSpec}.
 * @property {bool} usedByVertexShader Self explanitory
 * @property {bool} usedByFragmentShader Self explanitory
 * @property {bool} used Self explanitory
 * @memberOf module:twgl
 */

/**
 * A `UniformBlockSpec` represents the data needed to create and bind
 * UniformBlockObjects for a given program
 *
 * @typedef {Object} UniformBlockSpec
 * @property {Object.<string, module:twgl.BlockSpec> blockSpecs The BlockSpec for each block by block name
 * @property {UniformData[]} uniformData An array of data for each uniform by uniform index.
 * @memberOf module:twgl
 */

/**
 * Creates a UniformBlockSpec for the given program.
 *
 * A UniformBlockSpec represents the data needed to create and bind
 * UniformBlockObjects
 *
 * @param {WebGL2RenderingContext} gl A WebGL2 Rendering Context
 * @param {WebGLProgram} program A WebGLProgram for a successfully linked program
 * @return {module:twgl.UniformBlockSpec} The created UniformBlockSpec
 * @memberOf module:twgl/programs
 */


function createUniformBlockSpecFromProgram(gl, program) {
  var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  var uniformData = [];
  var uniformIndices = [];

  for (var ii = 0; ii < numUniforms; ++ii) {
    uniformIndices.push(ii);
    uniformData.push({});
    var uniformInfo = gl.getActiveUniform(program, ii);

    if (isBuiltIn(uniformInfo)) {
      break;
    } // REMOVE [0]?


    uniformData[ii].name = uniformInfo.name;
  }

  [["UNIFORM_TYPE", "type"], ["UNIFORM_SIZE", "size"], // num elements
  ["UNIFORM_BLOCK_INDEX", "blockNdx"], ["UNIFORM_OFFSET", "offset"]].forEach(function (pair) {
    var pname = pair[0];
    var key = pair[1];
    gl.getActiveUniforms(program, uniformIndices, gl[pname]).forEach(function (value, ndx) {
      uniformData[ndx][key] = value;
    });
  });
  var blockSpecs = {};
  var numUniformBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);

  for (var _ii = 0; _ii < numUniformBlocks; ++_ii) {
    var name = gl.getActiveUniformBlockName(program, _ii);
    var blockSpec = {
      index: _ii,
      usedByVertexShader: gl.getActiveUniformBlockParameter(program, _ii, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),
      usedByFragmentShader: gl.getActiveUniformBlockParameter(program, _ii, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),
      size: gl.getActiveUniformBlockParameter(program, _ii, gl.UNIFORM_BLOCK_DATA_SIZE),
      uniformIndices: gl.getActiveUniformBlockParameter(program, _ii, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES)
    };
    blockSpec.used = blockSpec.usedByVertexSahder || blockSpec.usedByFragmentShader;
    blockSpecs[name] = blockSpec;
  }

  return {
    blockSpecs: blockSpecs,
    uniformData: uniformData
  };
}

var arraySuffixRE = /\[\d+\]\.$/; // better way to check?

/**
 * Represents a UniformBlockObject including an ArrayBuffer with all the uniform values
 * and a corresponding WebGLBuffer to hold those values on the GPU
 *
 * @typedef {Object} UniformBlockInfo
 * @property {string} name The name of the block
 * @property {ArrayBuffer} array The array buffer that contains the uniform values
 * @property {Float32Array} asFloat A float view on the array buffer. This is useful
 *    inspecting the contents of the buffer in the debugger.
 * @property {WebGLBuffer} buffer A WebGL buffer that will hold a copy of the uniform values for rendering.
 * @property {number} [offset] offset into buffer
 * @property {Object.<string, ArrayBufferView>} uniforms A uniform name to ArrayBufferView map.
 *   each Uniform has a correctly typed `ArrayBufferView` into array at the correct offset
 *   and length of that uniform. So for example a float uniform would have a 1 float `Float32Array`
 *   view. A single mat4 would have a 16 element `Float32Array` view. An ivec2 would have an
 *   `Int32Array` view, etc.
 * @memberOf module:twgl
 */

/**
 * Creates a `UniformBlockInfo` for the specified block
 *
 * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy
 * `UniformBlockInfo` is returned**. This is because when debugging GLSL
 * it is common to comment out large portions of a shader or for example set
 * the final output to a constant. When that happens blocks get optimized out.
 * If this function did not create dummy blocks your code would crash when debugging.
 *
 * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext
 * @param {WebGLProgram} program A WebGLProgram
 * @param {module:twgl.UniformBlockSpec} uinformBlockSpec. A UniformBlockSpec as returned
 *     from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {string} blockName The name of the block.
 * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo
 * @memberOf module:twgl/programs
 */

function createUniformBlockInfoFromProgram(gl, program, uniformBlockSpec, blockName) {
  var blockSpecs = uniformBlockSpec.blockSpecs;
  var uniformData = uniformBlockSpec.uniformData;
  var blockSpec = blockSpecs[blockName];

  if (!blockSpec) {
    warn("no uniform block object named:", blockName);
    return {
      name: blockName,
      uniforms: {}
    };
  }

  var array = new ArrayBuffer(blockSpec.size);
  var buffer = gl.createBuffer();
  var uniformBufferIndex = blockSpec.index;
  gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
  gl.uniformBlockBinding(program, blockSpec.index, uniformBufferIndex);
  var prefix = blockName + ".";

  if (arraySuffixRE.test(prefix)) {
    prefix = prefix.replace(arraySuffixRE, ".");
  }

  var uniforms = {};
  blockSpec.uniformIndices.forEach(function (uniformNdx) {
    var data = uniformData[uniformNdx];
    var typeInfo = typeMap[data.type];
    var Type = typeInfo.Type;
    var length = data.size * typeInfo.size;
    var name = data.name;

    if (name.substr(0, prefix.length) === prefix) {
      name = name.substr(prefix.length);
    }

    uniforms[name] = new Type(array, data.offset, length / Type.BYTES_PER_ELEMENT);
  });
  return {
    name: blockName,
    array: array,
    asFloat: new Float32Array(array),
    // for debugging
    buffer: buffer,
    uniforms: uniforms
  };
}
/**
 * Creates a `UniformBlockInfo` for the specified block
 *
 * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy
 * `UniformBlockInfo` is returned**. This is because when debugging GLSL
 * it is common to comment out large portions of a shader or for example set
 * the final output to a constant. When that happens blocks get optimized out.
 * If this function did not create dummy blocks your code would crash when debugging.
 *
 * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext
 * @param {module:twgl.ProgramInfo} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo}
 * @param {string} blockName The name of the block.
 * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo
 * @memberOf module:twgl/programs
 */


function createUniformBlockInfo(gl, programInfo, blockName) {
  return createUniformBlockInfoFromProgram(gl, programInfo.program, programInfo.uniformBlockSpec, blockName);
}
/**
 * Binds a unform block to the matching uniform block point.
 * Matches by blocks by name so blocks must have the same name not just the same
 * structure.
 *
 * If you have changed any values and you upload the valus into the corresponding WebGLBuffer
 * call {@link module:twgl.setUniformBlock} instead.
 *
 * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.
 * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as
 *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from
 *     {@link module:twgl.createUniformBlockInfo}.
 * @return {bool} true if buffer was bound. If the programInfo has no block with the same block name
 *     no buffer is bound.
 * @memberOf module:twgl/programs
 */


function bindUniformBlock(gl, programInfo, uniformBlockInfo) {
  var uniformBlockSpec = programInfo.uniformBlockSpec || programInfo;
  var blockSpec = uniformBlockSpec.blockSpecs[uniformBlockInfo.name];

  if (blockSpec) {
    var bufferBindIndex = blockSpec.index;
    gl.bindBufferRange(gl.UNIFORM_BUFFER, bufferBindIndex, uniformBlockInfo.buffer, uniformBlockInfo.offset || 0, uniformBlockInfo.array.byteLength);
    return true;
  }

  return false;
}
/**
 * Uploads the current uniform values to the corresponding WebGLBuffer
 * and binds that buffer to the program's corresponding bind point for the uniform block object.
 *
 * If you haven't changed any values and you only need to bind the uniform block object
 * call {@link module:twgl.bindUniformBlock} instead.
 *
 * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.
 * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as
 *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from
 *     {@link module:twgl.createUniformBlockInfo}.
 * @memberOf module:twgl/programs
 */


function setUniformBlock(gl, programInfo, uniformBlockInfo) {
  if (bindUniformBlock(gl, programInfo, uniformBlockInfo)) {
    gl.bufferData(gl.UNIFORM_BUFFER, uniformBlockInfo.array, gl.DYNAMIC_DRAW);
  }
}
/**
 * Sets values of a uniform block object
 *
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo A UniformBlockInfo as returned by {@link module:twgl.createUniformBlockInfo}.
 * @param {Object.<string, ?>} values A uniform name to value map where the value is correct for the given
 *    type of uniform. So for example given a block like
 *
 *       uniform SomeBlock {
 *         float someFloat;
 *         vec2 someVec2;
 *         vec3 someVec3Array[2];
 *         int someInt;
 *       }
 *
 *  You can set the values of the uniform block with
 *
 *       twgl.setBlockUniforms(someBlockInfo, {
 *          someFloat: 12.3,
 *          someVec2: [1, 2],
 *          someVec3Array: [1, 2, 3, 4, 5, 6],
 *          someInt: 5,
 *       }
 *
 *  Arrays can be JavaScript arrays or typed arrays
 *
 *  Any name that doesn't match will be ignored
 * @memberOf module:twgl/programs
 */


function setBlockUniforms(uniformBlockInfo, values) {
  var uniforms = uniformBlockInfo.uniforms;

  for (var name in values) {
    var array = uniforms[name];

    if (array) {
      var value = values[name];

      if (value.length) {
        array.set(value);
      } else {
        array[0] = value;
      }
    }
  }
}
/**
 * Set uniforms and binds related textures.
 *
 * example:
 *
 *     const programInfo = createProgramInfo(
 *         gl, ["some-vs", "some-fs"]);
 *
 *     const tex1 = gl.createTexture();
 *     const tex2 = gl.createTexture();
 *
 *     ... assume we setup the textures with data ...
 *
 *     const uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     gl.useProgram(program);
 *
 * This will automatically bind the textures AND set the
 * uniforms.
 *
 *     twgl.setUniforms(programInfo, uniforms);
 *
 * For the example above it is equivalent to
 *
 *     var texUnit = 0;
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex1);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex2);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);
 *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);
 *     gl.uniformMatrix4fv(u_someMatrix, false, [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ]);
 *
 * Note it is perfectly reasonable to call `setUniforms` multiple times. For example
 *
 *     const uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *     };
 *
 *     const moreUniforms {
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     twgl.setUniforms(programInfo, uniforms);
 *     twgl.setUniforms(programInfo, moreUniforms);
 *
 * You can also add WebGLSamplers to uniform samplers as in
 *
 *     const uniforms = {
 *       u_someSampler: {
 *         texture: someWebGLTexture,
 *         sampler: someWebGLSampler,
 *       },
 *     };
 *
 * In which case both the sampler and texture will be bound to the
 * same unit.
 *
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from
 *        `createUniformSetters`.
 * @param {Object.<string, ?>} values an object with values for the
 *        uniforms.
 *   You can pass multiple objects by putting them in an array or by calling with more arguments.For example
 *
 *     const sharedUniforms = {
 *       u_fogNear: 10,
 *       u_projection: ...
 *       ...
 *     };
 *
 *     const localUniforms = {
 *       u_world: ...
 *       u_diffuseColor: ...
 *     };
 *
 *     twgl.setUniforms(programInfo, sharedUniforms, localUniforms);
 *
 *     // is the same as
 *
 *     twgl.setUniforms(programInfo, [sharedUniforms, localUniforms]);
 *
 *     // is the same as
 *
 *     twgl.setUniforms(programInfo, sharedUniforms);
 *     twgl.setUniforms(programInfo, localUniforms};
 *
 * @memberOf module:twgl/programs
 */


function setUniforms(setters, values) {
  // eslint-disable-line
  var actualSetters = setters.uniformSetters || setters;
  var numArgs = arguments.length;

  for (var andx = 1; andx < numArgs; ++andx) {
    var vals = arguments[andx];

    if (Array.isArray(vals)) {
      var numValues = vals.length;

      for (var ii = 0; ii < numValues; ++ii) {
        setUniforms(actualSetters, vals[ii]);
      }
    } else {
      for (var name in vals) {
        var setter = actualSetters[name];

        if (setter) {
          setter(vals[name]);
        }
      }
    }
  }
}
/**
 * Creates setter functions for all attributes of a shader
 * program. You can pass this to {@link module:twgl.setBuffersAndAttributes} to set all your buffers and attributes.
 *
 * @see {@link module:twgl.setAttributes} for example
 * @param {WebGLProgram} program the program to create setters for.
 * @return {Object.<string, function>} an object with a setter for each attribute by name.
 * @memberOf module:twgl/programs
 */


function createAttributeSetters(gl, program) {
  var attribSetters = {};
  var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

  for (var ii = 0; ii < numAttribs; ++ii) {
    var attribInfo = gl.getActiveAttrib(program, ii);

    if (isBuiltIn(attribInfo)) {
      continue;
    }

    var index = gl.getAttribLocation(program, attribInfo.name);
    var typeInfo = attrTypeMap[attribInfo.type];
    var setter = typeInfo.setter(gl, index, typeInfo);
    setter.location = index;
    attribSetters[attribInfo.name] = setter;
  }

  return attribSetters;
}
/**
 * Sets attributes and binds buffers (deprecated... use {@link module:twgl.setBuffersAndAttributes})
 *
 * Example:
 *
 *     const program = createProgramFromScripts(
 *         gl, ["some-vs", "some-fs");
 *
 *     const attribSetters = createAttributeSetters(program);
 *
 *     const positionBuffer = gl.createBuffer();
 *     const texcoordBuffer = gl.createBuffer();
 *
 *     const attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *     };
 *
 *     gl.useProgram(program);
 *
 * This will automatically bind the buffers AND set the
 * attributes.
 *
 *     setAttributes(attribSetters, attribs);
 *
 * Properties of attribs. For each attrib you can add
 * properties:
 *
 * *   type: the type of data in the buffer. Default = gl.FLOAT
 * *   normalize: whether or not to normalize the data. Default = false
 * *   stride: the stride. Default = 0
 * *   offset: offset into the buffer. Default = 0
 * *   divisor: the divisor for instances. Default = undefined
 *
 * For example if you had 3 value float positions, 2 value
 * float texcoord and 4 value uint8 colors you'd setup your
 * attribs like this
 *
 *     const attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *       a_color: {
 *         buffer: colorBuffer,
 *         numComponents: 4,
 *         type: gl.UNSIGNED_BYTE,
 *         normalize: true,
 *       },
 *     };
 *
 * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
 * @param {Object.<string, module:twgl.AttribInfo>} buffers AttribInfos mapped by attribute name.
 * @memberOf module:twgl/programs
 * @deprecated use {@link module:twgl.setBuffersAndAttributes}
 */


function setAttributes(setters, buffers) {
  for (var name in buffers) {
    var setter = setters[name];

    if (setter) {
      setter(buffers[name]);
    }
  }
}
/**
 * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate
 *
 * Example:
 *
 *     const programInfo = createProgramInfo(
 *         gl, ["some-vs", "some-fs");
 *
 *     const arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *     };
 *
 *     const bufferInfo = createBufferInfoFromArrays(gl, arrays);
 *
 *     gl.useProgram(programInfo.program);
 *
 * This will automatically bind the buffers AND set the
 * attributes.
 *
 *     setBuffersAndAttributes(gl, programInfo, bufferInfo);
 *
 * For the example above it is equivilent to
 *
 *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
 *     gl.enableVertexAttribArray(a_positionLocation);
 *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
 *     gl.enableVertexAttribArray(a_texcoordLocation);
 *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters A `ProgramInfo` as returned from {@link module:twgl.createProgrmaInfo} or Attribute setters as returned from {@link module:twgl.createAttributeSetters}
 * @param {(module:twgl.BufferInfo|module:twgl.vertexArrayInfo)} buffers a `BufferInfo` as returned from {@link module:twgl.createBufferInfoFromArrays}.
 *   or a `VertexArrayInfo` as returned from {@link module:twgl.createVertexArrayInfo}
 * @memberOf module:twgl/programs
 */


function setBuffersAndAttributes(gl, programInfo, buffers) {
  if (buffers.vertexArrayObject) {
    gl.bindVertexArray(buffers.vertexArrayObject);
  } else {
    setAttributes(programInfo.attribSetters || programInfo, buffers.attribs);

    if (buffers.indices) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
    }
  }
}
/**
 * @typedef {Object} ProgramInfo
 * @property {WebGLProgram} program A shader program
 * @property {Object<string, function>} uniformSetters object of setters as returned from createUniformSetters,
 * @property {Object<string, function>} attribSetters object of setters as returned from createAttribSetters,
 * @propetty {module:twgl.UniformBlockSpec} [uniformBlockSpace] a uniform block spec for making UniformBlockInfos with createUniformBlockInfo etc..
 * @property {Object<string, module:twgl.TransformFeedbackInfo>} [transformFeedbackInfo] info for transform feedbacks
 * @memberOf module:twgl
 */

/**
 * Creates a ProgramInfo from an existing program.
 *
 * A ProgramInfo contains
 *
 *     programInfo = {
 *        program: WebGLProgram,
 *        uniformSetters: object of setters as returned from createUniformSetters,
 *        attribSetters: object of setters as returned from createAttribSetters,
 *     }
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {WebGLProgram} program an existing WebGLProgram.
 * @return {module:twgl.ProgramInfo} The created ProgramInfo.
 * @memberOf module:twgl/programs
 */


function createProgramInfoFromProgram(gl, program) {
  var uniformSetters = createUniformSetters(gl, program);
  var attribSetters = createAttributeSetters(gl, program);
  var programInfo = {
    program: program,
    uniformSetters: uniformSetters,
    attribSetters: attribSetters
  };

  if (utils.isWebGL2(gl)) {
    programInfo.uniformBlockSpec = createUniformBlockSpecFromProgram(gl, program);
    programInfo.transformFeedbackInfo = createTransformFeedbackInfo(gl, program);
  }

  return programInfo;
}
/**
 * Creates a ProgramInfo from 2 sources.
 *
 * A ProgramInfo contains
 *
 *     programInfo = {
 *        program: WebGLProgram,
 *        uniformSetters: object of setters as returned from createUniformSetters,
 *        attribSetters: object of setters as returned from createAttribSetters,
 *     }
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramInfo(gl, [vs, fs], options);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders or ids. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations] The locations for the attributes. A parallel array to opt_attribs letting you assign locations.
 * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {module:twgl.ProgramInfo?} The created ProgramInfo or null if it failed to link or compile
 * @memberOf module:twgl/programs
 */


function createProgramInfo(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
  var progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  var good = true;
  shaderSources = shaderSources.map(function (source) {
    // Lets assume if there is no \n it's an id
    if (source.indexOf("\n") < 0) {
      var script = getElementById(source);

      if (!script) {
        progOptions.errorCallback("no element with id: " + source);
        good = false;
      } else {
        source = script.text;
      }
    }

    return source;
  });

  if (!good) {
    return null;
  }

  var program = createProgramFromSources(gl, shaderSources, progOptions);

  if (!program) {
    return null;
  }

  return createProgramInfoFromProgram(gl, program);
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.axisRotate = axisRotate;
exports.axisRotation = axisRotation;
exports.copy = copy;
exports.frustum = frustum;
exports.getAxis = getAxis;
exports.getTranslation = getTranslation;
exports.identity = identity;
exports.inverse = inverse;
exports.lookAt = lookAt;
exports.multiply = multiply;
exports.negate = negate;
exports.ortho = ortho;
exports.perspective = perspective;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.rotationX = rotationX;
exports.rotationY = rotationY;
exports.rotationZ = rotationZ;
exports.scale = scale;
exports.scaling = scaling;
exports.setAxis = setAxis;
exports.setDefaultType = setDefaultType;
exports.setTranslation = setTranslation;
exports.transformDirection = transformDirection;
exports.transformNormal = transformNormal;
exports.transformPoint = transformPoint;
exports.translate = translate;
exports.translation = translation;
exports.transpose = transpose;

var v3 = _interopRequireWildcard(__webpack_require__(3));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/*
 * Copyright 2015, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * 4x4 Matrix math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new matrix. In other words you can do this
 *
 *     const mat = m4.translation([1, 2, 3]);  // Creates a new translation matrix
 *
 * or
 *
 *     const mat = m4.create();
 *     m4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any matrix as the destination. So for example
 *
 *     const mat = m4.identity();
 *     const trans = m4.translation([1, 2, 3]);
 *     m4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.
 *
 * @module twgl/m4
 */
var MatType = Float32Array;
var tempV3a = v3.create();
var tempV3b = v3.create();
var tempV3c = v3.create();
/**
 * A JavaScript array with 16 values or a Float32Array with 16 values.
 * When created by the library will create the default type which is `Float32Array`
 * but can be set by calling {@link module:twgl/m4.setDefaultType}.
 * @typedef {(number[]|Float32Array)} Mat4
 * @memberOf module:twgl/m4
 */

/**
 * Sets the type this library creates for a Mat4
 * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`
 * @return {constructor} previous constructor for Mat4
 */

function setDefaultType(ctor) {
  var oldType = MatType;
  MatType = ctor;
  return oldType;
}
/**
 * Negates a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} -m.
 * @memberOf module:twgl/m4
 */


function negate(m, dst) {
  dst = dst || new MatType(16);
  dst[0] = -m[0];
  dst[1] = -m[1];
  dst[2] = -m[2];
  dst[3] = -m[3];
  dst[4] = -m[4];
  dst[5] = -m[5];
  dst[6] = -m[6];
  dst[7] = -m[7];
  dst[8] = -m[8];
  dst[9] = -m[9];
  dst[10] = -m[10];
  dst[11] = -m[11];
  dst[12] = -m[12];
  dst[13] = -m[13];
  dst[14] = -m[14];
  dst[15] = -m[15];
  return dst;
}
/**
 * Copies a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] The matrix.
 * @return {module:twgl/m4.Mat4} A copy of m.
 * @memberOf module:twgl/m4
 */


function copy(m, dst) {
  dst = dst || new MatType(16);
  dst[0] = m[0];
  dst[1] = m[1];
  dst[2] = m[2];
  dst[3] = m[3];
  dst[4] = m[4];
  dst[5] = m[5];
  dst[6] = m[6];
  dst[7] = m[7];
  dst[8] = m[8];
  dst[9] = m[9];
  dst[10] = m[10];
  dst[11] = m[11];
  dst[12] = m[12];
  dst[13] = m[13];
  dst[14] = m[14];
  dst[15] = m[15];
  return dst;
}
/**
 * Creates an n-by-n identity matrix.
 *
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} An n-by-n identity matrix.
 * @memberOf module:twgl/m4
 */


function identity(dst) {
  dst = dst || new MatType(16);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Takes the transpose of a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} The transpose of m.
 * @memberOf module:twgl/m4
 */


function transpose(m, dst) {
  dst = dst || new MatType(16);

  if (dst === m) {
    var t;
    t = m[1];
    m[1] = m[4];
    m[4] = t;
    t = m[2];
    m[2] = m[8];
    m[8] = t;
    t = m[3];
    m[3] = m[12];
    m[12] = t;
    t = m[6];
    m[6] = m[9];
    m[9] = t;
    t = m[7];
    m[7] = m[13];
    m[13] = t;
    t = m[11];
    m[11] = m[14];
    m[14] = t;
    return dst;
  }

  var m00 = m[0 * 4 + 0];
  var m01 = m[0 * 4 + 1];
  var m02 = m[0 * 4 + 2];
  var m03 = m[0 * 4 + 3];
  var m10 = m[1 * 4 + 0];
  var m11 = m[1 * 4 + 1];
  var m12 = m[1 * 4 + 2];
  var m13 = m[1 * 4 + 3];
  var m20 = m[2 * 4 + 0];
  var m21 = m[2 * 4 + 1];
  var m22 = m[2 * 4 + 2];
  var m23 = m[2 * 4 + 3];
  var m30 = m[3 * 4 + 0];
  var m31 = m[3 * 4 + 1];
  var m32 = m[3 * 4 + 2];
  var m33 = m[3 * 4 + 3];
  dst[0] = m00;
  dst[1] = m10;
  dst[2] = m20;
  dst[3] = m30;
  dst[4] = m01;
  dst[5] = m11;
  dst[6] = m21;
  dst[7] = m31;
  dst[8] = m02;
  dst[9] = m12;
  dst[10] = m22;
  dst[11] = m32;
  dst[12] = m03;
  dst[13] = m13;
  dst[14] = m23;
  dst[15] = m33;
  return dst;
}
/**
 * Computes the inverse of a 4-by-4 matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} The inverse of m.
 * @memberOf module:twgl/m4
 */


function inverse(m, dst) {
  dst = dst || new MatType(16);
  var m00 = m[0 * 4 + 0];
  var m01 = m[0 * 4 + 1];
  var m02 = m[0 * 4 + 2];
  var m03 = m[0 * 4 + 3];
  var m10 = m[1 * 4 + 0];
  var m11 = m[1 * 4 + 1];
  var m12 = m[1 * 4 + 2];
  var m13 = m[1 * 4 + 3];
  var m20 = m[2 * 4 + 0];
  var m21 = m[2 * 4 + 1];
  var m22 = m[2 * 4 + 2];
  var m23 = m[2 * 4 + 3];
  var m30 = m[3 * 4 + 0];
  var m31 = m[3 * 4 + 1];
  var m32 = m[3 * 4 + 2];
  var m33 = m[3 * 4 + 3];
  var tmp_0 = m22 * m33;
  var tmp_1 = m32 * m23;
  var tmp_2 = m12 * m33;
  var tmp_3 = m32 * m13;
  var tmp_4 = m12 * m23;
  var tmp_5 = m22 * m13;
  var tmp_6 = m02 * m33;
  var tmp_7 = m32 * m03;
  var tmp_8 = m02 * m23;
  var tmp_9 = m22 * m03;
  var tmp_10 = m02 * m13;
  var tmp_11 = m12 * m03;
  var tmp_12 = m20 * m31;
  var tmp_13 = m30 * m21;
  var tmp_14 = m10 * m31;
  var tmp_15 = m30 * m11;
  var tmp_16 = m10 * m21;
  var tmp_17 = m20 * m11;
  var tmp_18 = m00 * m31;
  var tmp_19 = m30 * m01;
  var tmp_20 = m00 * m21;
  var tmp_21 = m20 * m01;
  var tmp_22 = m00 * m11;
  var tmp_23 = m10 * m01;
  var t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
  var t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
  var t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
  var t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);
  var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
  dst[0] = d * t0;
  dst[1] = d * t1;
  dst[2] = d * t2;
  dst[3] = d * t3;
  dst[4] = d * (tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30 - (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));
  dst[5] = d * (tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30 - (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));
  dst[6] = d * (tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30 - (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));
  dst[7] = d * (tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20 - (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));
  dst[8] = d * (tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33 - (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));
  dst[9] = d * (tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33 - (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));
  dst[10] = d * (tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33 - (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));
  dst[11] = d * (tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23 - (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));
  dst[12] = d * (tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12 - (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));
  dst[13] = d * (tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22 - (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));
  dst[14] = d * (tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02 - (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));
  dst[15] = d * (tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12 - (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));
  return dst;
}
/**
 * Multiplies two 4-by-4 matrices with a on the left and b on the right
 * @param {module:twgl/m4.Mat4} a The matrix on the left.
 * @param {module:twgl/m4.Mat4} b The matrix on the right.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} The matrix product of a and b.
 * @memberOf module:twgl/m4
 */


function multiply(a, b, dst) {
  dst = dst || new MatType(16);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4 + 0];
  var a11 = a[4 + 1];
  var a12 = a[4 + 2];
  var a13 = a[4 + 3];
  var a20 = a[8 + 0];
  var a21 = a[8 + 1];
  var a22 = a[8 + 2];
  var a23 = a[8 + 3];
  var a30 = a[12 + 0];
  var a31 = a[12 + 1];
  var a32 = a[12 + 2];
  var a33 = a[12 + 3];
  var b00 = b[0];
  var b01 = b[1];
  var b02 = b[2];
  var b03 = b[3];
  var b10 = b[4 + 0];
  var b11 = b[4 + 1];
  var b12 = b[4 + 2];
  var b13 = b[4 + 3];
  var b20 = b[8 + 0];
  var b21 = b[8 + 1];
  var b22 = b[8 + 2];
  var b23 = b[8 + 3];
  var b30 = b[12 + 0];
  var b31 = b[12 + 1];
  var b32 = b[12 + 2];
  var b33 = b[12 + 3];
  dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
  dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
  dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
  dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
  dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
  dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
  dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
  dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
  dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
  dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
  dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
  dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
  dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
  dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
  dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
  dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
  return dst;
}
/**
 * Sets the translation component of a 4-by-4 matrix to the given
 * vector.
 * @param {module:twgl/m4.Mat4} a The matrix.
 * @param {Vec3} v The vector.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} a once modified.
 * @memberOf module:twgl/m4
 */


function setTranslation(a, v, dst) {
  dst = dst || identity();

  if (a !== dst) {
    dst[0] = a[0];
    dst[1] = a[1];
    dst[2] = a[2];
    dst[3] = a[3];
    dst[4] = a[4];
    dst[5] = a[5];
    dst[6] = a[6];
    dst[7] = a[7];
    dst[8] = a[8];
    dst[9] = a[9];
    dst[10] = a[10];
    dst[11] = a[11];
  }

  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}
/**
 * Returns the translation component of a 4-by-4 matrix as a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {Vec3} [dst] vector..
 * @return {Vec3} The translation component of m.
 * @memberOf module:twgl/m4
 */


function getTranslation(m, dst) {
  dst = dst || v3.create();
  dst[0] = m[12];
  dst[1] = m[13];
  dst[2] = m[14];
  return dst;
}
/**
 * Returns an axis of a 4x4 matrix as a vector with 3 entries
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} axis The axis 0 = x, 1 = y, 2 = z;
 * @return {Vec3} [dst] vector.
 * @return {Vec3} The axis component of m.
 * @memberOf module:twgl/m4
 */


function getAxis(m, axis, dst) {
  dst = dst || v3.create();
  var off = axis * 4;
  dst[0] = m[off + 0];
  dst[1] = m[off + 1];
  dst[2] = m[off + 2];
  return dst;
}
/**
 * Sets an axis of a 4x4 matrix as a vector with 3 entries
 * @param {Vec3} v the axis vector
 * @param {number} axis The axis  0 = x, 1 = y, 2 = z;
 * @param {module:twgl/m4.Mat4} [dst] The matrix to set. If none a new one is created
 * @return {module:twgl/m4.Mat4} dst
 * @memberOf module:twgl/m4
 */


function setAxis(a, v, axis, dst) {
  if (dst !== a) {
    dst = copy(a, dst);
  }

  var off = axis * 4;
  dst[off + 0] = v[0];
  dst[off + 1] = v[1];
  dst[off + 2] = v[2];
  return dst;
}
/**
 * Computes a 4-by-4 perspective transformation matrix given the angular height
 * of the frustum, the aspect ratio, and the near and far clipping planes.  The
 * arguments define a frustum extending in the negative z direction.  The given
 * angle is the vertical angle of the frustum, and the horizontal angle is
 * determined to produce the given aspect ratio.  The arguments near and far are
 * the distances to the near and far clipping planes.  Note that near and far
 * are not z coordinates, but rather they are distances along the negative
 * z-axis.  The matrix generated sends the viewing frustum to the unit box.
 * We assume a unit box extending from -1 to 1 in the x and y dimensions and
 * from 0 to 1 in the z dimension.
 * @param {number} fieldOfViewYInRadians The camera angle from top to bottom (in radians).
 * @param {number} aspect The aspect ratio width / height.
 * @param {number} zNear The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param {number} zFar The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} The perspective matrix.
 * @memberOf module:twgl/m4
 */


function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {
  dst = dst || new MatType(16);
  var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);
  var rangeInv = 1.0 / (zNear - zFar);
  dst[0] = f / aspect;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = f;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = (zNear + zFar) * rangeInv;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = zNear * zFar * rangeInv * 2;
  dst[15] = 0;
  return dst;
}
/**
 * Computes a 4-by-4 othogonal transformation matrix given the left, right,
 * bottom, and top dimensions of the near clipping plane as well as the
 * near and far clipping plane distances.
 * @param {number} left Left side of the near clipping plane viewport.
 * @param {number} right Right side of the near clipping plane viewport.
 * @param {number} top Top of the near clipping plane viewport.
 * @param {number} bottom Bottom of the near clipping plane viewport.
 * @param {number} near The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param {number} far The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param {module:twgl/m4.Mat4} [dst] Output matrix.
 * @return {module:twgl/m4.Mat4} The perspective matrix.
 * @memberOf module:twgl/m4
 */


function ortho(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);
  dst[0] = 2 / (right - left);
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 2 / (top - bottom);
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 2 / (near - far);
  dst[11] = 0;
  dst[12] = (right + left) / (left - right);
  dst[13] = (top + bottom) / (bottom - top);
  dst[14] = (far + near) / (near - far);
  dst[15] = 1;
  return dst;
}
/**
 * Computes a 4-by-4 perspective transformation matrix given the left, right,
 * top, bottom, near and far clipping planes. The arguments define a frustum
 * extending in the negative z direction. The arguments near and far are the
 * distances to the near and far clipping planes. Note that near and far are not
 * z coordinates, but rather they are distances along the negative z-axis. The
 * matrix generated sends the viewing frustum to the unit box. We assume a unit
 * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z
 * dimension.
 * @param {number} left The x coordinate of the left plane of the box.
 * @param {number} right The x coordinate of the right plane of the box.
 * @param {number} bottom The y coordinate of the bottom plane of the box.
 * @param {number} top The y coordinate of the right plane of the box.
 * @param {number} near The negative z coordinate of the near plane of the box.
 * @param {number} far The negative z coordinate of the far plane of the box.
 * @param {module:twgl/m4.Mat4} [dst] Output matrix.
 * @return {module:twgl/m4.Mat4} The perspective projection matrix.
 * @memberOf module:twgl/m4
 */


function frustum(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);
  var dx = right - left;
  var dy = top - bottom;
  var dz = near - far;
  dst[0] = 2 * near / dx;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 2 * near / dy;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = (left + right) / dx;
  dst[9] = (top + bottom) / dy;
  dst[10] = far / dz;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = near * far / dz;
  dst[15] = 0;
  return dst;
}
/**
 * Computes a 4-by-4 look-at transformation.
 *
 * This is a matrix which positions the camera itself. If you want
 * a view matrix (a matrix which moves things in front of the camera)
 * take the inverse of this.
 *
 * @param {Vec3} eye The position of the eye.
 * @param {Vec3} target The position meant to be viewed.
 * @param {Vec3} up A vector pointing up.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} The look-at matrix.
 * @memberOf module:twgl/m4
 */


function lookAt(eye, target, up, dst) {
  dst = dst || new MatType(16);
  var xAxis = tempV3a;
  var yAxis = tempV3b;
  var zAxis = tempV3c;
  v3.normalize(v3.subtract(eye, target, zAxis), zAxis);
  v3.normalize(v3.cross(up, zAxis, xAxis), xAxis);
  v3.normalize(v3.cross(zAxis, xAxis, yAxis), yAxis);
  dst[0] = xAxis[0];
  dst[1] = xAxis[1];
  dst[2] = xAxis[2];
  dst[3] = 0;
  dst[4] = yAxis[0];
  dst[5] = yAxis[1];
  dst[6] = yAxis[2];
  dst[7] = 0;
  dst[8] = zAxis[0];
  dst[9] = zAxis[1];
  dst[10] = zAxis[2];
  dst[11] = 0;
  dst[12] = eye[0];
  dst[13] = eye[1];
  dst[14] = eye[2];
  dst[15] = 1;
  return dst;
}
/**
 * Creates a 4-by-4 matrix which translates by the given vector v.
 * @param {Vec3} v The vector by
 *     which to translate.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} The translation matrix.
 * @memberOf module:twgl/m4
 */


function translation(v, dst) {
  dst = dst || new MatType(16);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}
/**
 * Modifies the given 4-by-4 matrix by translation by the given vector v.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {Vec3} v The vector by
 *     which to translate.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} m once modified.
 * @memberOf module:twgl/m4
 */


function translate(m, v, dst) {
  dst = dst || new MatType(16);
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  var m00 = m[0];
  var m01 = m[1];
  var m02 = m[2];
  var m03 = m[3];
  var m10 = m[1 * 4 + 0];
  var m11 = m[1 * 4 + 1];
  var m12 = m[1 * 4 + 2];
  var m13 = m[1 * 4 + 3];
  var m20 = m[2 * 4 + 0];
  var m21 = m[2 * 4 + 1];
  var m22 = m[2 * 4 + 2];
  var m23 = m[2 * 4 + 3];
  var m30 = m[3 * 4 + 0];
  var m31 = m[3 * 4 + 1];
  var m32 = m[3 * 4 + 2];
  var m33 = m[3 * 4 + 3];

  if (m !== dst) {
    dst[0] = m00;
    dst[1] = m01;
    dst[2] = m02;
    dst[3] = m03;
    dst[4] = m10;
    dst[5] = m11;
    dst[6] = m12;
    dst[7] = m13;
    dst[8] = m20;
    dst[9] = m21;
    dst[10] = m22;
    dst[11] = m23;
  }

  dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;
  dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;
  dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;
  dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;
  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */


function rotationX(angleInRadians, dst) {
  dst = dst || new MatType(16);
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = c;
  dst[6] = s;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = -s;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Modifies the given 4-by-4 matrix by a rotation around the x-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} m once modified.
 * @memberOf module:twgl/m4
 */


function rotateX(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var m10 = m[4];
  var m11 = m[5];
  var m12 = m[6];
  var m13 = m[7];
  var m20 = m[8];
  var m21 = m[9];
  var m22 = m[10];
  var m23 = m[11];
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[4] = c * m10 + s * m20;
  dst[5] = c * m11 + s * m21;
  dst[6] = c * m12 + s * m22;
  dst[7] = c * m13 + s * m23;
  dst[8] = c * m20 - s * m10;
  dst[9] = c * m21 - s * m11;
  dst[10] = c * m22 - s * m12;
  dst[11] = c * m23 - s * m13;

  if (m !== dst) {
    dst[0] = m[0];
    dst[1] = m[1];
    dst[2] = m[2];
    dst[3] = m[3];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */


function rotationY(angleInRadians, dst) {
  dst = dst || new MatType(16);
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = 0;
  dst[2] = -s;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = s;
  dst[9] = 0;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Modifies the given 4-by-4 matrix by a rotation around the y-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} m once modified.
 * @memberOf module:twgl/m4
 */


function rotateY(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var m00 = m[0 * 4 + 0];
  var m01 = m[0 * 4 + 1];
  var m02 = m[0 * 4 + 2];
  var m03 = m[0 * 4 + 3];
  var m20 = m[2 * 4 + 0];
  var m21 = m[2 * 4 + 1];
  var m22 = m[2 * 4 + 2];
  var m23 = m[2 * 4 + 3];
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = c * m00 - s * m20;
  dst[1] = c * m01 - s * m21;
  dst[2] = c * m02 - s * m22;
  dst[3] = c * m03 - s * m23;
  dst[8] = c * m20 + s * m00;
  dst[9] = c * m21 + s * m01;
  dst[10] = c * m22 + s * m02;
  dst[11] = c * m23 + s * m03;

  if (m !== dst) {
    dst[4] = m[4];
    dst[5] = m[5];
    dst[6] = m[6];
    dst[7] = m[7];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */


function rotationZ(angleInRadians, dst) {
  dst = dst || new MatType(16);
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = s;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = -s;
  dst[5] = c;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Modifies the given 4-by-4 matrix by a rotation around the z-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} m once modified.
 * @memberOf module:twgl/m4
 */


function rotateZ(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var m00 = m[0 * 4 + 0];
  var m01 = m[0 * 4 + 1];
  var m02 = m[0 * 4 + 2];
  var m03 = m[0 * 4 + 3];
  var m10 = m[1 * 4 + 0];
  var m11 = m[1 * 4 + 1];
  var m12 = m[1 * 4 + 2];
  var m13 = m[1 * 4 + 3];
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  dst[0] = c * m00 + s * m10;
  dst[1] = c * m01 + s * m11;
  dst[2] = c * m02 + s * m12;
  dst[3] = c * m03 + s * m13;
  dst[4] = c * m10 - s * m00;
  dst[5] = c * m11 - s * m01;
  dst[6] = c * m12 - s * m02;
  dst[7] = c * m13 - s * m03;

  if (m !== dst) {
    dst[8] = m[8];
    dst[9] = m[9];
    dst[10] = m[10];
    dst[11] = m[11];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the given axis by the given
 * angle.
 * @param {Vec3} axis The axis
 *     about which to rotate.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} A matrix which rotates angle radians
 *     around the axis.
 * @memberOf module:twgl/m4
 */


function axisRotation(axis, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var x = axis[0];
  var y = axis[1];
  var z = axis[2];
  var n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  var xx = x * x;
  var yy = y * y;
  var zz = z * z;
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  var oneMinusCosine = 1 - c;
  dst[0] = xx + (1 - xx) * c;
  dst[1] = x * y * oneMinusCosine + z * s;
  dst[2] = x * z * oneMinusCosine - y * s;
  dst[3] = 0;
  dst[4] = x * y * oneMinusCosine - z * s;
  dst[5] = yy + (1 - yy) * c;
  dst[6] = y * z * oneMinusCosine + x * s;
  dst[7] = 0;
  dst[8] = x * z * oneMinusCosine + y * s;
  dst[9] = y * z * oneMinusCosine - x * s;
  dst[10] = zz + (1 - zz) * c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Modifies the given 4-by-4 matrix by rotation around the given axis by the
 * given angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {Vec3} axis The axis
 *     about which to rotate.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} m once modified.
 * @memberOf module:twgl/m4
 */


function axisRotate(m, axis, angleInRadians, dst) {
  dst = dst || new MatType(16);
  var x = axis[0];
  var y = axis[1];
  var z = axis[2];
  var n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  var xx = x * x;
  var yy = y * y;
  var zz = z * z;
  var c = Math.cos(angleInRadians);
  var s = Math.sin(angleInRadians);
  var oneMinusCosine = 1 - c;
  var r00 = xx + (1 - xx) * c;
  var r01 = x * y * oneMinusCosine + z * s;
  var r02 = x * z * oneMinusCosine - y * s;
  var r10 = x * y * oneMinusCosine - z * s;
  var r11 = yy + (1 - yy) * c;
  var r12 = y * z * oneMinusCosine + x * s;
  var r20 = x * z * oneMinusCosine + y * s;
  var r21 = y * z * oneMinusCosine - x * s;
  var r22 = zz + (1 - zz) * c;
  var m00 = m[0];
  var m01 = m[1];
  var m02 = m[2];
  var m03 = m[3];
  var m10 = m[4];
  var m11 = m[5];
  var m12 = m[6];
  var m13 = m[7];
  var m20 = m[8];
  var m21 = m[9];
  var m22 = m[10];
  var m23 = m[11];
  dst[0] = r00 * m00 + r01 * m10 + r02 * m20;
  dst[1] = r00 * m01 + r01 * m11 + r02 * m21;
  dst[2] = r00 * m02 + r01 * m12 + r02 * m22;
  dst[3] = r00 * m03 + r01 * m13 + r02 * m23;
  dst[4] = r10 * m00 + r11 * m10 + r12 * m20;
  dst[5] = r10 * m01 + r11 * m11 + r12 * m21;
  dst[6] = r10 * m02 + r11 * m12 + r12 * m22;
  dst[7] = r10 * m03 + r11 * m13 + r12 * m23;
  dst[8] = r20 * m00 + r21 * m10 + r22 * m20;
  dst[9] = r20 * m01 + r21 * m11 + r22 * m21;
  dst[10] = r20 * m02 + r21 * m12 + r22 * m22;
  dst[11] = r20 * m03 + r21 * m13 + r22 * m23;

  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Creates a 4-by-4 matrix which scales in each dimension by an amount given by
 * the corresponding entry in the given vector; assumes the vector has three
 * entries.
 * @param {Vec3} v A vector of
 *     three entries specifying the factor by which to scale in each dimension.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} The scaling matrix.
 * @memberOf module:twgl/m4
 */


function scaling(v, dst) {
  dst = dst || new MatType(16);
  dst[0] = v[0];
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = v[1];
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = v[2];
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Modifies the given 4-by-4 matrix, scaling in each dimension by an amount
 * given by the corresponding entry in the given vector; assumes the vector has
 * three entries.
 * @param {module:twgl/m4.Mat4} m The matrix to be modified.
 * @param {Vec3} v A vector of three entries specifying the
 *     factor by which to scale in each dimension.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If none new one is created..
 * @return {module:twgl/m4.Mat4} m once modified.
 * @memberOf module:twgl/m4
 */


function scale(m, v, dst) {
  dst = dst || new MatType(16);
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  dst[0] = v0 * m[0 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2];
  dst[3] = v0 * m[0 * 4 + 3];
  dst[4] = v1 * m[1 * 4 + 0];
  dst[5] = v1 * m[1 * 4 + 1];
  dst[6] = v1 * m[1 * 4 + 2];
  dst[7] = v1 * m[1 * 4 + 3];
  dst[8] = v2 * m[2 * 4 + 0];
  dst[9] = v2 * m[2 * 4 + 1];
  dst[10] = v2 * m[2 * 4 + 2];
  dst[11] = v2 * m[2 * 4 + 3];

  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}
/**
 * Takes a 4-by-4 matrix and a vector with 3 entries,
 * interprets the vector as a point, transforms that point by the matrix, and
 * returns the result as a vector with 3 entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {Vec3} v The point.
 * @param {Vec3} dst optional vec3 to store result
 * @return {Vec3} dst or new vec3 if not provided
 * @memberOf module:twgl/m4
 */


function transformPoint(m, v, dst) {
  dst = dst || v3.create();
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  var d = v0 * m[0 * 4 + 3] + v1 * m[1 * 4 + 3] + v2 * m[2 * 4 + 3] + m[3 * 4 + 3];
  dst[0] = (v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0] + m[3 * 4 + 0]) / d;
  dst[1] = (v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1] + m[3 * 4 + 1]) / d;
  dst[2] = (v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2] + m[3 * 4 + 2]) / d;
  return dst;
}
/**
 * Takes a 4-by-4 matrix and a vector with 3 entries, interprets the vector as a
 * direction, transforms that direction by the matrix, and returns the result;
 * assumes the transformation of 3-dimensional space represented by the matrix
 * is parallel-preserving, i.e. any combination of rotation, scaling and
 * translation, but not a perspective distortion. Returns a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {Vec3} v The direction.
 * @param {Vec3} dst optional Vec3 to store result
 * @return {Vec3} dst or new Vec3 if not provided
 * @memberOf module:twgl/m4
 */


function transformDirection(m, v, dst) {
  dst = dst || v3.create();
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];
  return dst;
}
/**
 * Takes a 4-by-4 matrix m and a vector v with 3 entries, interprets the vector
 * as a normal to a surface, and computes a vector which is normal upon
 * transforming that surface by the matrix. The effect of this function is the
 * same as transforming v (as a direction) by the inverse-transpose of m.  This
 * function assumes the transformation of 3-dimensional space represented by the
 * matrix is parallel-preserving, i.e. any combination of rotation, scaling and
 * translation, but not a perspective distortion.  Returns a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {Vec3} v The normal.
 * @param {Vec3} [dst] The direction.
 * @return {Vec3} The transformed direction.
 * @memberOf module:twgl/m4
 */


function transformNormal(m, v, dst) {
  dst = dst || v3.create();
  var mi = inverse(m);
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];
  dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];
  dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];
  return dst;
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.createAttribsFromArrays = createAttribsFromArrays;
exports.createBuffersFromArrays = createBuffersFromArrays;
exports.createBufferFromArray = createBufferFromArray;
exports.createBufferFromTypedArray = createBufferFromTypedArray;
exports.createBufferInfoFromArrays = createBufferInfoFromArrays;
exports.setAttribInfoBufferFromArray = setAttribInfoBufferFromArray;
exports.setAttributePrefix = setAttributePrefix;
exports.setAttributeDefaults_ = setDefaults;
exports.getNumComponents_ = getNumComponents;
exports.getArray_ = getArray;

var typedArrays = _interopRequireWildcard(__webpack_require__(1));

var helper = _interopRequireWildcard(__webpack_require__(0));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/*
 * Copyright 2015, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Low level attribute and buffer related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibily they are available at both `twgl.attributes` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/attributes
 */
// make sure we don't see a global gl
var gl = undefined; // eslint-disable-line

var defaults = {
  attribPrefix: ""
};
/**
 * Sets the default attrib prefix
 *
 * When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`
 * as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.
 *
 * In otherwords I'll create arrays of geometry like this
 *
 *     var arrays = {
 *       position: ...
 *       normal: ...
 *       texcoord: ...
 *     };
 *
 * But need those mapped to attributes and my attributes start with `a_`.
 *
 * @deprecated see {@link module:twgl.setDefaults}
 * @param {string} prefix prefix for attribs
 * @memberOf module:twgl/attributes
 */

function setAttributePrefix(prefix) {
  defaults.attribPrefix = prefix;
}

function setDefaults(newDefaults) {
  helper.copyExistingProperties(newDefaults, defaults);
}

function setBufferFromTypedArray(gl, type, buffer, array, drawType) {
  gl.bindBuffer(type, buffer);
  gl.bufferData(type, array, drawType || gl.STATIC_DRAW);
}
/**
 * Given typed array creates a WebGLBuffer and copies the typed array
 * into it.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {ArrayBuffer|SharedArrayBuffer|ArrayBufferView|WebGLBuffer} typedArray the typed array. Note: If a WebGLBuffer is passed in it will just be returned. No action will be taken
 * @param {number} [type] the GL bind type for the buffer. Default = `gl.ARRAY_BUFFER`.
 * @param {number} [drawType] the GL draw type for the buffer. Default = 'gl.STATIC_DRAW`.
 * @return {WebGLBuffer} the created WebGLBuffer
 * @memberOf module:twgl/attributes
 */


function createBufferFromTypedArray(gl, typedArray, type, drawType) {
  if (helper.isBuffer(gl, typedArray)) {
    return typedArray;
  }

  type = type || gl.ARRAY_BUFFER;
  var buffer = gl.createBuffer();
  setBufferFromTypedArray(gl, type, buffer, typedArray, drawType);
  return buffer;
}

function isIndices(name) {
  return name === "indices";
} // This is really just a guess. Though I can't really imagine using
// anything else? Maybe for some compression?


function getNormalizationForTypedArray(typedArray) {
  if (typedArray instanceof Int8Array) {
    return true;
  } // eslint-disable-line


  if (typedArray instanceof Uint8Array) {
    return true;
  } // eslint-disable-line


  return false;
} // This is really just a guess. Though I can't really imagine using
// anything else? Maybe for some compression?


function getNormalizationForTypedArrayType(typedArrayType) {
  if (typedArrayType === Int8Array) {
    return true;
  } // eslint-disable-line


  if (typedArrayType === Uint8Array) {
    return true;
  } // eslint-disable-line


  return false;
}

function getArray(array) {
  return array.length ? array : array.data;
}

var texcoordRE = /coord|texture/i;
var colorRE = /color|colour/i;

function guessNumComponentsFromName(name, length) {
  var numComponents;

  if (texcoordRE.test(name)) {
    numComponents = 2;
  } else if (colorRE.test(name)) {
    numComponents = 4;
  } else {
    numComponents = 3; // position, normals, indices ...
  }

  if (length % numComponents > 0) {
    throw "Can not guess numComponents for attribute '" + name + "'. Tried " + numComponents + " but " + length + " values is not evenly divisible by " + numComponents + ". You should specify it.";
  }

  return numComponents;
}

function getNumComponents(array, arrayName) {
  return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);
}

function makeTypedArray(array, name) {
  if (typedArrays.isArrayBuffer(array)) {
    return array;
  }

  if (typedArrays.isArrayBuffer(array.data)) {
    return array.data;
  }

  if (Array.isArray(array)) {
    array = {
      data: array
    };
  }

  var Type = array.type;

  if (!Type) {
    if (isIndices(name)) {
      Type = Uint16Array;
    } else {
      Type = Float32Array;
    }
  }

  return new Type(array.data);
}
/**
 * The info for an attribute. This is effectively just the arguments to `gl.vertexAttribPointer` plus the WebGLBuffer
 * for the attribute.
 *
 * @typedef {Object} AttribInfo
 * @property {number} [numComponents] the number of components for this attribute.
 * @property {number} [size] synonym for `numComponents`.
 * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`
 * @property {boolean} [normalize] whether or not to normalize the data. Default = false
 * @property {number} [offset] offset into buffer in bytes. Default = 0
 * @property {number} [stride] the stride in bytes per element. Default = 0
 * @property {number} [divisor] the divisor in instances. Default = undefined. Note: undefined = don't call gl.vertexAttribDivisor
 *    where as anything else = do call it with this value
 * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute
 * @property {number} [drawType] the draw type passed to gl.bufferData. Default = gl.STATIC_DRAW
 * @memberOf module:twgl
 */

/**
 * Use this type of array spec when TWGL can't guess the type or number of compoments of an array
 * @typedef {Object} FullArraySpec
 * @property {(number|number[]|ArrayBufferView)} data The data of the array. A number alone becomes the number of elements of type.
 * @property {number} [numComponents] number of components for `vertexAttribPointer`. Default is based on the name of the array.
 *    If `coord` is in the name assumes `numComponents = 2`.
 *    If `color` is in the name assumes `numComponents = 4`.
 *    otherwise assumes `numComponents = 3`
 * @property {constructor} type The type. This is only used if `data` is a JavaScript array. It is the constructor for the typedarray. (eg. `Uint8Array`).
 * For example if you want colors in a `Uint8Array` you might have a `FullArraySpec` like `{ type: Uint8Array, data: [255,0,255,255, ...], }`.
 * @property {number} [size] synonym for `numComponents`.
 * @property {boolean} [normalize] normalize for `vertexAttribPointer`. Default is true if type is `Int8Array` or `Uint8Array` otherwise false.
 * @property {number} [stride] stride for `vertexAttribPointer`. Default = 0
 * @property {number} [offset] offset for `vertexAttribPointer`. Default = 0
 * @property {number} [divisor] divisor for `vertexAttribDivisor`. Default = undefined. Note: undefined = don't call gl.vertexAttribDivisor
 *    where as anything else = do call it with this value
 * @property {string} [attrib] name of attribute this array maps to. Defaults to same name as array prefixed by the default attribPrefix.
 * @property {string} [name] synonym for `attrib`.
 * @property {string} [attribName] synonym for `attrib`.
 * @memberOf module:twgl
 */

/**
 * An individual array in {@link module:twgl.Arrays}
 *
 * When passed to {@link module:twgl.createBufferInfoFromArrays} if an ArraySpec is `number[]` or `ArrayBufferView`
 * the types will be guessed based on the name. `indices` will be `Uint16Array`, everything else will
 * be `Float32Array`. If an ArraySpec is a number it's the number of floats for an empty (zeroed) buffer.
 *
 * @typedef {(number|number[]|ArrayBufferView|module:twgl.FullArraySpec)} ArraySpec
 * @memberOf module:twgl
 */

/**
 * This is a JavaScript object of arrays by name. The names should match your shader's attributes. If your
 * attributes have a common prefix you can specify it by calling {@link module:twgl.setAttributePrefix}.
 *
 *     Bare JavaScript Arrays
 *
 *         var arrays = {
 *            position: [-1, 1, 0],
 *            normal: [0, 1, 0],
 *            ...
 *         }
 *
 *     Bare TypedArrays
 *
 *         var arrays = {
 *            position: new Float32Array([-1, 1, 0]),
 *            color: new Uint8Array([255, 128, 64, 255]),
 *            ...
 *         }
 *
 * *   Will guess at `numComponents` if not specified based on name.
 *
 *     If `coord` is in the name assumes `numComponents = 2`
 *
 *     If `color` is in the name assumes `numComponents = 4`
 *
 *     otherwise assumes `numComponents = 3`
 *
 * Objects with various fields. See {@link module:twgl.FullArraySpec}.
 *
 *     var arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *     };
 *
 * @typedef {Object.<string, module:twgl.ArraySpec>} Arrays
 * @memberOf module:twgl
 */

/**
 * Creates a set of attribute data and WebGLBuffers from set of arrays
 *
 * Given
 *
 *      var arrays = {
 *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },
 *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *      };
 *
 * returns something like
 *
 *      var attribs = {
 *        position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },
 *      };
 *
 * notes:
 *
 * *   Arrays can take various forms
 *
 *     Bare JavaScript Arrays
 *
 *         var arrays = {
 *            position: [-1, 1, 0],
 *            normal: [0, 1, 0],
 *            ...
 *         }
 *
 *     Bare TypedArrays
 *
 *         var arrays = {
 *            position: new Float32Array([-1, 1, 0]),
 *            color: new Uint8Array([255, 128, 64, 255]),
 *            ...
 *         }
 *
 * *   Will guess at `numComponents` if not specified based on name.
 *
 *     If `coord` is in the name assumes `numComponents = 2`
 *
 *     If `color` is in the name assumes `numComponents = 4`
 *
 *     otherwise assumes `numComponents = 3`
 *
 * @param {WebGLRenderingContext} gl The webgl rendering context.
 * @param {module:twgl.Arrays} arrays The arrays
 * @return {Object.<string, module:twgl.AttribInfo>} the attribs
 * @memberOf module:twgl/attributes
 */


function createAttribsFromArrays(gl, arrays) {
  var attribs = {};
  Object.keys(arrays).forEach(function (arrayName) {
    if (!isIndices(arrayName)) {
      var array = arrays[arrayName];
      var attribName = array.attrib || array.name || array.attribName || defaults.attribPrefix + arrayName;
      var buffer;
      var type;
      var normalization;
      var numComponents;
      var numValues;

      if (typeof array === "number" || typeof array.data === "number") {
        numValues = array.data || array;
        var arrayType = array.type || Float32Array;
        var numBytes = numValues * arrayType.BYTES_PER_ELEMENT;
        type = typedArrays.getGLTypeForTypedArrayType(arrayType);
        normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArrayType(arrayType);
        numComponents = array.numComponents || array.size || guessNumComponentsFromName(arrayName, numValues);
        buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, numBytes, array.drawType || gl.STATIC_DRAW);
      } else {
        var typedArray = makeTypedArray(array, arrayName);
        buffer = createBufferFromTypedArray(gl, typedArray, undefined, array.drawType);
        type = typedArrays.getGLTypeForTypedArray(typedArray);
        normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArray(typedArray);
        numComponents = getNumComponents(array, arrayName);
        numValues = typedArray.length;
      }

      attribs[attribName] = {
        buffer: buffer,
        numComponents: numComponents,
        type: type,
        normalize: normalization,
        stride: array.stride || 0,
        offset: array.offset || 0,
        divisor: array.divisor === undefined ? undefined : array.divisor,
        drawType: array.drawType
      };
    }
  });
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  return attribs;
}
/**
 * Sets the contents of a buffer attached to an attribInfo
 *
 * This is helper function to dynamically update a buffer.
 *
 * Let's say you make a bufferInfo
 *
 *     var arrays = {
 *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
 *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
 *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
 *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
 *     };
 *     var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
 *
 *  And you want to dynamically upate the positions. You could do this
 *
 *     // assuming arrays.position has already been updated with new data.
 *     twgl.setAttribInfoBufferFromArray(gl, bufferInfo.attribs.position, arrays.position);
 *
 * @param {WebGLRenderingContext} gl
 * @param {AttribInfo} attribInfo The attribInfo who's buffer contents to set. NOTE: If you have an attribute prefix
 *   the name of the attribute will include the prefix.
 * @param {ArraySpec} array Note: it is arguably ineffient to pass in anything but a typed array because anything
 *    else will have to be converted to a typed array before it can be used by WebGL. During init time that
 *    inefficiency is usually not important but if you're updating data dynamically best to be efficient.
 * @param {number} [offset] an optional offset into the buffer. This is only an offset into the WebGL buffer
 *    not the array. To pass in an offset into the array itself use a typed array and create an `ArrayBufferView`
 *    for the portion of the array you want to use.
 *
 *        var someArray = new Float32Array(1000); // an array with 1000 floats
 *        var someSubArray = new Float32Array(someArray.buffer, offsetInBytes, sizeInUnits); // a view into someArray
 *
 *    Now you can pass `someSubArray` into setAttribInfoBufferFromArray`
 * @memberOf module:twgl/attributes
 */


function setAttribInfoBufferFromArray(gl, attribInfo, array, offset) {
  array = makeTypedArray(array);

  if (offset !== undefined) {
    gl.bindBuffer(gl.ARRAY_BUFFER, attribInfo.buffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);
  } else {
    setBufferFromTypedArray(gl, gl.ARRAY_BUFFER, attribInfo.buffer, array, attribInfo.drawType);
  }
}

function getBytesPerValueForGLType(gl, type) {
  if (type === gl.BYTE) return 1; // eslint-disable-line

  if (type === gl.UNSIGNED_BYTE) return 1; // eslint-disable-line

  if (type === gl.SHORT) return 2; // eslint-disable-line

  if (type === gl.UNSIGNED_SHORT) return 2; // eslint-disable-line

  if (type === gl.INT) return 4; // eslint-disable-line

  if (type === gl.UNSIGNED_INT) return 4; // eslint-disable-line

  if (type === gl.FLOAT) return 4; // eslint-disable-line

  return 0;
}
/**
 * tries to get the number of elements from a set of arrays.
 */


var positionKeys = ['position', 'positions', 'a_position'];

function getNumElementsFromNonIndexedArrays(arrays) {
  var key;

  for (var _ii = 0; _ii < positionKeys.length; ++_ii) {
    key = positionKeys[_ii];

    if (key in arrays) {
      break;
    }
  }

  if (ii === positionKeys.length) {
    key = Object.keys(arrays)[0];
  }

  var array = arrays[key];
  var length = getArray(array).length;
  var numComponents = getNumComponents(array, key);
  var numElements = length / numComponents;

  if (length % numComponents > 0) {
    throw "numComponents " + numComponents + " not correct for length " + length;
  }

  return numElements;
}

function getNumElementsFromAttributes(gl, attribs) {
  var key;
  var ii;

  for (ii = 0; ii < positionKeys.length; ++ii) {
    key = positionKeys[ii];

    if (key in attribs) {
      break;
    }

    key = defaults.attribPrefix + key;

    if (key in attribs) {
      break;
    }
  }

  if (ii === positionKeys.length) {
    key = Object.keys(attribs)[0];
  }

  var attrib = attribs[key];
  gl.bindBuffer(gl.ARRAY_BUFFER, attrib.buffer);
  var numBytes = gl.getBufferParameter(gl.ARRAY_BUFFER, gl.BUFFER_SIZE);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  var bytesPerValue = getBytesPerValueForGLType(gl, attrib.type);
  var totalElements = numBytes / bytesPerValue;
  var numComponents = attrib.numComponents || attrib.size; // TODO: check stride

  var numElements = totalElements / numComponents;

  if (numElements % 1 !== 0) {
    throw "numComponents " + numComponents + " not correct for length " + length;
  }

  return numElements;
}
/**
 * @typedef {Object} BufferInfo
 * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
 * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..
 * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.
 * @property {Object.<string, module:twgl.AttribInfo>} [attribs] The attribs approriate to call `setAttributes`
 * @memberOf module:twgl
 */

/**
 * Creates a BufferInfo from an object of arrays.
 *
 * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to
 * {@link module:twgl:drawBufferInfo}.
 *
 * Given an object like
 *
 *     var arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *     };
 *
 *  Creates an BufferInfo like this
 *
 *     bufferInfo = {
 *       numElements: 4,        // or whatever the number of elements is
 *       indices: WebGLBuffer,  // this property will not exist if there are no indices
 *       attribs: {
 *         a_position: { buffer: WebGLBuffer, numComponents: 3, },
 *         a_normal:   { buffer: WebGLBuffer, numComponents: 3, },
 *         a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },
 *       },
 *     };
 *
 *  The properties of arrays can be JavaScript arrays in which case the number of components
 *  will be guessed.
 *
 *     var arrays = {
 *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],
 *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],
 *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
 *        indices:  [0, 1, 2, 1, 2, 3],
 *     };
 *
 *  They can also by TypedArrays
 *
 *     var arrays = {
 *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
 *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
 *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
 *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
 *     };
 *
 *  Or augmentedTypedArrays
 *
 *     var positions = createAugmentedTypedArray(3, 4);
 *     var texcoords = createAugmentedTypedArray(2, 4);
 *     var normals   = createAugmentedTypedArray(3, 4);
 *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);
 *
 *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);
 *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);
 *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
 *     indices.push([0, 1, 2, 1, 2, 3]);
 *
 *     var arrays = {
 *        position: positions,
 *        texcoord: texcoords,
 *        normal:   normals,
 *        indices:  indices,
 *     };
 *
 * For the last example it is equivalent to
 *
 *     var bufferInfo = {
 *       attribs: {
 *         a_position: { numComponents: 3, buffer: gl.createBuffer(), },
 *         a_texcoods: { numComponents: 2, buffer: gl.createBuffer(), },
 *         a_normals: { numComponents: 3, buffer: gl.createBuffer(), },
 *       },
 *       indices: gl.createBuffer(),
 *       numElements: 6,
 *     };
 *
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_position.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_texcoord.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_normal.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);
 *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.Arrays} arrays Your data
 * @return {module:twgl.BufferInfo} A BufferInfo
 * @memberOf module:twgl/attributes
 */


function createBufferInfoFromArrays(gl, arrays) {
  var bufferInfo = {
    attribs: createAttribsFromArrays(gl, arrays)
  };
  var indices = arrays.indices;

  if (indices) {
    var newIndices = makeTypedArray(indices, "indices");
    bufferInfo.indices = createBufferFromTypedArray(gl, newIndices, gl.ELEMENT_ARRAY_BUFFER);
    bufferInfo.numElements = newIndices.length;
    bufferInfo.elementType = typedArrays.getGLTypeForTypedArray(newIndices);
  } else {
    bufferInfo.numElements = getNumElementsFromAttributes(gl, bufferInfo.attribs);
  }

  return bufferInfo;
}
/**
 * Creates a buffer from an array, typed array, or array spec
 *
 * Given something like this
 *
 *     [1, 2, 3],
 *
 * or
 *
 *     new Uint16Array([1,2,3]);
 *
 * or
 *
 *     {
 *        data: [1, 2, 3],
 *        type: Uint8Array,
 *     }
 *
 * returns a WebGLBuffer that constains the given data.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {module:twgl.ArraySpec} array an array, typed array, or array spec.
 * @param {string} arrayName name of array. Used to guess the type if type can not be dervied other wise.
 * @return {WebGLBuffer} a WebGLBuffer containing the data in array.
 * @memberOf module:twgl/attributes
 */


function createBufferFromArray(gl, array, arrayName) {
  var type = arrayName === "indices" ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
  var typedArray = makeTypedArray(array, arrayName);
  return createBufferFromTypedArray(gl, typedArray, type);
}
/**
 * Creates buffers from arrays or typed arrays
 *
 * Given something like this
 *
 *     var arrays = {
 *        positions: [1, 2, 3],
 *        normals: [0, 0, 1],
 *     }
 *
 * returns something like
 *
 *     buffers = {
 *       positions: WebGLBuffer,
 *       normals: WebGLBuffer,
 *     }
 *
 * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {module:twgl.Arrays} arrays
 * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array
 * @memberOf module:twgl/attributes
 */


function createBuffersFromArrays(gl, arrays) {
  var buffers = {};
  Object.keys(arrays).forEach(function (key) {
    buffers[key] = createBufferFromArray(gl, arrays[key], key);
  }); // Ugh!

  if (arrays.indices) {
    buffers.numElements = arrays.indices.length;
    buffers.elementType = typedArrays.getGLTypeForTypedArray(makeTypedArray(arrays.indices), 'indices');
  } else {
    buffers.numElements = getNumElementsFromNonIndexedArrays(arrays);
  }

  return buffers;
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.setTextureDefaults_ = setDefaults;
exports.createSampler = createSampler;
exports.createSamplers = createSamplers;
exports.setSamplerParameters = setSamplerParameters;
exports.createTexture = createTexture;
exports.setEmptyTexture = setEmptyTexture;
exports.setTextureFromArray = setTextureFromArray;
exports.loadTextureFromUrl = loadTextureFromUrl;
exports.setTextureFromElement = setTextureFromElement;
exports.setTextureFilteringForSize = setTextureFilteringForSize;
exports.setTextureParameters = setTextureParameters;
exports.setDefaultTextureColor = setDefaultTextureColor;
exports.createTextures = createTextures;
exports.resizeTexture = resizeTexture;
exports.getNumComponentsForFormat = getNumComponentsForFormat;
exports.getBytesPerElementForInternalFormat = getBytesPerElementForInternalFormat;

var utils = _interopRequireWildcard(__webpack_require__(4));

var typedArrays = _interopRequireWildcard(__webpack_require__(1));

var helper = _interopRequireWildcard(__webpack_require__(0));

var _globalObject = _interopRequireDefault(__webpack_require__(2));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/*
 * Copyright 2015, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Low level texture related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibily they are available at both `twgl.textures` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/textures
 */
// make sure we don't see a global gl
var gl = undefined; // eslint-disable-line

var defaults = {
  textureColor: new Uint8Array([128, 192, 255, 255]),
  textureOptions: {},
  crossOrigin: undefined
};
var isArrayBuffer = typedArrays.isArrayBuffer; // Should we make this on demand?

var ctx = _globalObject.default.document && _globalObject.default.document.createElement ? _globalObject.default.document.createElement("canvas").getContext("2d") : null; // NOTE: Chrome supports 2D canvas in a Worker (behind flag as of v64 but
//       not only does Firefox NOT support it but Firefox freezes immediately
//       if you try to create one instead of just returning null and continuing.
//  : (global.OffscreenCanvas && (new global.OffscreenCanvas(1, 1)).getContext("2d"));  // OffscreenCanvas may not support 2d
// NOTE: We can maybe remove some of the need for the 2d canvas. In WebGL2
// we can use the various unpack settings. Otherwise we could try using
// the ability of an imagebitmap to be cut. Unfortunately cutting an imagebitmap
// is async and the current TWGL code expects a non-Async result though that
// might not be a problem. ImageBitmap though is not available in Edge or Safari
// as of 2018-01-02

/* PixelFormat */

var ALPHA = 0x1906;
var RGB = 0x1907;
var RGBA = 0x1908;
var LUMINANCE = 0x1909;
var LUMINANCE_ALPHA = 0x190A;
var DEPTH_COMPONENT = 0x1902;
var DEPTH_STENCIL = 0x84F9;
/* TextureWrapMode */

var REPEAT = 0x2901; // eslint-disable-line

var MIRRORED_REPEAT = 0x8370; // eslint-disable-line

/* TextureMagFilter */

var NEAREST = 0x2600; // eslint-disable-line

/* TextureMinFilter */

var NEAREST_MIPMAP_NEAREST = 0x2700; // eslint-disable-line

var LINEAR_MIPMAP_NEAREST = 0x2701; // eslint-disable-line

var NEAREST_MIPMAP_LINEAR = 0x2702; // eslint-disable-line

var LINEAR_MIPMAP_LINEAR = 0x2703; // eslint-disable-line

var R8 = 0x8229;
var R8_SNORM = 0x8F94;
var R16F = 0x822D;
var R32F = 0x822E;
var R8UI = 0x8232;
var R8I = 0x8231;
var RG16UI = 0x823A;
var RG16I = 0x8239;
var RG32UI = 0x823C;
var RG32I = 0x823B;
var RG8 = 0x822B;
var RG8_SNORM = 0x8F95;
var RG16F = 0x822F;
var RG32F = 0x8230;
var RG8UI = 0x8238;
var RG8I = 0x8237;
var R16UI = 0x8234;
var R16I = 0x8233;
var R32UI = 0x8236;
var R32I = 0x8235;
var RGB8 = 0x8051;
var SRGB8 = 0x8C41;
var RGB565 = 0x8D62;
var RGB8_SNORM = 0x8F96;
var R11F_G11F_B10F = 0x8C3A;
var RGB9_E5 = 0x8C3D;
var RGB16F = 0x881B;
var RGB32F = 0x8815;
var RGB8UI = 0x8D7D;
var RGB8I = 0x8D8F;
var RGB16UI = 0x8D77;
var RGB16I = 0x8D89;
var RGB32UI = 0x8D71;
var RGB32I = 0x8D83;
var RGBA8 = 0x8058;
var SRGB8_ALPHA8 = 0x8C43;
var RGBA8_SNORM = 0x8F97;
var RGB5_A1 = 0x8057;
var RGBA4 = 0x8056;
var RGB10_A2 = 0x8059;
var RGBA16F = 0x881A;
var RGBA32F = 0x8814;
var RGBA8UI = 0x8D7C;
var RGBA8I = 0x8D8E;
var RGB10_A2UI = 0x906F;
var RGBA16UI = 0x8D76;
var RGBA16I = 0x8D88;
var RGBA32I = 0x8D82;
var RGBA32UI = 0x8D70;
var DEPTH_COMPONENT16 = 0x81A5;
var DEPTH_COMPONENT24 = 0x81A6;
var DEPTH_COMPONENT32F = 0x8CAC;
var DEPTH32F_STENCIL8 = 0x8CAD;
var DEPTH24_STENCIL8 = 0x88F0;
/* DataType */

var BYTE = 0x1400;
var UNSIGNED_BYTE = 0x1401;
var SHORT = 0x1402;
var UNSIGNED_SHORT = 0x1403;
var INT = 0x1404;
var UNSIGNED_INT = 0x1405;
var FLOAT = 0x1406;
var UNSIGNED_SHORT_4_4_4_4 = 0x8033;
var UNSIGNED_SHORT_5_5_5_1 = 0x8034;
var UNSIGNED_SHORT_5_6_5 = 0x8363;
var HALF_FLOAT = 0x140B;
var HALF_FLOAT_OES = 0x8D61; // Thanks Khronos for making this different >:(

var UNSIGNED_INT_2_10_10_10_REV = 0x8368;
var UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;
var UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;
var FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
var UNSIGNED_INT_24_8 = 0x84FA;
var RG = 0x8227;
var RG_INTEGER = 0x8228;
var RED = 0x1903;
var RED_INTEGER = 0x8D94;
var RGB_INTEGER = 0x8D98;
var RGBA_INTEGER = 0x8D99;
var formatInfo = {};
{
  // NOTE: this is named `numColorComponents` vs `numComponents` so we can let Uglify mangle
  // the name.
  var f = formatInfo;
  f[ALPHA] = {
    numColorComponents: 1
  };
  f[LUMINANCE] = {
    numColorComponents: 1
  };
  f[LUMINANCE_ALPHA] = {
    numColorComponents: 2
  };
  f[RGB] = {
    numColorComponents: 3
  };
  f[RGBA] = {
    numColorComponents: 4
  };
  f[RED] = {
    numColorComponents: 1
  };
  f[RED_INTEGER] = {
    numColorComponents: 1
  };
  f[RG] = {
    numColorComponents: 2
  };
  f[RG_INTEGER] = {
    numColorComponents: 2
  };
  f[RGB] = {
    numColorComponents: 3
  };
  f[RGB_INTEGER] = {
    numColorComponents: 3
  };
  f[RGBA] = {
    numColorComponents: 4
  };
  f[RGBA_INTEGER] = {
    numColorComponents: 4
  };
  f[DEPTH_COMPONENT] = {
    numColorComponents: 1
  };
  f[DEPTH_STENCIL] = {
    numColorComponents: 2
  };
}
var textureInternalFormatInfo = {};
{
  // NOTE: these properties need unique names so we can let Uglify mangle the name.
  var t = textureInternalFormatInfo; // unsized formats

  t[ALPHA] = {
    textureFormat: ALPHA,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: [1, 2, 2, 4],
    type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT]
  };
  t[LUMINANCE] = {
    textureFormat: LUMINANCE,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: [1, 2, 2, 4],
    type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT]
  };
  t[LUMINANCE_ALPHA] = {
    textureFormat: LUMINANCE_ALPHA,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: [2, 4, 4, 8],
    type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT]
  };
  t[RGB] = {
    textureFormat: RGB,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: [3, 6, 6, 12, 2],
    type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_5_6_5]
  };
  t[RGBA] = {
    textureFormat: RGBA,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: [4, 8, 8, 16, 2, 2],
    type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1]
  }; // sized formats

  t[R8] = {
    textureFormat: RED,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: 1,
    type: UNSIGNED_BYTE
  };
  t[R8_SNORM] = {
    textureFormat: RED,
    colorRenderable: false,
    textureFilterable: true,
    bytesPerElement: 1,
    type: BYTE
  };
  t[R16F] = {
    textureFormat: RED,
    colorRenderable: false,
    textureFilterable: true,
    bytesPerElement: [4, 2],
    type: [FLOAT, HALF_FLOAT]
  };
  t[R32F] = {
    textureFormat: RED,
    colorRenderable: false,
    textureFilterable: false,
    bytesPerElement: 4,
    type: FLOAT
  };
  t[R8UI] = {
    textureFormat: RED_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 1,
    type: UNSIGNED_BYTE
  };
  t[R8I] = {
    textureFormat: RED_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 1,
    type: BYTE
  };
  t[R16UI] = {
    textureFormat: RED_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 2,
    type: UNSIGNED_SHORT
  };
  t[R16I] = {
    textureFormat: RED_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 2,
    type: SHORT
  };
  t[R32UI] = {
    textureFormat: RED_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 4,
    type: UNSIGNED_INT
  };
  t[R32I] = {
    textureFormat: RED_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 4,
    type: INT
  };
  t[RG8] = {
    textureFormat: RG,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: 2,
    type: UNSIGNED_BYTE
  };
  t[RG8_SNORM] = {
    textureFormat: RG,
    colorRenderable: false,
    textureFilterable: true,
    bytesPerElement: 2,
    type: BYTE
  };
  t[RG16F] = {
    textureFormat: RG,
    colorRenderable: false,
    textureFilterable: true,
    bytesPerElement: [8, 4],
    type: [FLOAT, HALF_FLOAT]
  };
  t[RG32F] = {
    textureFormat: RG,
    colorRenderable: false,
    textureFilterable: false,
    bytesPerElement: 8,
    type: FLOAT
  };
  t[RG8UI] = {
    textureFormat: RG_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 2,
    type: UNSIGNED_BYTE
  };
  t[RG8I] = {
    textureFormat: RG_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 2,
    type: BYTE
  };
  t[RG16UI] = {
    textureFormat: RG_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 4,
    type: UNSIGNED_SHORT
  };
  t[RG16I] = {
    textureFormat: RG_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 4,
    type: SHORT
  };
  t[RG32UI] = {
    textureFormat: RG_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 8,
    type: UNSIGNED_INT
  };
  t[RG32I] = {
    textureFormat: RG_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 8,
    type: INT
  };
  t[RGB8] = {
    textureFormat: RGB,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: 3,
    type: UNSIGNED_BYTE
  };
  t[SRGB8] = {
    textureFormat: RGB,
    colorRenderable: false,
    textureFilterable: true,
    bytesPerElement: 3,
    type: UNSIGNED_BYTE
  };
  t[RGB565] = {
    textureFormat: RGB,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: [3, 2],
    type: [UNSIGNED_BYTE, UNSIGNED_SHORT_5_6_5]
  };
  t[RGB8_SNORM] = {
    textureFormat: RGB,
    colorRenderable: false,
    textureFilterable: true,
    bytesPerElement: 3,
    type: BYTE
  };
  t[R11F_G11F_B10F] = {
    textureFormat: RGB,
    colorRenderable: false,
    textureFilterable: true,
    bytesPerElement: [12, 6, 4],
    type: [FLOAT, HALF_FLOAT, UNSIGNED_INT_10F_11F_11F_REV]
  };
  t[RGB9_E5] = {
    textureFormat: RGB,
    colorRenderable: false,
    textureFilterable: true,
    bytesPerElement: [12, 6, 4],
    type: [FLOAT, HALF_FLOAT, UNSIGNED_INT_5_9_9_9_REV]
  };
  t[RGB16F] = {
    textureFormat: RGB,
    colorRenderable: false,
    textureFilterable: true,
    bytesPerElement: [12, 6],
    type: [FLOAT, HALF_FLOAT]
  };
  t[RGB32F] = {
    textureFormat: RGB,
    colorRenderable: false,
    textureFilterable: false,
    bytesPerElement: 12,
    type: FLOAT
  };
  t[RGB8UI] = {
    textureFormat: RGB_INTEGER,
    colorRenderable: false,
    textureFilterable: false,
    bytesPerElement: 3,
    type: UNSIGNED_BYTE
  };
  t[RGB8I] = {
    textureFormat: RGB_INTEGER,
    colorRenderable: false,
    textureFilterable: false,
    bytesPerElement: 3,
    type: BYTE
  };
  t[RGB16UI] = {
    textureFormat: RGB_INTEGER,
    colorRenderable: false,
    textureFilterable: false,
    bytesPerElement: 6,
    type: UNSIGNED_SHORT
  };
  t[RGB16I] = {
    textureFormat: RGB_INTEGER,
    colorRenderable: false,
    textureFilterable: false,
    bytesPerElement: 6,
    type: SHORT
  };
  t[RGB32UI] = {
    textureFormat: RGB_INTEGER,
    colorRenderable: false,
    textureFilterable: false,
    bytesPerElement: 12,
    type: UNSIGNED_INT
  };
  t[RGB32I] = {
    textureFormat: RGB_INTEGER,
    colorRenderable: false,
    textureFilterable: false,
    bytesPerElement: 12,
    type: INT
  };
  t[RGBA8] = {
    textureFormat: RGBA,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: 4,
    type: UNSIGNED_BYTE
  };
  t[SRGB8_ALPHA8] = {
    textureFormat: RGBA,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: 4,
    type: UNSIGNED_BYTE
  };
  t[RGBA8_SNORM] = {
    textureFormat: RGBA,
    colorRenderable: false,
    textureFilterable: true,
    bytesPerElement: 4,
    type: BYTE
  };
  t[RGB5_A1] = {
    textureFormat: RGBA,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: [4, 2, 4],
    type: [UNSIGNED_BYTE, UNSIGNED_SHORT_5_5_5_1, UNSIGNED_INT_2_10_10_10_REV]
  };
  t[RGBA4] = {
    textureFormat: RGBA,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: [4, 2],
    type: [UNSIGNED_BYTE, UNSIGNED_SHORT_4_4_4_4]
  };
  t[RGB10_A2] = {
    textureFormat: RGBA,
    colorRenderable: true,
    textureFilterable: true,
    bytesPerElement: 4,
    type: UNSIGNED_INT_2_10_10_10_REV
  };
  t[RGBA16F] = {
    textureFormat: RGBA,
    colorRenderable: false,
    textureFilterable: true,
    bytesPerElement: [16, 8],
    type: [FLOAT, HALF_FLOAT]
  };
  t[RGBA32F] = {
    textureFormat: RGBA,
    colorRenderable: false,
    textureFilterable: false,
    bytesPerElement: 16,
    type: FLOAT
  };
  t[RGBA8UI] = {
    textureFormat: RGBA_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 4,
    type: UNSIGNED_BYTE
  };
  t[RGBA8I] = {
    textureFormat: RGBA_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 4,
    type: BYTE
  };
  t[RGB10_A2UI] = {
    textureFormat: RGBA_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 4,
    type: UNSIGNED_INT_2_10_10_10_REV
  };
  t[RGBA16UI] = {
    textureFormat: RGBA_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 8,
    type: UNSIGNED_SHORT
  };
  t[RGBA16I] = {
    textureFormat: RGBA_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 8,
    type: SHORT
  };
  t[RGBA32I] = {
    textureFormat: RGBA_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 16,
    type: INT
  };
  t[RGBA32UI] = {
    textureFormat: RGBA_INTEGER,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 16,
    type: UNSIGNED_INT
  }; // Sized Internal

  t[DEPTH_COMPONENT16] = {
    textureFormat: DEPTH_COMPONENT,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: [2, 4],
    type: [UNSIGNED_SHORT, UNSIGNED_INT]
  };
  t[DEPTH_COMPONENT24] = {
    textureFormat: DEPTH_COMPONENT,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 4,
    type: UNSIGNED_INT
  };
  t[DEPTH_COMPONENT32F] = {
    textureFormat: DEPTH_COMPONENT,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 4,
    type: FLOAT
  };
  t[DEPTH24_STENCIL8] = {
    textureFormat: DEPTH_STENCIL,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 4,
    type: UNSIGNED_INT_24_8
  };
  t[DEPTH32F_STENCIL8] = {
    textureFormat: DEPTH_STENCIL,
    colorRenderable: true,
    textureFilterable: false,
    bytesPerElement: 4,
    type: FLOAT_32_UNSIGNED_INT_24_8_REV
  };
  Object.keys(t).forEach(function (internalFormat) {
    var info = t[internalFormat];
    info.bytesPerElementMap = {};

    if (Array.isArray(info.bytesPerElement)) {
      info.bytesPerElement.forEach(function (bytesPerElement, ndx) {
        var type = info.type[ndx];
        info.bytesPerElementMap[type] = bytesPerElement;
      });
    } else {
      var type = info.type;
      info.bytesPerElementMap[type] = info.bytesPerElement;
    }
  });
}
/**
 * Gets the number of bytes per element for a given internalFormat / type
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @param {number} type The type parameter for texImage2D etc..
 * @return {number} the number of bytes per element for the given internalFormat, type combo
 * @memberOf module:twgl/textures
 */

function getBytesPerElementForInternalFormat(internalFormat, type) {
  var info = textureInternalFormatInfo[internalFormat];

  if (!info) {
    throw "unknown internal format";
  }

  var bytesPerElement = info.bytesPerElementMap[type];

  if (bytesPerElement === undefined) {
    throw "unknown internal format";
  }

  return bytesPerElement;
}
/**
 * Gets the format for a given internalFormat
 *
 * @param {number} internalFormat The internal format
 * @return {{format:number, type:number}} the corresponding format and type
 */


function getFormatAndTypeForInternalFormat(internalFormat) {
  var info = textureInternalFormatInfo[internalFormat];

  if (!info) {
    throw "unknown internal format";
  }

  return {
    format: info.textureFormat,
    type: Array.isArray(info.type) ? info.type[0] : info.type
  };
}
/**
 * Returns true if value is power of 2
 * @param {number} value number to check.
 * @return true if value is power of 2
 */


function isPowerOf2(value) {
  return (value & value - 1) === 0;
}
/**
 * Gets whether or not we can generate mips for the given format
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @param {number} type The type parameter for texImage2D etc..
 * @return {boolean} true if we can generate mips
 */


function canGenerateMipmap(gl, width, height, internalFormat
/*, type */
) {
  if (!utils.isWebGL2(gl)) {
    return isPowerOf2(width) && isPowerOf2(height);
  }

  var info = textureInternalFormatInfo[internalFormat];

  if (!info) {
    throw "unknown internal format";
  }

  return info.colorRenderable && info.textureFilterable;
}
/**
 * Gets whether or not we can generate mips for the given format
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @param {number} type The type parameter for texImage2D etc..
 * @return {boolean} true if we can generate mips
 */


function canFilter(internalFormat
/*, type */
) {
  var info = textureInternalFormatInfo[internalFormat];

  if (!info) {
    throw "unknown internal format";
  }

  return info.textureFilterable;
}
/**
 * Gets the number of compontents for a given image format.
 * @param {number} format the format.
 * @return {number} the number of components for the format.
 * @memberOf module:twgl/textures
 */


function getNumComponentsForFormat(format) {
  var info = formatInfo[format];

  if (!info) {
    throw "unknown format: " + format;
  }

  return info.numColorComponents;
}
/**
 * Gets the texture type for a given array type.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @return {number} the gl texture type
 */


function getTextureTypeForArrayType(gl, src, defaultType) {
  if (isArrayBuffer(src)) {
    return typedArrays.getGLTypeForTypedArray(src);
  }

  return defaultType || gl.UNSIGNED_BYTE;
}

function guessDimensions(gl, target, width, height, numElements) {
  if (numElements % 1 !== 0) {
    throw "can't guess dimensions";
  }

  if (!width && !height) {
    var size = Math.sqrt(numElements / (target === gl.TEXTURE_CUBE_MAP ? 6 : 1));

    if (size % 1 === 0) {
      width = size;
      height = size;
    } else {
      width = numElements;
      height = 1;
    }
  } else if (!height) {
    height = numElements / width;

    if (height % 1) {
      throw "can't guess dimensions";
    }
  } else if (!width) {
    width = numElements / height;

    if (width % 1) {
      throw "can't guess dimensions";
    }
  }

  return {
    width: width,
    height: height
  };
}
/**
 * Sets the default texture color.
 *
 * The default texture color is used when loading textures from
 * urls. Because the URL will be loaded async we'd like to be
 * able to use the texture immediately. By putting a 1x1 pixel
 * color in the texture we can start using the texture before
 * the URL has loaded.
 *
 * @param {number[]} color Array of 4 values in the range 0 to 1
 * @deprecated see {@link module:twgl.setDefaults}
 * @memberOf module:twgl/textures
 */


function setDefaultTextureColor(color) {
  defaults.textureColor = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);
}

function setDefaults(newDefaults) {
  helper.copyExistingProperties(newDefaults, defaults);

  if (newDefaults.textureColor) {
    setDefaultTextureColor(newDefaults.textureColor);
  }
}
/**
 * A function to generate the source for a texture.
 * @callback TextureFunc
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options the texture options
 * @return {*} Returns any of the things documentented for `src` for {@link module:twgl.TextureOptions}.
 * @memberOf module:twgl
 */

/**
 * Texture options passed to most texture functions. Each function will use whatever options
 * are appropriate for its needs. This lets you pass the same options to all functions.
 *
 * Note: A `TexImageSource` is defined in the WebGL spec as a `HTMLImageElement`, `HTMLVideoElement`,
 * `HTMLCanvasElement`, `ImageBitmap`, or `ImageData`.
 *
 * @typedef {Object} TextureOptions
 * @property {number} [target] the type of texture `gl.TEXTURE_2D` or `gl.TEXTURE_CUBE_MAP`. Defaults to `gl.TEXTURE_2D`.
 * @property {number} [level] the mip level to affect. Defaults to 0. Note, if set auto will be considered false unless explicitly set to true.
 * @property {number} [width] the width of the texture. Only used if src is an array or typed array or null.
 * @property {number} [height] the height of a texture. Only used if src is an array or typed array or null.
 * @property {number} [depth] the depth of a texture. Only used if src is an array or type array or null and target is `TEXTURE_3D` .
 * @property {number} [min] the min filter setting (eg. `gl.LINEAR`). Defaults to `gl.NEAREST_MIPMAP_LINEAR`
 *     or if texture is not a power of 2 on both dimensions then defaults to `gl.LINEAR`.
 * @property {number} [mag] the mag filter setting (eg. `gl.LINEAR`). Defaults to `gl.LINEAR`
 * @property {number} [minMag] both the min and mag filter settings.
 * @property {number} [internalFormat] internal format for texture. Defaults to `gl.RGBA`
 * @property {number} [format] format for texture. Defaults to `gl.RGBA`.
 * @property {number} [type] type for texture. Defaults to `gl.UNSIGNED_BYTE` unless `src` is ArrayBufferView. If `src`
 *     is ArrayBufferView defaults to type that matches ArrayBufferView type.
 * @property {number} [wrap] Texture wrapping for both S and T (and R if TEXTURE_3D or WebGLSampler). Defaults to `gl.REPEAT` for 2D unless src is WebGL1 and src not npot and `gl.CLAMP_TO_EDGE` for cube
 * @property {number} [wrapS] Texture wrapping for S. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [wrapT] Texture wrapping for T. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [wrapR] Texture wrapping for R. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [minLod] TEXTURE_MIN_LOD setting
 * @property {number} [maxLod] TEXTURE_MAX_LOD setting
 * @property {number} [baseLevel] TEXTURE_BASE_LEVEL setting
 * @property {number} [maxLevel] TEXTURE_MAX_LEVEL setting
 * @property {number} [unpackAlignment] The `gl.UNPACK_ALIGNMENT` used when uploading an array. Defaults to 1.
 * @property {number} [premultiplyAlpha] Whether or not to premultiply alpha. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {number} [flipY] Whether or not to flip the texture vertically on upload. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {number} [colorspaceConversion] Whether or not to let the browser do colorspace conversion of the texture on upload. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {(number[]|ArrayBufferView)} color color used as temporary 1x1 pixel color for textures loaded async when src is a string.
 *    If it's a JavaScript array assumes color is 0 to 1 like most GL colors as in `[1, 0, 0, 1] = red=1, green=0, blue=0, alpha=0`.
 *    Defaults to `[0.5, 0.75, 1, 1]`. See {@link module:twgl.setDefaultTextureColor}. If `false` texture is set. Can be used to re-load a texture
 * @property {boolean} [auto] If `undefined` or `true`, in WebGL1, texture filtering is set automatically for non-power of 2 images and
 *    mips are generated for power of 2 images. In WebGL2 mips are generated if they can be. Note: if `level` is set above
 *    then then `auto` is assumed to be `false` unless explicity set to `true`.
 * @property {number[]} [cubeFaceOrder] The order that cube faces are pulled out of an img or set of images. The default is
 *
 *     [gl.TEXTURE_CUBE_MAP_POSITIVE_X,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
 *      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
 *      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]
 *
 * @property {(number[]|ArrayBufferView|TexImageSource|TexImageSource[]|string|string[]|module:twgl.TextureFunc)} [src] source for texture
 *
 *    If `string` then it's assumed to be a URL to an image. The image will be downloaded async. A usable
 *    1x1 pixel texture will be returned immediatley. The texture will be updated once the image has downloaded.
 *    If `target` is `gl.TEXTURE_CUBE_MAP` will attempt to divide image into 6 square pieces. 1x6, 6x1, 3x2, 2x3.
 *    The pieces will be uploaded in `cubeFaceOrder`
 *
 *    If `string[]` or `TexImageSource[]` and target is `gl.TEXTURE_CUBE_MAP` then it must have 6 entries, one for each face of a cube map.
 *
 *    If `string[]` or `TexImageSource[]` and target is `gl.TEXTURE_2D_ARRAY` then eact entry is a slice of the a 2d array texture
 *    and will be scaled to the specified width and height OR to the size of the first image that loads.
 *
 *    If `TexImageSource` then it wil be used immediately to create the contents of the texture. Examples `HTMLImageElement`,
 *    `HTMLCanvasElement`, `HTMLVideoElement`.
 *
 *    If `number[]` or `ArrayBufferView` it's assumed to be data for a texture. If `width` or `height` is
 *    not specified it is guessed as follows. First the number of elements is computed by `src.length / numComponents`
 *    where `numComponents` is derived from `format`. If `target` is `gl.TEXTURE_CUBE_MAP` then `numElements` is divided
 *    by 6. Then
 *
 *    *   If neither `width` nor `height` are specified and `sqrt(numElements)` is an integer then width and height
 *        are set to `sqrt(numElements)`. Otherwise `width = numElements` and `height = 1`.
 *
 *    *   If only one of `width` or `height` is specified then the other equals `numElements / specifiedDimension`.
 *
 * If `number[]` will be converted to `type`.
 *
 * If `src` is a function it will be called with a `WebGLRenderingContext` and these options.
 * Whatever it returns is subject to these rules. So it can return a string url, an `HTMLElement`
 * an array etc...
 *
 * If `src` is undefined then an empty texture will be created of size `width` by `height`.
 *
 * @property {string} [crossOrigin] What to set the crossOrigin property of images when they are downloaded.
 *    default: undefined. Also see {@link module:twgl.setDefaults}.
 *
 * @memberOf module:twgl
 */
// NOTE: While querying GL is considered slow it's not remotely as slow
// as uploading a texture. On top of that you're unlikely to call this in
// a perf critical loop. Even if upload a texture every frame that's unlikely
// to be more than 1 or 2 textures a frame. In other words, the benefits of
// making the API easy to use outweigh any supposed perf benefits
//
// Also note I get that having one global of these is bad practice.
// As long as it's used correctly it means no garbage which probably
// doesn't matter when dealing with textures but old habits die hard.


var lastPackState = {};
/**
 * Saves any packing state that will be set based on the options.
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 */

function savePackState(gl, options) {
  if (options.colorspaceConversion !== undefined) {
    lastPackState.colorspaceConversion = gl.getParameter(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, options.colorspaceConversion);
  }

  if (options.premultiplyAlpha !== undefined) {
    lastPackState.premultiplyAlpha = gl.getParameter(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlpha);
  }

  if (options.flipY !== undefined) {
    lastPackState.flipY = gl.getParameter(gl.UNPACK_FLIP_Y_WEBGL);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, options.flipY);
  }
}
/**
 * Restores any packing state that was set based on the options.
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 */


function restorePackState(gl, options) {
  if (options.colorspaceConversion !== undefined) {
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, lastPackState.colorspaceConversion);
  }

  if (options.premultiplyAlpha !== undefined) {
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, lastPackState.premultiplyAlpha);
  }

  if (options.flipY !== undefined) {
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, lastPackState.flipY);
  }
}
/**
 * Saves state related to data size
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 */


function saveSkipState(gl) {
  lastPackState.unpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);

  if (utils.isWebGL2(gl)) {
    lastPackState.unpackRowLength = gl.getParameter(gl.UNPACK_ROW_LENGTH);
    lastPackState.unpackImageHeight = gl.getParameter(gl.UNPACK_IMAGE_HEIGHT);
    lastPackState.unpackSkipPixels = gl.getParameter(gl.UNPACK_SKIP_PIXELS);
    lastPackState.unpackSkipRows = gl.getParameter(gl.UNPACK_SKIP_ROWS);
    lastPackState.unpackSkipImages = gl.getParameter(gl.UNPACK_SKIP_IMAGES);
  }
}
/**
 * Restores state related to data size
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 */


function restoreSkipState(gl) {
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, lastPackState.unpackAlignment);

  if (utils.isWebGL2(gl)) {
    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, lastPackState.unpackRowLength);
    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, lastPackState.unpackImageHeight);
    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, lastPackState.unpackSkipPixels);
    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, lastPackState.unpackSkipRows);
    gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, lastPackState.unpackSkipImages);
  }
}
/**
 * Sets the parameters of a texture or sampler
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {number|WebGLSampler} target texture target or sampler
 * @param {function()} parameteriFn texParamteri or samplerParameteri fn
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 */


function setTextureSamplerParameters(gl, target, parameteriFn, options) {
  if (options.minMag) {
    parameteriFn.call(gl, target, gl.TEXTURE_MIN_FILTER, options.minMag);
    parameteriFn.call(gl, target, gl.TEXTURE_MAG_FILTER, options.minMag);
  }

  if (options.min) {
    parameteriFn.call(gl, target, gl.TEXTURE_MIN_FILTER, options.min);
  }

  if (options.mag) {
    parameteriFn.call(gl, target, gl.TEXTURE_MAG_FILTER, options.mag);
  }

  if (options.wrap) {
    parameteriFn.call(gl, target, gl.TEXTURE_WRAP_S, options.wrap);
    parameteriFn.call(gl, target, gl.TEXTURE_WRAP_T, options.wrap);

    if (target === gl.TEXTURE_3D || helper.isSampler(gl, target)) {
      parameteriFn.call(gl, target, gl.TEXTURE_WRAP_R, options.wrap);
    }
  }

  if (options.wrapR) {
    parameteriFn.call(gl, target, gl.TEXTURE_WRAP_R, options.wrapR);
  }

  if (options.wrapS) {
    parameteriFn.call(gl, target, gl.TEXTURE_WRAP_S, options.wrapS);
  }

  if (options.wrapT) {
    parameteriFn.call(gl, target, gl.TEXTURE_WRAP_T, options.wrapT);
  }

  if (options.minLod) {
    parameteriFn.call(gl, target, gl.TEXTURE_MIN_LOD, options.minLod);
  }

  if (options.maxLod) {
    parameteriFn.call(gl, target, gl.TEXTURE_MAX_LOD, options.maxLod);
  }

  if (options.baseLevel) {
    parameteriFn.call(gl, target, gl.TEXTURE_BASE_LEVEL, options.baseLevel);
  }

  if (options.maxLevel) {
    parameteriFn.call(gl, target, gl.TEXTURE_MAX_LEVEL, options.maxLevel);
  }
}
/**
 * Sets the texture parameters of a texture.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */


function setTextureParameters(gl, tex, options) {
  var target = options.target || gl.TEXTURE_2D;
  gl.bindTexture(target, tex);
  setTextureSamplerParameters(gl, target, gl.texParameteri, options);
}
/**
 * Sets the sampler parameters of a sampler.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLSampler} sampler the WebGLSampler to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @memberOf module:twgl/textures
 */


function setSamplerParameters(gl, sampler, options) {
  setTextureSamplerParameters(gl, sampler, gl.samplerParameteri, options);
}
/**
 * Creates a new sampler object and sets parameters.
 *
 * Example:
 *
 *      const sampler = twgl.createSampler(gl, {
 *        minMag: gl.NEAREST,         // sets both TEXTURE_MIN_FILTER and TEXTURE_MAG_FILTER
 *        wrap: gl.CLAMP_TO_NEAREST,  // sets both TEXTURE_WRAP_S and TEXTURE_WRAP_T and TEXTURE_WRAP_R
 *      });
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per sampler.
 * @return {Object.<string,WebGLSampler>} the created samplers by name
 */


function createSampler(gl, options) {
  var sampler = gl.createSampler();
  setSamplerParameters(gl, sampler, options);
  return sampler;
}
/**
 * Creates a multiple sampler objects and sets parameters on each.
 *
 * Example:
 *
 *      const samplers = twgl.createSamplers(gl, {
 *        nearest: {
 *          minMag: gl.NEAREST,
 *        },
 *        nearestClampS: {
 *          minMag: gl.NEAREST,
 *          wrapS: gl.CLAMP_TO_NEAREST,
 *        },
 *        linear: {
 *          minMag: gl.LINEAR,
 *        },
 *        nearestClamp: {
 *          minMag: gl.NEAREST,
 *          wrap: gl.CLAMP_TO_EDGE,
 *        },
 *        linearClamp: {
 *          minMag: gl.LINEAR,
 *          wrap: gl.CLAMP_TO_EDGE,
 *        },
 *        linearClampT: {
 *          minMag: gl.LINEAR,
 *          wrapT: gl.CLAMP_TO_EDGE,
 *        },
 *      });
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set on the sampler
 */


function createSamplers(gl, samplerOptions) {
  var samplers = {};
  Object.keys(samplerOptions).forEach(function (name) {
    samplers[name] = createSampler(gl, samplerOptions[name]);
  });
  return samplers;
}
/**
 * Makes a 1x1 pixel
 * If no color is passed in uses the default color which can be set by calling `setDefaultTextureColor`.
 * @param {(number[]|ArrayBufferView)} [color] The color using 0-1 values
 * @return {Uint8Array} Unit8Array with color.
 */


function make1Pixel(color) {
  color = color || defaults.textureColor;

  if (isArrayBuffer(color)) {
    return color;
  }

  return new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);
}
/**
 * Sets filtering or generates mips for texture based on width or height
 * If width or height is not passed in uses `options.width` and//or `options.height`
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @param {number} [width] width of texture
 * @param {number} [height] height of texture
 * @param {number} [internalFormat] The internalFormat parameter from texImage2D etc..
 * @param {number} [type] The type parameter for texImage2D etc..
 * @memberOf module:twgl/textures
 */


function setTextureFilteringForSize(gl, tex, options, width, height, internalFormat, type) {
  options = options || defaults.textureOptions;
  internalFormat = internalFormat || gl.RGBA;
  type = type || gl.UNSIGNED_BYTE;
  var target = options.target || gl.TEXTURE_2D;
  width = width || options.width;
  height = height || options.height;
  gl.bindTexture(target, tex);

  if (canGenerateMipmap(gl, width, height, internalFormat, type)) {
    gl.generateMipmap(target);
  } else {
    var filtering = canFilter(internalFormat, type) ? gl.LINEAR : gl.NEAREST;
    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filtering);
    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filtering);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  }
}

function shouldAutomaticallySetTextureFilteringForSize(options) {
  return options.auto === true || options.auto === undefined && options.level === undefined;
}
/**
 * Gets an array of cubemap face enums
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @return {number[]} cubemap face enums
 */


function getCubeFaceOrder(gl, options) {
  options = options || {};
  return options.cubeFaceOrder || [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];
}
/**
 * @typedef {Object} FaceInfo
 * @property {number} face gl enum for texImage2D
 * @property {number} ndx face index (0 - 5) into source data
 * @ignore
 */

/**
 * Gets an array of FaceInfos
 * There's a bug in some NVidia drivers that will crash the driver if
 * `gl.TEXTURE_CUBE_MAP_POSITIVE_X` is not uploaded first. So, we take
 * the user's desired order from his faces to WebGL and make sure we
 * do the faces in WebGL order
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @return {FaceInfo[]} cubemap face infos. Arguably the `face` property of each element is redundent but
 *    it's needed internally to sort the array of `ndx` properties by `face`.
 */


function getCubeFacesWithNdx(gl, options) {
  var faces = getCubeFaceOrder(gl, options); // work around bug in NVidia drivers. We have to upload the first face first else the driver crashes :(

  var facesWithNdx = faces.map(function (face, ndx) {
    return {
      face: face,
      ndx: ndx
    };
  });
  facesWithNdx.sort(function (a, b) {
    return a.face - b.face;
  });
  return facesWithNdx;
}
/**
 * Set a texture from the contents of an element. Will also set
 * texture filtering or generate mips based on the dimensions of the element
 * unless `options.auto === false`. If `target === gl.TEXTURE_CUBE_MAP` will
 * attempt to slice image into 1x6, 2x3, 3x2, or 6x1 images, one for each face.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {HTMLElement} element a canvas, img, or video element.
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 * @kind function
 */


function setTextureFromElement(gl, tex, element, options) {
  options = options || defaults.textureOptions;
  var target = options.target || gl.TEXTURE_2D;
  var level = options.level || 0;
  var width = element.width;
  var height = element.height;
  var internalFormat = options.internalFormat || options.format || gl.RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || formatType.type;
  savePackState(gl, options);
  gl.bindTexture(target, tex);

  if (target === gl.TEXTURE_CUBE_MAP) {
    // guess the parts
    var imgWidth = element.width;
    var imgHeight = element.height;
    var size;
    var slices;

    if (imgWidth / 6 === imgHeight) {
      // It's 6x1
      size = imgHeight;
      slices = [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0];
    } else if (imgHeight / 6 === imgWidth) {
      // It's 1x6
      size = imgWidth;
      slices = [0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5];
    } else if (imgWidth / 3 === imgHeight / 2) {
      // It's 3x2
      size = imgWidth / 3;
      slices = [0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1];
    } else if (imgWidth / 2 === imgHeight / 3) {
      // It's 2x3
      size = imgWidth / 2;
      slices = [0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2];
    } else {
      throw "can't figure out cube map from element: " + (element.src ? element.src : element.nodeName);
    }

    if (ctx) {
      ctx.canvas.width = size;
      ctx.canvas.height = size;
      width = size;
      height = size;
      getCubeFacesWithNdx(gl, options).forEach(function (f) {
        var xOffset = slices[f.ndx * 2 + 0] * size;
        var yOffset = slices[f.ndx * 2 + 1] * size;
        ctx.drawImage(element, xOffset, yOffset, size, size, 0, 0, size, size);
        gl.texImage2D(f.face, level, internalFormat, format, type, ctx.canvas);
      }); // Free up the canvas memory

      ctx.canvas.width = 1;
      ctx.canvas.height = 1;
    } else if (_globalObject.default.createImageBitmap) {
      // NOTE: It seems like we should prefer ImageBitmap because unlike canvas it's
      // note lossy? (alpha is not premultiplied? although I'm not sure what
      width = size;
      height = size;
      getCubeFacesWithNdx(gl, options).forEach(function (f) {
        var xOffset = slices[f.ndx * 2 + 0] * size;
        var yOffset = slices[f.ndx * 2 + 1] * size; // We can't easily use a default texture color here as it would have to match
        // the type across all faces where as with a 2D one there's only one face
        // so we're replacing everything all at once. It also has to be the correct size.
        // On the other hand we need all faces to be the same size so as one face loads
        // the rest match else the texture will be unrenderable.

        gl.texImage2D(f.face, level, internalFormat, size, size, 0, format, type, null);

        _globalObject.default.createImageBitmap(element, xOffset, yOffset, size, size, {
          premultiplyAlpha: 'none',
          colorSpaceConversion: 'none'
        }).then(function (imageBitmap) {
          savePackState(gl, options);
          gl.bindTexture(target, tex);
          gl.texImage2D(f.face, level, internalFormat, format, type, imageBitmap);
          restorePackState(gl, options);

          if (shouldAutomaticallySetTextureFilteringForSize(options)) {
            setTextureFilteringForSize(gl, tex, options, width, height, internalFormat, type);
          }
        });
      });
    }
  } else if (target === gl.TEXTURE_3D || target === gl.TEXTURE_2D_ARRAY) {
    var smallest = Math.min(element.width, element.height);
    var largest = Math.max(element.width, element.height);
    var depth = largest / smallest;

    if (depth % 1 !== 0) {
      throw "can not compute 3D dimensions of element";
    }

    var xMult = element.width === largest ? 1 : 0;
    var yMult = element.height === largest ? 1 : 0;
    saveSkipState(gl);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, element.width);
    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, 0);
    gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, 0);
    gl.texImage3D(target, level, internalFormat, smallest, smallest, smallest, 0, format, type, null);

    for (var d = 0; d < depth; ++d) {
      var srcX = d * smallest * xMult;
      var srcY = d * smallest * yMult;
      gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, srcX);
      gl.pixelStorei(gl.UNPACK_SKIP_ROWS, srcY);
      gl.texSubImage3D(target, level, 0, 0, d, smallest, smallest, 1, format, type, element);
    }

    restoreSkipState(gl);
  } else {
    gl.texImage2D(target, level, internalFormat, format, type, element);
  }

  restorePackState(gl, options);

  if (shouldAutomaticallySetTextureFilteringForSize(options)) {
    setTextureFilteringForSize(gl, tex, options, width, height, internalFormat, type);
  }

  setTextureParameters(gl, tex, options);
}

function noop() {}
/**
 * Loads an image
 * @param {string} url url to image
 * @param {string} crossOrigin
 * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null
 *     if there was an error
 * @return {HTMLImageElement} the image being loaded.
 */


function loadImage(url, crossOrigin, callback) {
  callback = callback || noop;
  var img;

  if (_globalObject.default.Image) {
    img = new _globalObject.default.Image();
    crossOrigin = crossOrigin !== undefined ? crossOrigin : defaults.crossOrigin;

    if (crossOrigin !== undefined) {
      img.crossOrigin = crossOrigin;
    }

    var clearEventHandlers = function clearEventHandlers() {
      img.removeEventListener('error', onError); // eslint-disable-line

      img.removeEventListener('load', onLoad); // eslint-disable-line

      img = null;
    };

    var onError = function onError() {
      var msg = "couldn't load image: " + url;
      helper.error(msg);
      callback(msg, img);
      clearEventHandlers();
    };

    var onLoad = function onLoad() {
      callback(null, img);
      clearEventHandlers();
    };

    img.addEventListener('error', onError);
    img.addEventListener('load', onLoad);
    img.src = url;
    return img;
  } else if (_globalObject.default.ImageBitmap) {
    var err;
    var bm;

    var cb = function cb() {
      callback(err, bm);
    };

    var options = {};

    if (crossOrigin) {
      options.mode = 'cors'; // TODO: not sure how to translate image.crossOrigin
    }

    fetch(url, options).then(function (response) {
      if (!response.ok) {
        throw response;
      }

      return response.blob();
    }).then(function (blob) {
      return _globalObject.default.createImageBitmap(blob, {
        premultiplyAlpha: 'none',
        colorSpaceConversion: 'none'
      });
    }).then(function (bitmap) {
      // not sure if this works. We don't want
      // to catch the user's error. So, call
      // the callback in a timeout so we're
      // not in this scope inside the promise.
      bm = bitmap;
      setTimeout(cb);
    }).catch(function (e) {
      err = e;
      setTimeout(cb);
    });
    img = null;
  }

  return img;
}
/**
 * check if object is a TexImageSource
 *
 * @param {Object} obj Object to test
 * @return {boolean} true if object is a TexImageSource
 */


function isTexImageSource(obj) {
  return _globalObject.default.ImageBitmap && obj instanceof _globalObject.default.ImageBitmap || _globalObject.default.ImageData && obj instanceof _globalObject.default.ImageData || _globalObject.default.HTMLElement && obj instanceof _globalObject.default.HTMLElement;
}
/**
 * if obj is an TexImageSource then just
 * uses it otherwise if obj is a string
 * then load it first.
 *
 * @param {string|TexImageSource} obj
 * @param {string} crossOrigin
 * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null
 *     if there was an error
 */


function loadAndUseImage(obj, crossOrigin, callback) {
  if (isTexImageSource(obj)) {
    setTimeout(function () {
      callback(null, obj);
    });
    return obj;
  }

  return loadImage(obj, crossOrigin, callback);
}
/**
 * Sets a texture to a 1x1 pixel color. If `options.color === false` is nothing happens. If it's not set
 * the default texture color is used which can be set by calling `setDefaultTextureColor`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */


function setTextureTo1PixelColor(gl, tex, options) {
  options = options || defaults.textureOptions;
  var target = options.target || gl.TEXTURE_2D;
  gl.bindTexture(target, tex);

  if (options.color === false) {
    return;
  } // Assume it's a URL
  // Put 1x1 pixels in texture. That makes it renderable immediately regardless of filtering.


  var color = make1Pixel(options.color);

  if (target === gl.TEXTURE_CUBE_MAP) {
    for (var ii = 0; ii < 6; ++ii) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);
    }
  } else if (target === gl.TEXTURE_3D || target === gl.TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, 0, gl.RGBA, 1, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);
  } else {
    gl.texImage2D(target, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);
  }
}
/**
 * The src image(s) used to create a texture.
 *
 * When you call {@link module:twgl.createTexture} or {@link module:twgl.createTextures}
 * you can pass in urls for images to load into the textures. If it's a single url
 * then this will be a single HTMLImageElement. If it's an array of urls used for a cubemap
 * this will be a corresponding array of images for the cubemap.
 *
 * @typedef {HTMLImageElement|HTMLImageElement[]} TextureSrc
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback TextureReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} texture the texture.
 * @param {module:twgl.TextureSrc} souce image(s) used to as the src for the texture
 * @memberOf module:twgl
 */

/**
 * A callback for when all images have finished downloading and been uploaded into their respective textures
 * @callback TexturesReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {Object.<string, WebGLTexture>} textures the created textures by name. Same as returned by {@link module:twgl.createTextures}.
 * @param {Object.<string, module:twgl.TextureSrc>} sources the image(s) used for the texture by name.
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback CubemapReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} tex the texture.
 * @param {HTMLImageElement[]} imgs the images for each face.
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback ThreeDReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} tex the texture.
 * @param {HTMLImageElement[]} imgs the images for each slice.
 * @memberOf module:twgl
 */

/**
 * Loads a texture from an image from a Url as specified in `options.src`
 * If `options.color !== false` will set the texture to a 1x1 pixel color so that the texture is
 * immediately useable. It will be updated with the contents of the image once the image has finished
 * downloading. Filtering options will be set as approriate for image unless `options.auto === false`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.TextureReadyCallback} [callback] A function to be called when the image has finished loading. err will
 *    be non null if there was an error.
 * @return {HTMLImageElement} the image being downloaded.
 * @memberOf module:twgl/textures
 */


function loadTextureFromUrl(gl, tex, options, callback) {
  callback = callback || noop;
  options = options || defaults.textureOptions;
  setTextureTo1PixelColor(gl, tex, options); // Because it's async we need to copy the options.

  options = Object.assign({}, options);
  var img = loadAndUseImage(options.src, options.crossOrigin, function (err, img) {
    if (err) {
      callback(err, tex, img);
    } else {
      setTextureFromElement(gl, tex, img, options);
      callback(null, tex, img);
    }
  });
  return img;
}
/**
 * Loads a cubemap from 6 urls or TexImageSources as specified in `options.src`. Will set the cubemap to a 1x1 pixel color
 * so that it is usable immediately unless `option.color === false`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.CubemapReadyCallback} [callback] A function to be called when all the images have finished loading. err will
 *    be non null if there was an error.
 * @memberOf module:twgl/textures
 */


function loadCubemapFromUrls(gl, tex, options, callback) {
  callback = callback || noop;
  var urls = options.src;

  if (urls.length !== 6) {
    throw "there must be 6 urls for a cubemap";
  }

  var level = options.level || 0;
  var internalFormat = options.internalFormat || options.format || gl.RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || gl.UNSIGNED_BYTE;
  var target = options.target || gl.TEXTURE_2D;

  if (target !== gl.TEXTURE_CUBE_MAP) {
    throw "target must be TEXTURE_CUBE_MAP";
  }

  setTextureTo1PixelColor(gl, tex, options); // Because it's async we need to copy the options.

  options = Object.assign({}, options);
  var numToLoad = 6;
  var errors = [];
  var faces = getCubeFaceOrder(gl, options);
  var imgs; // eslint-disable-line

  function uploadImg(faceTarget) {
    return function (err, img) {
      --numToLoad;

      if (err) {
        errors.push(err);
      } else {
        if (img.width !== img.height) {
          errors.push("cubemap face img is not a square: " + img.src);
        } else {
          savePackState(gl, options);
          gl.bindTexture(target, tex); // So assuming this is the first image we now have one face that's img sized
          // and 5 faces that are 1x1 pixel so size the other faces

          if (numToLoad === 5) {
            // use the default order
            getCubeFaceOrder(gl).forEach(function (otherTarget) {
              // Should we re-use the same face or a color?
              gl.texImage2D(otherTarget, level, internalFormat, format, type, img);
            });
          } else {
            gl.texImage2D(faceTarget, level, internalFormat, format, type, img);
          }

          restorePackState(gl, options);

          if (shouldAutomaticallySetTextureFilteringForSize(options)) {
            gl.generateMipmap(target);
          }
        }
      }

      if (numToLoad === 0) {
        callback(errors.length ? errors : undefined, tex, imgs);
      }
    };
  }

  imgs = urls.map(function (url, ndx) {
    return loadAndUseImage(url, options.crossOrigin, uploadImg(faces[ndx]));
  });
}
/**
 * Loads a 2d array or 3d texture from urls OR TexImageSources as specified in `options.src`.
 * Will set the texture to a 1x1 pixel color
 * so that it is usable immediately unless `option.color === false`.
 *
 * If the width and height is not specified the width and height of the first
 * image loaded will be used. Note that since images are loaded async
 * which image downloads first is unknown.
 *
 * If an image is not the same size as the width and height it will be scaled
 * to that width and height.
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.ThreeDReadyCallback} [callback] A function to be called when all the images have finished loading. err will
 *    be non null if there was an error.
 * @memberOf module:twgl/textures
 */


function loadSlicesFromUrls(gl, tex, options, callback) {
  callback = callback || noop;
  var urls = options.src;
  var internalFormat = options.internalFormat || options.format || gl.RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || gl.UNSIGNED_BYTE;
  var target = options.target || gl.TEXTURE_2D_ARRAY;

  if (target !== gl.TEXTURE_3D && target !== gl.TEXTURE_2D_ARRAY) {
    throw "target must be TEXTURE_3D or TEXTURE_2D_ARRAY";
  }

  setTextureTo1PixelColor(gl, tex, options); // Because it's async we need to copy the options.

  options = Object.assign({}, options);
  var numToLoad = urls.length;
  var errors = [];
  var imgs; // eslint-disable-line

  var level = options.level || 0;
  var width = options.width;
  var height = options.height;
  var depth = urls.length;
  var firstImage = true;

  function uploadImg(slice) {
    return function (err, img) {
      --numToLoad;

      if (err) {
        errors.push(err);
      } else {
        savePackState(gl, options);
        gl.bindTexture(target, tex);

        if (firstImage) {
          firstImage = false;
          width = options.width || img.width;
          height = options.height || img.height;
          gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, null); // put it in every slice otherwise some slices will be 0,0,0,0

          for (var s = 0; s < depth; ++s) {
            gl.texSubImage3D(target, level, 0, 0, s, width, height, 1, format, type, img);
          }
        } else {
          var src = img;

          if (img.width !== width || img.height !== height) {
            // Size the image to fix
            src = ctx.canvas;
            ctx.canvas.width = width;
            ctx.canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
          }

          gl.texSubImage3D(target, level, 0, 0, slice, width, height, 1, format, type, src); // free the canvas memory

          if (src === ctx.canvas) {
            ctx.canvas.width = 0;
            ctx.canvas.height = 0;
          }
        }

        restorePackState(gl, options);

        if (shouldAutomaticallySetTextureFilteringForSize(options)) {
          gl.generateMipmap(target);
        }
      }

      if (numToLoad === 0) {
        callback(errors.length ? errors : undefined, tex, imgs);
      }
    };
  }

  imgs = urls.map(function (url, ndx) {
    return loadAndUseImage(url, options.crossOrigin, uploadImg(ndx));
  });
}
/**
 * Sets a texture from an array or typed array. If the width or height is not provided will attempt to
 * guess the size. See {@link module:twgl.TextureOptions}.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {(number[]|ArrayBufferView)} src An array or typed arry with texture data.
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */


function setTextureFromArray(gl, tex, src, options) {
  options = options || defaults.textureOptions;
  var target = options.target || gl.TEXTURE_2D;
  gl.bindTexture(target, tex);
  var width = options.width;
  var height = options.height;
  var depth = options.depth;
  var level = options.level || 0;
  var internalFormat = options.internalFormat || options.format || gl.RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);

  if (!isArrayBuffer(src)) {
    var Type = typedArrays.getTypedArrayTypeForGLType(type);
    src = new Type(src);
  } else if (src instanceof Uint8ClampedArray) {
    src = new Uint8Array(src.buffer);
  }

  var bytesPerElement = getBytesPerElementForInternalFormat(internalFormat, type);
  var numElements = src.byteLength / bytesPerElement; // TODO: check UNPACK_ALIGNMENT?

  if (numElements % 1) {
    throw "length wrong size for format: " + utils.glEnumToString(gl, format);
  }

  var dimensions;

  if (target === gl.TEXTURE_3D) {
    if (!width && !height && !depth) {
      var size = Math.cbrt(numElements);

      if (size % 1 !== 0) {
        throw "can't guess cube size of array of numElements: " + numElements;
      }

      width = size;
      height = size;
      depth = size;
    } else if (width && (!height || !depth)) {
      dimensions = guessDimensions(gl, target, height, depth, numElements / width);
      height = dimensions.width;
      depth = dimensions.height;
    } else if (height && (!width || !depth)) {
      dimensions = guessDimensions(gl, target, width, depth, numElements / height);
      width = dimensions.width;
      depth = dimensions.height;
    } else {
      dimensions = guessDimensions(gl, target, width, height, numElements / depth);
      width = dimensions.width;
      height = dimensions.height;
    }
  } else {
    dimensions = guessDimensions(gl, target, width, height, numElements);
    width = dimensions.width;
    height = dimensions.height;
  }

  saveSkipState(gl);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, options.unpackAlignment || 1);
  savePackState(gl, options);

  if (target === gl.TEXTURE_CUBE_MAP) {
    var elementsPerElement = bytesPerElement / src.BYTES_PER_ELEMENT;
    var faceSize = numElements / 6 * elementsPerElement;
    getCubeFacesWithNdx(gl, options).forEach(function (f) {
      var offset = faceSize * f.ndx;
      var data = src.subarray(offset, offset + faceSize);
      gl.texImage2D(f.face, level, internalFormat, width, height, 0, format, type, data);
    });
  } else if (target === gl.TEXTURE_3D) {
    gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, src);
  } else {
    gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, src);
  }

  restorePackState(gl, options);
  restoreSkipState(gl);
  return {
    width: width,
    height: height,
    depth: depth,
    type: type
  };
}
/**
 * Sets a texture with no contents of a certain size. In other words calls `gl.texImage2D` with `null`.
 * You must set `options.width` and `options.height`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @memberOf module:twgl/textures
 */


function setEmptyTexture(gl, tex, options) {
  var target = options.target || gl.TEXTURE_2D;
  gl.bindTexture(target, tex);
  var level = options.level || 0;
  var internalFormat = options.internalFormat || options.format || gl.RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type = options.type || formatType.type;
  savePackState(gl, options);

  if (target === gl.TEXTURE_CUBE_MAP) {
    for (var ii = 0; ii < 6; ++ii) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, level, internalFormat, options.width, options.height, 0, format, type, null);
    }
  } else if (target === gl.TEXTURE_3D) {
    gl.texImage3D(target, level, internalFormat, options.width, options.height, options.depth, 0, format, type, null);
  } else {
    gl.texImage2D(target, level, internalFormat, options.width, options.height, 0, format, type, null);
  }

  restorePackState(gl, options);
}
/**
 * Creates a texture based on the options passed in.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.TextureReadyCallback} [callback] A callback called when an image has been downloaded and uploaded to the texture.
 * @return {WebGLTexture} the created texture.
 * @memberOf module:twgl/textures
 */


function createTexture(gl, options, callback) {
  callback = callback || noop;
  options = options || defaults.textureOptions;
  var tex = gl.createTexture();
  var target = options.target || gl.TEXTURE_2D;
  var width = options.width || 1;
  var height = options.height || 1;
  var internalFormat = options.internalFormat || gl.RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var type = options.type || formatType.type;
  gl.bindTexture(target, tex);

  if (target === gl.TEXTURE_CUBE_MAP) {
    // this should have been the default for CUBEMAPS :(
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  }

  var src = options.src;

  if (src) {
    if (typeof src === "function") {
      src = src(gl, options);
    }

    if (typeof src === "string") {
      loadTextureFromUrl(gl, tex, options, callback);
    } else if (isArrayBuffer(src) || Array.isArray(src) && (typeof src[0] === 'number' || Array.isArray(src[0]) || isArrayBuffer(src[0]))) {
      var dimensions = setTextureFromArray(gl, tex, src, options);
      width = dimensions.width;
      height = dimensions.height;
      type = dimensions.type;
    } else if (Array.isArray(src) && (typeof src[0] === 'string' || isTexImageSource(src[0]))) {
      if (target === gl.TEXTURE_CUBE_MAP) {
        loadCubemapFromUrls(gl, tex, options, callback);
      } else {
        loadSlicesFromUrls(gl, tex, options, callback);
      }
    } else if (isTexImageSource(src)) {
      setTextureFromElement(gl, tex, src, options);
      width = src.width;
      height = src.height;
    } else {
      throw "unsupported src type";
    }
  } else {
    setEmptyTexture(gl, tex, options);
  }

  if (shouldAutomaticallySetTextureFilteringForSize(options)) {
    setTextureFilteringForSize(gl, tex, options, width, height, internalFormat, type);
  }

  setTextureParameters(gl, tex, options);
  return tex;
}
/**
 * Resizes a texture based on the options passed in.
 *
 * Note: This is not a generic resize anything function.
 * It's mostly used by {@link module:twgl.resizeFramebufferInfo}
 * It will use `options.src` if it exists to try to determine a `type`
 * otherwise it will assume `gl.UNSIGNED_BYTE`. No data is provided
 * for the texture. Texture parameters will be set accordingly
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the texture to resize
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {number} [width] the new width. If not passed in will use `options.width`
 * @param {number} [height] the new height. If not passed in will use `options.height`
 * @memberOf module:twgl/textures
 */


function resizeTexture(gl, tex, options, width, height) {
  width = width || options.width;
  height = height || options.height;
  var target = options.target || gl.TEXTURE_2D;
  gl.bindTexture(target, tex);
  var level = options.level || 0;
  var internalFormat = options.internalFormat || options.format || gl.RGBA;
  var formatType = getFormatAndTypeForInternalFormat(internalFormat);
  var format = options.format || formatType.format;
  var type;
  var src = options.src;

  if (!src) {
    type = options.type || formatType.type;
  } else if (isArrayBuffer(src) || Array.isArray(src) && typeof src[0] === 'number') {
    type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);
  } else {
    type = options.type || formatType.type;
  }

  if (target === gl.TEXTURE_CUBE_MAP) {
    for (var ii = 0; ii < 6; ++ii) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, level, internalFormat, width, height, 0, format, type, null);
    }
  } else {
    gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);
  }
}
/**
 * Check if a src is an async request.
 * if src is a string we're going to download an image
 * if src is an array of strings we're going to download cubemap images
 * @param {*} src The src from a TextureOptions
 * @returns {bool} true if src is async.
 */


function isAsyncSrc(src) {
  return typeof src === 'string' || Array.isArray(src) && typeof src[0] === 'string';
}
/**
 * Creates a bunch of textures based on the passed in options.
 *
 * Example:
 *
 *     const textures = twgl.createTextures(gl, {
 *       // a power of 2 image
 *       hftIcon: { src: "images/hft-icon-16.png", mag: gl.NEAREST },
 *       // a non-power of 2 image
 *       clover: { src: "images/clover.jpg" },
 *       // From a canvas
 *       fromCanvas: { src: ctx.canvas },
 *       // A cubemap from 6 images
 *       yokohama: {
 *         target: gl.TEXTURE_CUBE_MAP,
 *         src: [
 *           'images/yokohama/posx.jpg',
 *           'images/yokohama/negx.jpg',
 *           'images/yokohama/posy.jpg',
 *           'images/yokohama/negy.jpg',
 *           'images/yokohama/posz.jpg',
 *           'images/yokohama/negz.jpg',
 *         ],
 *       },
 *       // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)
 *       goldengate: {
 *         target: gl.TEXTURE_CUBE_MAP,
 *         src: 'images/goldengate.jpg',
 *       },
 *       // A 2x2 pixel texture from a JavaScript array
 *       checker: {
 *         mag: gl.NEAREST,
 *         min: gl.LINEAR,
 *         src: [
 *           255,255,255,255,
 *           192,192,192,255,
 *           192,192,192,255,
 *           255,255,255,255,
 *         ],
 *       },
 *       // a 1x2 pixel texture from a typed array.
 *       stripe: {
 *         mag: gl.NEAREST,
 *         min: gl.LINEAR,
 *         format: gl.LUMINANCE,
 *         src: new Uint8Array([
 *           255,
 *           128,
 *           255,
 *           128,
 *           255,
 *           128,
 *           255,
 *           128,
 *         ]),
 *         width: 1,
 *       },
 *     });
 *
 * Now
 *
 * *   `textures.hftIcon` will be a 2d texture
 * *   `textures.clover` will be a 2d texture
 * *   `textures.fromCanvas` will be a 2d texture
 * *   `textures.yohohama` will be a cubemap texture
 * *   `textures.goldengate` will be a cubemap texture
 * *   `textures.checker` will be a 2d texture
 * *   `textures.stripe` will be a 2d texture
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per texture.
 * @param {module:twgl.TexturesReadyCallback} [callback] A callback called when all textures have been downloaded.
 * @return {Object.<string,WebGLTexture>} the created textures by name
 * @memberOf module:twgl/textures
 */


function createTextures(gl, textureOptions, callback) {
  callback = callback || noop;
  var numDownloading = 0;
  var errors = [];
  var textures = {};
  var images = {};

  function callCallbackIfReady() {
    if (numDownloading === 0) {
      setTimeout(function () {
        callback(errors.length ? errors : undefined, textures, images);
      }, 0);
    }
  }

  Object.keys(textureOptions).forEach(function (name) {
    var options = textureOptions[name];
    var onLoadFn;

    if (isAsyncSrc(options.src)) {
      onLoadFn = function onLoadFn(err, tex, img) {
        images[name] = img;
        --numDownloading;

        if (err) {
          errors.push(err);
        }

        callCallbackIfReady();
      };

      ++numDownloading;
    }

    textures[name] = createTexture(gl, options, onLoadFn);
  }); // queue the callback if there are no images to download.
  // We do this because if your code is structured to wait for
  // images to download but then you comment out all the async
  // images your code would break.

  callCallbackIfReady();
  return textures;
} // Using quotes prevents Uglify from changing the names.
// No speed diff AFAICT.

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var _exportNames = {
  m4: true,
  v3: true,
  primitives: true
};
exports.primitives = exports.v3 = exports.m4 = void 0;

var m4 = _interopRequireWildcard(__webpack_require__(6));

exports.m4 = m4;

var v3 = _interopRequireWildcard(__webpack_require__(3));

exports.v3 = v3;

var primitives = _interopRequireWildcard(__webpack_require__(10));

exports.primitives = primitives;

var _twgl = __webpack_require__(11);

Object.keys(_twgl).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _twgl[key];
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.create3DFVertices = create3DFVertices;
exports.createAugmentedTypedArray = createAugmentedTypedArray;
exports.createCubeVertices = createCubeVertices;
exports.createPlaneVertices = createPlaneVertices;
exports.createSphereVertices = createSphereVertices;
exports.createTruncatedConeVertices = createTruncatedConeVertices;
exports.createXYQuadVertices = createXYQuadVertices;
exports.createCresentVertices = createCresentVertices;
exports.createCylinderVertices = createCylinderVertices;
exports.createTorusVertices = createTorusVertices;
exports.createDiscVertices = createDiscVertices;
exports.deindexVertices = deindexVertices;
exports.flattenNormals = flattenNormals;
exports.makeRandomVertexColors = makeRandomVertexColors;
exports.reorientDirections = reorientDirections;
exports.reorientNormals = reorientNormals;
exports.reorientPositions = reorientPositions;
exports.reorientVertices = reorientVertices;
exports.concatVertices = concatVertices;
exports.duplicateVertices = duplicateVertices;
exports.createDiscBuffers = exports.createDiscBufferInfo = exports.createTorusBuffers = exports.createTorusBufferInfo = exports.createCylinderBuffers = exports.createCylinderBufferInfo = exports.createCresentBuffers = exports.createCresentBufferInfo = exports.createXYQuadBuffers = exports.createXYQuadBufferInfo = exports.createTruncatedConeBuffers = exports.createTruncatedConeBufferInfo = exports.createSphereBuffers = exports.createSphereBufferInfo = exports.createPlaneBuffers = exports.createPlaneBufferInfo = exports.createCubeBuffers = exports.createCubeBufferInfo = exports.create3DFBuffers = exports.create3DFBufferInfo = void 0;

var attributes = _interopRequireWildcard(__webpack_require__(7));

var helper = _interopRequireWildcard(__webpack_require__(0));

var typedArrays = _interopRequireWildcard(__webpack_require__(1));

var m4 = _interopRequireWildcard(__webpack_require__(6));

var v3 = _interopRequireWildcard(__webpack_require__(3));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/*
 * Copyright 2015, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Various functions to make simple primitives
 *
 * note: Most primitive functions come in 3 styles
 *
 * *  `createSomeShapeBufferInfo`
 *
 *    These functions are almost always the functions you want to call. They
 *    create vertices then make WebGLBuffers and create {@link module:twgl.AttribInfo}s
 *    returing a {@link module:twgl.BufferInfo} you can pass to {@link module:twgl.setBuffersAndAttributes}
 *    and {@link module:twgl.drawBufferInfo} etc...
 *
 * *  `createSomeShapeBuffers`
 *
 *    These create WebGLBuffers and put your data in them but nothing else.
 *    It's a shortcut to doing it yourself if you don't want to use
 *    the higher level functions.
 *
 * *  `createSomeShapeVertices`
 *
 *    These just create vertices, no buffers. This allows you to manipulate the vertices
 *    or add more data before generating a {@link module:twgl.BufferInfo}. Once you're finished
 *    manipulating the vertices call {@link module:twgl.createBufferInfoFromArrays}.
 *
 *    example:
 *
 *        const arrays = twgl.primitives.createPlaneArrays(1);
 *        twgl.primitives.reorientVertices(arrays, m4.rotationX(Math.PI * 0.5));
 *        const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
 *
 * @module twgl/primitives
 */
var getArray = attributes.getArray_; // eslint-disable-line

var getNumComponents = attributes.getNumComponents_; // eslint-disable-line

/**
 * Add `push` to a typed array. It just keeps a 'cursor'
 * and allows use to `push` values into the array so we
 * don't have to manually compute offsets
 * @param {TypedArray} typedArray TypedArray to augment
 * @param {number} numComponents number of components.
 */

function augmentTypedArray(typedArray, numComponents) {
  var cursor = 0;

  typedArray.push = function () {
    for (var ii = 0; ii < arguments.length; ++ii) {
      var value = arguments[ii];

      if (value instanceof Array || typedArrays.isArrayBuffer(value)) {
        for (var jj = 0; jj < value.length; ++jj) {
          typedArray[cursor++] = value[jj];
        }
      } else {
        typedArray[cursor++] = value;
      }
    }
  };

  typedArray.reset = function (opt_index) {
    cursor = opt_index || 0;
  };

  typedArray.numComponents = numComponents;
  Object.defineProperty(typedArray, 'numElements', {
    get: function get() {
      return this.length / this.numComponents | 0;
    }
  });
  return typedArray;
}
/**
 * creates a typed array with a `push` function attached
 * so that you can easily *push* values.
 *
 * `push` can take multiple arguments. If an argument is an array each element
 * of the array will be added to the typed array.
 *
 * Example:
 *
 *     const array = createAugmentedTypedArray(3, 2);  // creates a Float32Array with 6 values
 *     array.push(1, 2, 3);
 *     array.push([4, 5, 6]);
 *     // array now contains [1, 2, 3, 4, 5, 6]
 *
 * Also has `numComponents` and `numElements` properties.
 *
 * @param {number} numComponents number of components
 * @param {number} numElements number of elements. The total size of the array will be `numComponents * numElements`.
 * @param {constructor} opt_type A constructor for the type. Default = `Float32Array`.
 * @return {ArrayBufferView} A typed array.
 * @memberOf module:twgl/primitives
 */


function createAugmentedTypedArray(numComponents, numElements, opt_type) {
  var Type = opt_type || Float32Array;
  return augmentTypedArray(new Type(numComponents * numElements), numComponents);
}

function allButIndices(name) {
  return name !== "indices";
}
/**
 * Given indexed vertices creates a new set of vertices unindexed by expanding the indexed vertices.
 * @param {Object.<string, TypedArray>} vertices The indexed vertices to deindex
 * @return {Object.<string, TypedArray>} The deindexed vertices
 * @memberOf module:twgl/primitives
 */


function deindexVertices(vertices) {
  var indices = vertices.indices;
  var newVertices = {};
  var numElements = indices.length;

  function expandToUnindexed(channel) {
    var srcBuffer = vertices[channel];
    var numComponents = srcBuffer.numComponents;
    var dstBuffer = createAugmentedTypedArray(numComponents, numElements, srcBuffer.constructor);

    for (var ii = 0; ii < numElements; ++ii) {
      var ndx = indices[ii];
      var offset = ndx * numComponents;

      for (var jj = 0; jj < numComponents; ++jj) {
        dstBuffer.push(srcBuffer[offset + jj]);
      }
    }

    newVertices[channel] = dstBuffer;
  }

  Object.keys(vertices).filter(allButIndices).forEach(expandToUnindexed);
  return newVertices;
}
/**
 * flattens the normals of deindexed vertices in place.
 * @param {Object.<string, TypedArray>} vertices The deindexed vertices who's normals to flatten
 * @return {Object.<string, TypedArray>} The flattened vertices (same as was passed in)
 * @memberOf module:twgl/primitives
 */


function flattenNormals(vertices) {
  if (vertices.indices) {
    throw "can't flatten normals of indexed vertices. deindex them first";
  }

  var normals = vertices.normal;
  var numNormals = normals.length;

  for (var ii = 0; ii < numNormals; ii += 9) {
    // pull out the 3 normals for this triangle
    var nax = normals[ii + 0];
    var nay = normals[ii + 1];
    var naz = normals[ii + 2];
    var nbx = normals[ii + 3];
    var nby = normals[ii + 4];
    var nbz = normals[ii + 5];
    var ncx = normals[ii + 6];
    var ncy = normals[ii + 7];
    var ncz = normals[ii + 8]; // add them

    var nx = nax + nbx + ncx;
    var ny = nay + nby + ncy;
    var nz = naz + nbz + ncz; // normalize them

    var length = Math.sqrt(nx * nx + ny * ny + nz * nz);
    nx /= length;
    ny /= length;
    nz /= length; // copy them back in

    normals[ii + 0] = nx;
    normals[ii + 1] = ny;
    normals[ii + 2] = nz;
    normals[ii + 3] = nx;
    normals[ii + 4] = ny;
    normals[ii + 5] = nz;
    normals[ii + 6] = nx;
    normals[ii + 7] = ny;
    normals[ii + 8] = nz;
  }

  return vertices;
}

function applyFuncToV3Array(array, matrix, fn) {
  var len = array.length;
  var tmp = new Float32Array(3);

  for (var ii = 0; ii < len; ii += 3) {
    fn(matrix, [array[ii], array[ii + 1], array[ii + 2]], tmp);
    array[ii] = tmp[0];
    array[ii + 1] = tmp[1];
    array[ii + 2] = tmp[2];
  }
}

function transformNormal(mi, v, dst) {
  dst = dst || v3.create();
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];
  dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];
  dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];
  return dst;
}
/**
 * Reorients directions by the given matrix..
 * @param {number[]|TypedArray} array The array. Assumes value floats per element.
 * @param {Matrix} matrix A matrix to multiply by.
 * @return {number[]|TypedArray} the same array that was passed in
 * @memberOf module:twgl/primitives
 */


function reorientDirections(array, matrix) {
  applyFuncToV3Array(array, matrix, m4.transformDirection);
  return array;
}
/**
 * Reorients normals by the inverse-transpose of the given
 * matrix..
 * @param {number[]|TypedArray} array The array. Assumes value floats per element.
 * @param {Matrix} matrix A matrix to multiply by.
 * @return {number[]|TypedArray} the same array that was passed in
 * @memberOf module:twgl/primitives
 */


function reorientNormals(array, matrix) {
  applyFuncToV3Array(array, m4.inverse(matrix), transformNormal);
  return array;
}
/**
 * Reorients positions by the given matrix. In other words, it
 * multiplies each vertex by the given matrix.
 * @param {number[]|TypedArray} array The array. Assumes value floats per element.
 * @param {Matrix} matrix A matrix to multiply by.
 * @return {number[]|TypedArray} the same array that was passed in
 * @memberOf module:twgl/primitives
 */


function reorientPositions(array, matrix) {
  applyFuncToV3Array(array, matrix, m4.transformPoint);
  return array;
}
/**
 * Reorients arrays by the given matrix. Assumes arrays have
 * names that contains 'pos' could be reoriented as positions,
 * 'binorm' or 'tan' as directions, and 'norm' as normals.
 *
 * @param {Object.<string, (number[]|TypedArray)>} arrays The vertices to reorient
 * @param {Matrix} matrix matrix to reorient by.
 * @return {Object.<string, (number[]|TypedArray)>} same arrays that were passed in.
 * @memberOf module:twgl/primitives
 */


function reorientVertices(arrays, matrix) {
  Object.keys(arrays).forEach(function (name) {
    var array = arrays[name];

    if (name.indexOf("pos") >= 0) {
      reorientPositions(array, matrix);
    } else if (name.indexOf("tan") >= 0 || name.indexOf("binorm") >= 0) {
      reorientDirections(array, matrix);
    } else if (name.indexOf("norm") >= 0) {
      reorientNormals(array, matrix);
    }
  });
  return arrays;
}
/**
 * Creates XY quad BufferInfo
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {Object.<string, WebGLBuffer>} the created XY Quad BufferInfo
 * @memberOf module:twgl/primitives
 * @function createXYQuadBufferInfo
 */

/**
 * Creates XY quad Buffers
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {module:twgl.BufferInfo} the created XY Quad buffers
 * @memberOf module:twgl/primitives
 * @function createXYQuadBuffers
 */

/**
 * Creates XY quad vertices
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadVertices(1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadVertices(1, 0, 0.5);
 *
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {Object.<string, TypedArray> the created XY Quad vertices
 * @memberOf module:twgl/primitives
 */


function createXYQuadVertices(size, xOffset, yOffset) {
  size = size || 2;
  xOffset = xOffset || 0;
  yOffset = yOffset || 0;
  size *= 0.5;
  return {
    position: {
      numComponents: 2,
      data: [xOffset + -1 * size, yOffset + -1 * size, xOffset + 1 * size, yOffset + -1 * size, xOffset + -1 * size, yOffset + 1 * size, xOffset + 1 * size, yOffset + 1 * size]
    },
    normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
    texcoord: [0, 0, 1, 0, 0, 1, 1, 1],
    indices: [0, 1, 2, 2, 1, 3]
  };
}
/**
 * Creates XZ plane BufferInfo.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {Matrix4} [matrix] A matrix by which to multiply all the vertices.
 * @return {@module:twgl.BufferInfo} The created plane BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createPlaneBufferInfo
 */

/**
 * Creates XZ plane buffers.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {Matrix4} [matrix] A matrix by which to multiply all the vertices.
 * @return {Object.<string, WebGLBuffer>} The created plane buffers.
 * @memberOf module:twgl/primitives
 * @function createPlaneBuffers
 */

/**
 * Creates XZ plane vertices.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {Matrix4} [matrix] A matrix by which to multiply all the vertices.
 * @return {Object.<string, TypedArray>} The created plane vertices.
 * @memberOf module:twgl/primitives
 */


function createPlaneVertices(width, depth, subdivisionsWidth, subdivisionsDepth, matrix) {
  width = width || 1;
  depth = depth || 1;
  subdivisionsWidth = subdivisionsWidth || 1;
  subdivisionsDepth = subdivisionsDepth || 1;
  matrix = matrix || m4.identity();
  var numVertices = (subdivisionsWidth + 1) * (subdivisionsDepth + 1);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);

  for (var z = 0; z <= subdivisionsDepth; z++) {
    for (var x = 0; x <= subdivisionsWidth; x++) {
      var u = x / subdivisionsWidth;
      var v = z / subdivisionsDepth;
      positions.push(width * u - width * 0.5, 0, depth * v - depth * 0.5);
      normals.push(0, 1, 0);
      texcoords.push(u, v);
    }
  }

  var numVertsAcross = subdivisionsWidth + 1;
  var indices = createAugmentedTypedArray(3, subdivisionsWidth * subdivisionsDepth * 2, Uint16Array);

  for (var _z = 0; _z < subdivisionsDepth; _z++) {
    // eslint-disable-line
    for (var _x = 0; _x < subdivisionsWidth; _x++) {
      // eslint-disable-line
      // Make triangle 1 of quad.
      indices.push((_z + 0) * numVertsAcross + _x, (_z + 1) * numVertsAcross + _x, (_z + 0) * numVertsAcross + _x + 1); // Make triangle 2 of quad.

      indices.push((_z + 1) * numVertsAcross + _x, (_z + 1) * numVertsAcross + _x + 1, (_z + 0) * numVertsAcross + _x + 1);
    }
  }

  var arrays = reorientVertices({
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  }, matrix);
  return arrays;
}
/**
 * Creates sphere BufferInfo.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {module:twgl.BufferInfo} The created sphere BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createSphereBufferInfo
 */

/**
 * Creates sphere buffers.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {Object.<string, WebGLBuffer>} The created sphere buffers.
 * @memberOf module:twgl/primitives
 * @function createSphereBuffers
 */

/**
 * Creates sphere vertices.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {Object.<string, TypedArray>} The created sphere vertices.
 * @memberOf module:twgl/primitives
 */


function createSphereVertices(radius, subdivisionsAxis, subdivisionsHeight, opt_startLatitudeInRadians, opt_endLatitudeInRadians, opt_startLongitudeInRadians, opt_endLongitudeInRadians) {
  if (subdivisionsAxis <= 0 || subdivisionsHeight <= 0) {
    throw Error('subdivisionAxis and subdivisionHeight must be > 0');
  }

  opt_startLatitudeInRadians = opt_startLatitudeInRadians || 0;
  opt_endLatitudeInRadians = opt_endLatitudeInRadians || Math.PI;
  opt_startLongitudeInRadians = opt_startLongitudeInRadians || 0;
  opt_endLongitudeInRadians = opt_endLongitudeInRadians || Math.PI * 2;
  var latRange = opt_endLatitudeInRadians - opt_startLatitudeInRadians;
  var longRange = opt_endLongitudeInRadians - opt_startLongitudeInRadians; // We are going to generate our sphere by iterating through its
  // spherical coordinates and generating 2 triangles for each quad on a
  // ring of the sphere.

  var numVertices = (subdivisionsAxis + 1) * (subdivisionsHeight + 1);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices); // Generate the individual vertices in our vertex buffer.

  for (var y = 0; y <= subdivisionsHeight; y++) {
    for (var x = 0; x <= subdivisionsAxis; x++) {
      // Generate a vertex based on its spherical coordinates
      var u = x / subdivisionsAxis;
      var v = y / subdivisionsHeight;
      var theta = longRange * u;
      var phi = latRange * v;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var sinPhi = Math.sin(phi);
      var cosPhi = Math.cos(phi);
      var ux = cosTheta * sinPhi;
      var uy = cosPhi;
      var uz = sinTheta * sinPhi;
      positions.push(radius * ux, radius * uy, radius * uz);
      normals.push(ux, uy, uz);
      texcoords.push(1 - u, v);
    }
  }

  var numVertsAround = subdivisionsAxis + 1;
  var indices = createAugmentedTypedArray(3, subdivisionsAxis * subdivisionsHeight * 2, Uint16Array);

  for (var _x2 = 0; _x2 < subdivisionsAxis; _x2++) {
    // eslint-disable-line
    for (var _y = 0; _y < subdivisionsHeight; _y++) {
      // eslint-disable-line
      // Make triangle 1 of quad.
      indices.push((_y + 0) * numVertsAround + _x2, (_y + 0) * numVertsAround + _x2 + 1, (_y + 1) * numVertsAround + _x2); // Make triangle 2 of quad.

      indices.push((_y + 1) * numVertsAround + _x2, (_y + 0) * numVertsAround + _x2 + 1, (_y + 1) * numVertsAround + _x2 + 1);
    }
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Array of the indices of corners of each face of a cube.
 * @type {Array.<number[]>}
 */


var CUBE_FACE_INDICES = [[3, 7, 5, 1], // right
[6, 2, 0, 4], // left
[6, 7, 3, 2], // ??
[0, 1, 5, 4], // ??
[7, 6, 4, 5], // front
[2, 3, 1, 0]];
/**
 * Creates a BufferInfo for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] width, height and depth of the cube.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCubeBufferInfo
 */

/**
 * Creates the buffers and indices for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] width, height and depth of the cube.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCubeBuffers
 */

/**
 * Creates the vertices and indices for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {number} [size] width, height and depth of the cube.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */

function createCubeVertices(size) {
  size = size || 1;
  var k = size / 2;
  var cornerVertices = [[-k, -k, -k], [+k, -k, -k], [-k, +k, -k], [+k, +k, -k], [-k, -k, +k], [+k, -k, +k], [-k, +k, +k], [+k, +k, +k]];
  var faceNormals = [[+1, +0, +0], [-1, +0, +0], [+0, +1, +0], [+0, -1, +0], [+0, +0, +1], [+0, +0, -1]];
  var uvCoords = [[1, 0], [0, 0], [0, 1], [1, 1]];
  var numVertices = 6 * 4;
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);
  var indices = createAugmentedTypedArray(3, 6 * 2, Uint16Array);

  for (var f = 0; f < 6; ++f) {
    var faceIndices = CUBE_FACE_INDICES[f];

    for (var v = 0; v < 4; ++v) {
      var position = cornerVertices[faceIndices[v]];
      var normal = faceNormals[f];
      var uv = uvCoords[v]; // Each face needs all four vertices because the normals and texture
      // coordinates are not all the same.

      positions.push(position);
      normals.push(normal);
      texcoords.push(uv);
    } // Two triangles make a square face.


    var offset = 4 * f;
    indices.push(offset + 0, offset + 1, offset + 2);
    indices.push(offset + 0, offset + 2, offset + 3);
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Creates a BufferInfo for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {module:twgl.BufferInfo} The created cone BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createTruncatedConeBufferInfo
 */

/**
 * Creates buffers for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, WebGLBuffer>} The created cone buffers.
 * @memberOf module:twgl/primitives
 * @function createTruncatedConeBuffers
 */

/**
 * Creates vertices for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis. .
 *
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, TypedArray>} The created cone vertices.
 * @memberOf module:twgl/primitives
 */


function createTruncatedConeVertices(bottomRadius, topRadius, height, radialSubdivisions, verticalSubdivisions, opt_topCap, opt_bottomCap) {
  if (radialSubdivisions < 3) {
    throw Error('radialSubdivisions must be 3 or greater');
  }

  if (verticalSubdivisions < 1) {
    throw Error('verticalSubdivisions must be 1 or greater');
  }

  var topCap = opt_topCap === undefined ? true : opt_topCap;
  var bottomCap = opt_bottomCap === undefined ? true : opt_bottomCap;
  var extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  var numVertices = (radialSubdivisions + 1) * (verticalSubdivisions + 1 + extra);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);
  var indices = createAugmentedTypedArray(3, radialSubdivisions * (verticalSubdivisions + extra) * 2, Uint16Array);
  var vertsAroundEdge = radialSubdivisions + 1; // The slant of the cone is constant across its surface

  var slant = Math.atan2(bottomRadius - topRadius, height);
  var cosSlant = Math.cos(slant);
  var sinSlant = Math.sin(slant);
  var start = topCap ? -2 : 0;
  var end = verticalSubdivisions + (bottomCap ? 2 : 0);

  for (var yy = start; yy <= end; ++yy) {
    var v = yy / verticalSubdivisions;
    var y = height * v;
    var ringRadius = void 0;

    if (yy < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (yy > verticalSubdivisions) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (yy / verticalSubdivisions);
    }

    if (yy === -2 || yy === verticalSubdivisions + 2) {
      ringRadius = 0;
      v = 0;
    }

    y -= height / 2;

    for (var ii = 0; ii < vertsAroundEdge; ++ii) {
      var sin = Math.sin(ii * Math.PI * 2 / radialSubdivisions);
      var cos = Math.cos(ii * Math.PI * 2 / radialSubdivisions);
      positions.push(sin * ringRadius, y, cos * ringRadius);
      normals.push(yy < 0 || yy > verticalSubdivisions ? 0 : sin * cosSlant, yy < 0 ? -1 : yy > verticalSubdivisions ? 1 : sinSlant, yy < 0 || yy > verticalSubdivisions ? 0 : cos * cosSlant);
      texcoords.push(ii / radialSubdivisions, 1 - v);
    }
  }

  for (var _yy = 0; _yy < verticalSubdivisions + extra; ++_yy) {
    // eslint-disable-line
    for (var _ii = 0; _ii < radialSubdivisions; ++_ii) {
      // eslint-disable-line
      indices.push(vertsAroundEdge * (_yy + 0) + 0 + _ii, vertsAroundEdge * (_yy + 0) + 1 + _ii, vertsAroundEdge * (_yy + 1) + 1 + _ii);
      indices.push(vertsAroundEdge * (_yy + 0) + 0 + _ii, vertsAroundEdge * (_yy + 1) + 1 + _ii, vertsAroundEdge * (_yy + 1) + 0 + _ii);
    }
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Expands RLE data
 * @param {number[]} rleData data in format of run-length, x, y, z, run-length, x, y, z
 * @param {number[]} [padding] value to add each entry with.
 * @return {number[]} the expanded rleData
 */


function expandRLEData(rleData, padding) {
  padding = padding || [];
  var data = [];

  for (var ii = 0; ii < rleData.length; ii += 4) {
    var runLength = rleData[ii];
    var element = rleData.slice(ii + 1, ii + 4);
    element.push.apply(element, padding);

    for (var jj = 0; jj < runLength; ++jj) {
      data.push.apply(data, element);
    }
  }

  return data;
}
/**
 * Creates 3D 'F' BufferInfo.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function create3DFBufferInfo
 */

/**
 * Creates 3D 'F' buffers.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function create3DFBuffers
 */

/**
 * Creates 3D 'F' vertices.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color arrays.
 *
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function create3DFVertices() {
  var positions = [// left column front
  0, 0, 0, 0, 150, 0, 30, 0, 0, 0, 150, 0, 30, 150, 0, 30, 0, 0, // top rung front
  30, 0, 0, 30, 30, 0, 100, 0, 0, 30, 30, 0, 100, 30, 0, 100, 0, 0, // middle rung front
  30, 60, 0, 30, 90, 0, 67, 60, 0, 30, 90, 0, 67, 90, 0, 67, 60, 0, // left column back
  0, 0, 30, 30, 0, 30, 0, 150, 30, 0, 150, 30, 30, 0, 30, 30, 150, 30, // top rung back
  30, 0, 30, 100, 0, 30, 30, 30, 30, 30, 30, 30, 100, 0, 30, 100, 30, 30, // middle rung back
  30, 60, 30, 67, 60, 30, 30, 90, 30, 30, 90, 30, 67, 60, 30, 67, 90, 30, // top
  0, 0, 0, 100, 0, 0, 100, 0, 30, 0, 0, 0, 100, 0, 30, 0, 0, 30, // top rung front
  100, 0, 0, 100, 30, 0, 100, 30, 30, 100, 0, 0, 100, 30, 30, 100, 0, 30, // under top rung
  30, 30, 0, 30, 30, 30, 100, 30, 30, 30, 30, 0, 100, 30, 30, 100, 30, 0, // between top rung and middle
  30, 30, 0, 30, 60, 30, 30, 30, 30, 30, 30, 0, 30, 60, 0, 30, 60, 30, // top of middle rung
  30, 60, 0, 67, 60, 30, 30, 60, 30, 30, 60, 0, 67, 60, 0, 67, 60, 30, // front of middle rung
  67, 60, 0, 67, 90, 30, 67, 60, 30, 67, 60, 0, 67, 90, 0, 67, 90, 30, // bottom of middle rung.
  30, 90, 0, 30, 90, 30, 67, 90, 30, 30, 90, 0, 67, 90, 30, 67, 90, 0, // front of bottom
  30, 90, 0, 30, 150, 30, 30, 90, 30, 30, 90, 0, 30, 150, 0, 30, 150, 30, // bottom
  0, 150, 0, 0, 150, 30, 30, 150, 30, 0, 150, 0, 30, 150, 30, 30, 150, 0, // left side
  0, 0, 0, 0, 0, 30, 0, 150, 30, 0, 0, 0, 0, 150, 30, 0, 150, 0];
  var texcoords = [// left column front
  0.22, 0.19, 0.22, 0.79, 0.34, 0.19, 0.22, 0.79, 0.34, 0.79, 0.34, 0.19, // top rung front
  0.34, 0.19, 0.34, 0.31, 0.62, 0.19, 0.34, 0.31, 0.62, 0.31, 0.62, 0.19, // middle rung front
  0.34, 0.43, 0.34, 0.55, 0.49, 0.43, 0.34, 0.55, 0.49, 0.55, 0.49, 0.43, // left column back
  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, // top rung back
  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, // middle rung back
  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, // top
  0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, // top rung front
  0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, // under top rung
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, // between top rung and middle
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, // top of middle rung
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, // front of middle rung
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, // bottom of middle rung.
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, // front of bottom
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, // bottom
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, // left side
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0];
  var normals = expandRLEData([// left column front
  // top rung front
  // middle rung front
  18, 0, 0, 1, // left column back
  // top rung back
  // middle rung back
  18, 0, 0, -1, // top
  6, 0, 1, 0, // top rung front
  6, 1, 0, 0, // under top rung
  6, 0, -1, 0, // between top rung and middle
  6, 1, 0, 0, // top of middle rung
  6, 0, 1, 0, // front of middle rung
  6, 1, 0, 0, // bottom of middle rung.
  6, 0, -1, 0, // front of bottom
  6, 1, 0, 0, // bottom
  6, 0, -1, 0, // left side
  6, -1, 0, 0]);
  var colors = expandRLEData([// left column front
  // top rung front
  // middle rung front
  18, 200, 70, 120, // left column back
  // top rung back
  // middle rung back
  18, 80, 70, 200, // top
  6, 70, 200, 210, // top rung front
  6, 200, 200, 70, // under top rung
  6, 210, 100, 70, // between top rung and middle
  6, 210, 160, 70, // top of middle rung
  6, 70, 180, 210, // front of middle rung
  6, 100, 70, 210, // bottom of middle rung.
  6, 76, 210, 100, // front of bottom
  6, 140, 210, 80, // bottom
  6, 90, 130, 110, // left side
  6, 160, 160, 220], [255]);
  var numVerts = positions.length / 3;
  var arrays = {
    position: createAugmentedTypedArray(3, numVerts),
    texcoord: createAugmentedTypedArray(2, numVerts),
    normal: createAugmentedTypedArray(3, numVerts),
    color: createAugmentedTypedArray(4, numVerts, Uint8Array),
    indices: createAugmentedTypedArray(3, numVerts / 3, Uint16Array)
  };
  arrays.position.push(positions);
  arrays.texcoord.push(texcoords);
  arrays.normal.push(normals);
  arrays.color.push(colors);

  for (var ii = 0; ii < numVerts; ++ii) {
    arrays.indices.push(ii);
  }

  return arrays;
}
/**
 * Creates cresent BufferInfo.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the cresent.
 * @param {number} outerRadius The outer radius of the cresent.
 * @param {number} innerRadius The inner radius of the cresent.
 * @param {number} thickness The thickness of the cresent.
 * @param {number} subdivisionsDown number of steps around the cresent.
 * @param {number} subdivisionsThick number of vertically on the cresent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCresentBufferInfo
 */

/**
 * Creates cresent buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the cresent.
 * @param {number} outerRadius The outer radius of the cresent.
 * @param {number} innerRadius The inner radius of the cresent.
 * @param {number} thickness The thickness of the cresent.
 * @param {number} subdivisionsDown number of steps around the cresent.
 * @param {number} subdivisionsThick number of vertically on the cresent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCresentBuffers
 */

/**
 * Creates cresent vertices.
 *
 * @param {number} verticalRadius The vertical radius of the cresent.
 * @param {number} outerRadius The outer radius of the cresent.
 * @param {number} innerRadius The inner radius of the cresent.
 * @param {number} thickness The thickness of the cresent.
 * @param {number} subdivisionsDown number of steps around the cresent.
 * @param {number} subdivisionsThick number of vertically on the cresent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function createCresentVertices(verticalRadius, outerRadius, innerRadius, thickness, subdivisionsDown, startOffset, endOffset) {
  if (subdivisionsDown <= 0) {
    throw Error('subdivisionDown must be > 0');
  }

  startOffset = startOffset || 0;
  endOffset = endOffset || 1;
  var subdivisionsThick = 2;
  var offsetRange = endOffset - startOffset;
  var numVertices = (subdivisionsDown + 1) * 2 * (2 + subdivisionsThick);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);

  function lerp(a, b, s) {
    return a + (b - a) * s;
  }

  function createArc(arcRadius, x, normalMult, normalAdd, uMult, uAdd) {
    for (var z = 0; z <= subdivisionsDown; z++) {
      var uBack = x / (subdivisionsThick - 1);
      var v = z / subdivisionsDown;
      var xBack = (uBack - 0.5) * 2;
      var angle = (startOffset + v * offsetRange) * Math.PI;
      var s = Math.sin(angle);
      var c = Math.cos(angle);
      var radius = lerp(verticalRadius, arcRadius, s);
      var px = xBack * thickness;
      var py = c * verticalRadius;
      var pz = s * radius;
      positions.push(px, py, pz);
      var n = v3.add(v3.multiply([0, s, c], normalMult), normalAdd);
      normals.push(n);
      texcoords.push(uBack * uMult + uAdd, v);
    }
  } // Generate the individual vertices in our vertex buffer.


  for (var x = 0; x < subdivisionsThick; x++) {
    var uBack = (x / (subdivisionsThick - 1) - 0.5) * 2;
    createArc(outerRadius, x, [1, 1, 1], [0, 0, 0], 1, 0);
    createArc(outerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 0);
    createArc(innerRadius, x, [1, 1, 1], [0, 0, 0], 1, 0);
    createArc(innerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 1);
  } // Do outer surface.


  var indices = createAugmentedTypedArray(3, subdivisionsDown * 2 * (2 + subdivisionsThick), Uint16Array);

  function createSurface(leftArcOffset, rightArcOffset) {
    for (var z = 0; z < subdivisionsDown; ++z) {
      // Make triangle 1 of quad.
      indices.push(leftArcOffset + z + 0, leftArcOffset + z + 1, rightArcOffset + z + 0); // Make triangle 2 of quad.

      indices.push(leftArcOffset + z + 1, rightArcOffset + z + 1, rightArcOffset + z + 0);
    }
  }

  var numVerticesDown = subdivisionsDown + 1; // front

  createSurface(numVerticesDown * 0, numVerticesDown * 4); // right

  createSurface(numVerticesDown * 5, numVerticesDown * 7); // back

  createSurface(numVerticesDown * 6, numVerticesDown * 2); // left

  createSurface(numVerticesDown * 3, numVerticesDown * 1);
  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Creates cylinder BufferInfo. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCylinderBufferInfo
 */

/**
 * Creates cylinder buffers. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCylinderBuffers
 */

/**
 * Creates cylinder vertices. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function createCylinderVertices(radius, height, radialSubdivisions, verticalSubdivisions, topCap, bottomCap) {
  return createTruncatedConeVertices(radius, radius, height, radialSubdivisions, verticalSubdivisions, topCap, bottomCap);
}
/**
 * Creates BufferInfo for a torus
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createTorusBufferInfo
 */

/**
 * Creates buffers for a torus
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createTorusBuffers
 */

/**
 * Creates vertices for a torus
 *
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function createTorusVertices(radius, thickness, radialSubdivisions, bodySubdivisions, startAngle, endAngle) {
  if (radialSubdivisions < 3) {
    throw Error('radialSubdivisions must be 3 or greater');
  }

  if (bodySubdivisions < 3) {
    throw Error('verticalSubdivisions must be 3 or greater');
  }

  startAngle = startAngle || 0;
  endAngle = endAngle || Math.PI * 2;
  var range = endAngle - startAngle;
  var radialParts = radialSubdivisions + 1;
  var bodyParts = bodySubdivisions + 1;
  var numVertices = radialParts * bodyParts;
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);
  var indices = createAugmentedTypedArray(3, radialSubdivisions * bodySubdivisions * 2, Uint16Array);

  for (var slice = 0; slice < bodyParts; ++slice) {
    var v = slice / bodySubdivisions;
    var sliceAngle = v * Math.PI * 2;
    var sliceSin = Math.sin(sliceAngle);
    var ringRadius = radius + sliceSin * thickness;
    var ny = Math.cos(sliceAngle);
    var y = ny * thickness;

    for (var ring = 0; ring < radialParts; ++ring) {
      var u = ring / radialSubdivisions;
      var ringAngle = startAngle + u * range;
      var xSin = Math.sin(ringAngle);
      var zCos = Math.cos(ringAngle);
      var x = xSin * ringRadius;
      var z = zCos * ringRadius;
      var nx = xSin * sliceSin;
      var nz = zCos * sliceSin;
      positions.push(x, y, z);
      normals.push(nx, ny, nz);
      texcoords.push(u, 1 - v);
    }
  }

  for (var _slice = 0; _slice < bodySubdivisions; ++_slice) {
    // eslint-disable-line
    for (var _ring = 0; _ring < radialSubdivisions; ++_ring) {
      // eslint-disable-line
      var nextRingIndex = 1 + _ring;
      var nextSliceIndex = 1 + _slice;
      indices.push(radialParts * _slice + _ring, radialParts * nextSliceIndex + _ring, radialParts * _slice + nextRingIndex);
      indices.push(radialParts * nextSliceIndex + _ring, radialParts * nextSliceIndex + nextRingIndex, radialParts * _slice + nextRingIndex);
    }
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * Creates a disc BufferInfo. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose ouside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createDiscBufferInfo
 */

/**
 * Creates disc buffers. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose ouside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createDiscBuffers
 */

/**
 * Creates disc vertices. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose ouside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */


function createDiscVertices(radius, divisions, stacks, innerRadius, stackPower) {
  if (divisions < 3) {
    throw Error('divisions must be at least 3');
  }

  stacks = stacks ? stacks : 1;
  stackPower = stackPower ? stackPower : 1;
  innerRadius = innerRadius ? innerRadius : 0; // Note: We don't share the center vertex because that would
  // mess up texture coordinates.

  var numVertices = (divisions + 1) * (stacks + 1);
  var positions = createAugmentedTypedArray(3, numVertices);
  var normals = createAugmentedTypedArray(3, numVertices);
  var texcoords = createAugmentedTypedArray(2, numVertices);
  var indices = createAugmentedTypedArray(3, stacks * divisions * 2, Uint16Array);
  var firstIndex = 0;
  var radiusSpan = radius - innerRadius;
  var pointsPerStack = divisions + 1; // Build the disk one stack at a time.

  for (var stack = 0; stack <= stacks; ++stack) {
    var stackRadius = innerRadius + radiusSpan * Math.pow(stack / stacks, stackPower);

    for (var i = 0; i <= divisions; ++i) {
      var theta = 2.0 * Math.PI * i / divisions;
      var x = stackRadius * Math.cos(theta);
      var z = stackRadius * Math.sin(theta);
      positions.push(x, 0, z);
      normals.push(0, 1, 0);
      texcoords.push(1 - i / divisions, stack / stacks);

      if (stack > 0 && i !== divisions) {
        // a, b, c and d are the indices of the vertices of a quad.  unless
        // the current stack is the one closest to the center, in which case
        // the vertices a and b connect to the center vertex.
        var a = firstIndex + (i + 1);
        var b = firstIndex + i;
        var c = firstIndex + i - pointsPerStack;
        var d = firstIndex + (i + 1) - pointsPerStack; // Make a quad of the vertices a, b, c, d.

        indices.push(a, b, c);
        indices.push(a, c, d);
      }
    }

    firstIndex += divisions + 1;
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}
/**
 * creates a random integer between 0 and range - 1 inclusive.
 * @param {number} range
 * @return {number} random value between 0 and range - 1 inclusive.
 */


function randInt(range) {
  return Math.random() * range | 0;
}
/**
 * Used to supply random colors
 * @callback RandomColorFunc
 * @param {number} ndx index of triangle/quad if unindexed or index of vertex if indexed
 * @param {number} channel 0 = red, 1 = green, 2 = blue, 3 = alpha
 * @return {number} a number from 0 to 255
 * @memberOf module:twgl/primitives
 */

/**
 * @typedef {Object} RandomVerticesOptions
 * @property {number} [vertsPerColor] Defaults to 3 for non-indexed vertices
 * @property {module:twgl/primitives.RandomColorFunc} [rand] A function to generate random numbers
 * @memberOf module:twgl/primitives
 */

/**
 * Creates an augmentedTypedArray of random vertex colors.
 * If the vertices are indexed (have an indices array) then will
 * just make random colors. Otherwise assumes they are triangles
 * and makes one random color for every 3 vertices.
 * @param {Object.<string, augmentedTypedArray>} vertices Vertices as returned from one of the createXXXVertices functions.
 * @param {module:twgl/primitives.RandomVerticesOptions} [options] options.
 * @return {Object.<string, augmentedTypedArray>} same vertices as passed in with `color` added.
 * @memberOf module:twgl/primitives
 */


function makeRandomVertexColors(vertices, options) {
  options = options || {};
  var numElements = vertices.position.numElements;
  var vcolors = createAugmentedTypedArray(4, numElements, Uint8Array);

  var rand = options.rand || function (ndx, channel) {
    return channel < 3 ? randInt(256) : 255;
  };

  vertices.color = vcolors;

  if (vertices.indices) {
    // just make random colors if index
    for (var ii = 0; ii < numElements; ++ii) {
      vcolors.push(rand(ii, 0), rand(ii, 1), rand(ii, 2), rand(ii, 3));
    }
  } else {
    // make random colors per triangle
    var numVertsPerColor = options.vertsPerColor || 3;
    var numSets = numElements / numVertsPerColor;

    for (var _ii2 = 0; _ii2 < numSets; ++_ii2) {
      // eslint-disable-line
      var color = [rand(_ii2, 0), rand(_ii2, 1), rand(_ii2, 2), rand(_ii2, 3)];

      for (var jj = 0; jj < numVertsPerColor; ++jj) {
        vcolors.push(color);
      }
    }
  }

  return vertices;
}
/**
 * creates a function that calls fn to create vertices and then
 * creates a buffers for them
 */


function createBufferFunc(fn) {
  return function (gl) {
    var arrays = fn.apply(this, Array.prototype.slice.call(arguments, 1));
    return attributes.createBuffersFromArrays(gl, arrays);
  };
}
/**
 * creates a function that calls fn to create vertices and then
 * creates a bufferInfo object for them
 */


function createBufferInfoFunc(fn) {
  return function (gl) {
    var arrays = fn.apply(null, Array.prototype.slice.call(arguments, 1));
    return attributes.createBufferInfoFromArrays(gl, arrays);
  };
}

var arraySpecPropertyNames = ["numComponents", "size", "type", "normalize", "stride", "offset", "attrib", "name", "attribName"];
/**
 * Copy elements from one array to another
 *
 * @param {Array|TypedArray} src source array
 * @param {Array|TypedArray} dst dest array
 * @param {number} dstNdx index in dest to copy src
 * @param {number} [offset] offset to add to copied values
 */

function copyElements(src, dst, dstNdx, offset) {
  offset = offset || 0;
  var length = src.length;

  for (var ii = 0; ii < length; ++ii) {
    dst[dstNdx + ii] = src[ii] + offset;
  }
}
/**
 * Creates an array of the same time
 *
 * @param {(number[]|ArrayBufferView|module:twgl.FullArraySpec)} srcArray array who's type to copy
 * @param {number} length size of new array
 * @return {(number[]|ArrayBufferView|module:twgl.FullArraySpec)} array with same type as srcArray
 */


function createArrayOfSameType(srcArray, length) {
  var arraySrc = getArray(srcArray);
  var newArray = new arraySrc.constructor(length);
  var newArraySpec = newArray; // If it appears to have been augmented make new one augemented

  if (arraySrc.numComponents && arraySrc.numElements) {
    augmentTypedArray(newArray, arraySrc.numComponents);
  } // If it was a fullspec make new one a fullspec


  if (srcArray.data) {
    newArraySpec = {
      data: newArray
    };
    helper.copyNamedProperties(arraySpecPropertyNames, srcArray, newArraySpec);
  }

  return newArraySpec;
}
/**
 * Concatinates sets of vertices
 *
 * Assumes the vertices match in composition. For example
 * if one set of vertices has positions, normals, and indices
 * all sets of vertices must have positions, normals, and indices
 * and of the same type.
 *
 * Example:
 *
 *      const cubeVertices = twgl.primtiives.createCubeVertices(2);
 *      const sphereVertices = twgl.primitives.createSphereVertices(1, 10, 10);
 *      // move the sphere 2 units up
 *      twgl.primitives.reorientVertices(
 *          sphereVertices, twgl.m4.translation([0, 2, 0]));
 *      // merge the sphere with the cube
 *      const cubeSphereVertices = twgl.primitives.concatVertices(
 *          [cubeVertices, sphereVertices]);
 *      // turn them into WebGL buffers and attrib data
 *      const bufferInfo = twgl.createBufferInfoFromArrays(gl, cubeSphereVertices);
 *
 * @param {module:twgl.Arrays[]} arrays Array of arrays of vertices
 * @return {module:twgl.Arrays} The concatinated vertices.
 * @memberOf module:twgl/primitives
 */


function concatVertices(arrayOfArrays) {
  var names = {};
  var baseName; // get names of all arrays.
  // and numElements for each set of vertices

  var _loop = function _loop(ii) {
    var arrays = arrayOfArrays[ii];
    Object.keys(arrays).forEach(function (name) {
      // eslint-disable-line
      if (!names[name]) {
        names[name] = [];
      }

      if (!baseName && name !== 'indices') {
        baseName = name;
      }

      var arrayInfo = arrays[name];
      var numComponents = getNumComponents(arrayInfo, name);
      var array = getArray(arrayInfo);
      var numElements = array.length / numComponents;
      names[name].push(numElements);
    });
  };

  for (var ii = 0; ii < arrayOfArrays.length; ++ii) {
    _loop(ii);
  } // compute length of combined array
  // and return one for reference


  function getLengthOfCombinedArrays(name) {
    var length = 0;
    var arraySpec;

    for (var ii = 0; ii < arrayOfArrays.length; ++ii) {
      var arrays = arrayOfArrays[ii];
      var arrayInfo = arrays[name];
      var array = getArray(arrayInfo);
      length += array.length;

      if (!arraySpec || arrayInfo.data) {
        arraySpec = arrayInfo;
      }
    }

    return {
      length: length,
      spec: arraySpec
    };
  }

  function copyArraysToNewArray(name, base, newArray) {
    var baseIndex = 0;
    var offset = 0;

    for (var ii = 0; ii < arrayOfArrays.length; ++ii) {
      var arrays = arrayOfArrays[ii];
      var arrayInfo = arrays[name];
      var array = getArray(arrayInfo);

      if (name === 'indices') {
        copyElements(array, newArray, offset, baseIndex);
        baseIndex += base[ii];
      } else {
        copyElements(array, newArray, offset);
      }

      offset += array.length;
    }
  }

  var base = names[baseName];
  var newArrays = {};
  Object.keys(names).forEach(function (name) {
    var info = getLengthOfCombinedArrays(name);
    var newArraySpec = createArrayOfSameType(info.spec, info.length);
    copyArraysToNewArray(name, base, getArray(newArraySpec));
    newArrays[name] = newArraySpec;
  });
  return newArrays;
}
/**
 * Creates a duplicate set of vertices
 *
 * This is useful for calling reorientVertices when you
 * also want to keep the original available
 *
 * @param {module:twgl.Arrays} arrays of vertices
 * @return {module:twgl.Arrays} The dupilicated vertices.
 * @memberOf module:twgl/primitives
 */


function duplicateVertices(arrays) {
  var newArrays = {};
  Object.keys(arrays).forEach(function (name) {
    var arraySpec = arrays[name];
    var srcArray = getArray(arraySpec);
    var newArraySpec = createArrayOfSameType(arraySpec, srcArray.length);
    copyElements(srcArray, getArray(newArraySpec), 0);
    newArrays[name] = newArraySpec;
  });
  return newArrays;
}

var create3DFBufferInfo = createBufferInfoFunc(create3DFVertices);
exports.create3DFBufferInfo = create3DFBufferInfo;
var create3DFBuffers = createBufferFunc(create3DFVertices);
exports.create3DFBuffers = create3DFBuffers;
var createCubeBufferInfo = createBufferInfoFunc(createCubeVertices);
exports.createCubeBufferInfo = createCubeBufferInfo;
var createCubeBuffers = createBufferFunc(createCubeVertices);
exports.createCubeBuffers = createCubeBuffers;
var createPlaneBufferInfo = createBufferInfoFunc(createPlaneVertices);
exports.createPlaneBufferInfo = createPlaneBufferInfo;
var createPlaneBuffers = createBufferFunc(createPlaneVertices);
exports.createPlaneBuffers = createPlaneBuffers;
var createSphereBufferInfo = createBufferInfoFunc(createSphereVertices);
exports.createSphereBufferInfo = createSphereBufferInfo;
var createSphereBuffers = createBufferFunc(createSphereVertices);
exports.createSphereBuffers = createSphereBuffers;
var createTruncatedConeBufferInfo = createBufferInfoFunc(createTruncatedConeVertices);
exports.createTruncatedConeBufferInfo = createTruncatedConeBufferInfo;
var createTruncatedConeBuffers = createBufferFunc(createTruncatedConeVertices);
exports.createTruncatedConeBuffers = createTruncatedConeBuffers;
var createXYQuadBufferInfo = createBufferInfoFunc(createXYQuadVertices);
exports.createXYQuadBufferInfo = createXYQuadBufferInfo;
var createXYQuadBuffers = createBufferFunc(createXYQuadVertices);
exports.createXYQuadBuffers = createXYQuadBuffers;
var createCresentBufferInfo = createBufferInfoFunc(createCresentVertices);
exports.createCresentBufferInfo = createCresentBufferInfo;
var createCresentBuffers = createBufferFunc(createCresentVertices);
exports.createCresentBuffers = createCresentBuffers;
var createCylinderBufferInfo = createBufferInfoFunc(createCylinderVertices);
exports.createCylinderBufferInfo = createCylinderBufferInfo;
var createCylinderBuffers = createBufferFunc(createCylinderVertices);
exports.createCylinderBuffers = createCylinderBuffers;
var createTorusBufferInfo = createBufferInfoFunc(createTorusVertices);
exports.createTorusBufferInfo = createTorusBufferInfo;
var createTorusBuffers = createBufferFunc(createTorusVertices);
exports.createTorusBuffers = createTorusBuffers;
var createDiscBufferInfo = createBufferInfoFunc(createDiscVertices);
exports.createDiscBufferInfo = createDiscBufferInfo;
var createDiscBuffers = createBufferFunc(createDiscVertices);
exports.createDiscBuffers = createDiscBuffers;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var _exportNames = {
  addExtensionsToContext: true,
  getContext: true,
  getWebGLContext: true,
  resizeCanvasToDisplaySize: true,
  setDefaults: true
};
exports.addExtensionsToContext = addExtensionsToContext;
exports.getContext = getContext;
exports.getWebGLContext = getWebGLContext;
exports.resizeCanvasToDisplaySize = resizeCanvasToDisplaySize;
exports.setDefaults = setDefaults;

var attributes = _interopRequireWildcard(__webpack_require__(7));

Object.keys(attributes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = attributes[key];
});

var textures = _interopRequireWildcard(__webpack_require__(8));

Object.keys(textures).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = textures[key];
});

var helper = _interopRequireWildcard(__webpack_require__(0));

var utils = _interopRequireWildcard(__webpack_require__(4));

Object.keys(utils).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = utils[key];
});

var _draw = __webpack_require__(12);

Object.keys(_draw).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _draw[key];
});

var _framebuffers = __webpack_require__(13);

Object.keys(_framebuffers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _framebuffers[key];
});

var _programs = __webpack_require__(5);

Object.keys(_programs).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _programs[key];
});

var _typedarrays = __webpack_require__(1);

Object.keys(_typedarrays).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _typedarrays[key];
});

var _vertexArrays = __webpack_require__(14);

Object.keys(_vertexArrays).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _vertexArrays[key];
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/*
 * Copyright 2015, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * The main TWGL module.
 *
 * For most use cases you shouldn't need anything outside this module.
 * Exceptions between the stuff added to twgl-full (v3, m4, primitives)
 *
 * @module twgl
 * @borrows module:twgl/attributes.setAttribInfoBufferFromArray as setAttribInfoBufferFromArray
 * @borrows module:twgl/attributes.createBufferInfoFromArrays as createBufferInfoFromArrays
 * @borrows module:twgl/attributes.createVertexArrayInfo as createVertexArrayInfo
 * @borrows module:twgl/draw.drawBufferInfo as drawBufferInfo
 * @borrows module:twgl/draw.drawObjectList as drawObjectList
 * @borrows module:twgl/framebuffers.createFramebufferInfo as createFramebufferInfo
 * @borrows module:twgl/framebuffers.resizeFramebufferInfo as resizeFramebufferInfo
 * @borrows module:twgl/framebuffers.bindFramebufferInfo as bindFramebufferInfo
 * @borrows module:twgl/programs.createProgramInfo as createProgramInfo
 * @borrows module:twgl/programs.createUniformBlockInfo as createUniformBlockInfo
 * @borrows module:twgl/programs.bindUniformBlock as bindUniformBlock
 * @borrows module:twgl/programs.setUniformBlock as setUniformBlock
 * @borrows module:twgl/programs.setBlockUniforms as setBlockUniforms
 * @borrows module:twgl/programs.setUniforms as setUniforms
 * @borrows module:twgl/programs.setBuffersAndAttributes as setBuffersAndAttributes
 * @borrows module:twgl/textures.setTextureFromArray as setTextureFromArray
 * @borrows module:twgl/textures.createTexture as createTexture
 * @borrows module:twgl/textures.resizeTexture as resizeTexture
 * @borrows module:twgl/textures.createTextures as createTextures
 */
// make sure we don't see a global gl
var gl = undefined; // eslint-disable-line

var defaults = {
  addExtensionsToContext: true
};
/**
 * Various default settings for twgl.
 *
 * Note: You can call this any number of times. Example:
 *
 *     twgl.setDefaults({ textureColor: [1, 0, 0, 1] });
 *     twgl.setDefaults({ attribPrefix: 'a_' });
 *
 * is equivalent to
 *
 *     twgl.setDefaults({
 *       textureColor: [1, 0, 0, 1],
 *       attribPrefix: 'a_',
 *     });
 *
 * @typedef {Object} Defaults
 * @property {string} attribPrefix The prefix to stick on attributes
 *
 *   When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`
 *   as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.
 *
 *   In otherwords I'll create arrays of geometry like this
 *
 *       const arrays = {
 *         position: ...
 *         normal: ...
 *         texcoord: ...
 *       };
 *
 *   But need those mapped to attributes and my attributes start with `a_`.
 *
 *   Default: `""`
 *
 * @property {number[]} textureColor Array of 4 values in the range 0 to 1
 *
 *   The default texture color is used when loading textures from
 *   urls. Because the URL will be loaded async we'd like to be
 *   able to use the texture immediately. By putting a 1x1 pixel
 *   color in the texture we can start using the texture before
 *   the URL has loaded.
 *
 *   Default: `[0.5, 0.75, 1, 1]`
 *
 * @property {string} crossOrigin
 *
 *   If not undefined sets the crossOrigin attribute on images
 *   that twgl creates when downloading images for textures.
 *
 *   Also see {@link module:twgl.TextureOptions}.
 *
 * @property {bool} addExtensionsToContext
 *
 *   If true, then, when twgl will try to add any supported WebGL extensions
 *   directly to the context under their normal GL names. For example
 *   if ANGLE_instances_arrays exists then twgl would enable it,
 *   add the functions `vertexAttribDivisor`, `drawArraysInstanced`,
 *   `drawElementsInstanced`, and the constant `VERTEX_ATTRIB_ARRAY_DIVISOR`
 *   to the `WebGLRenderingContext`.
 *
 * @memberOf module:twgl
 */

/**
 * Sets various defaults for twgl.
 *
 * In the interest of terseness which is kind of the point
 * of twgl I've integrated a few of the older functions here
 *
 * @param {module:twgl.Defaults} newDefaults The default settings.
 * @memberOf module:twgl
 */

function setDefaults(newDefaults) {
  helper.copyExistingProperties(newDefaults, defaults);
  attributes.setAttributeDefaults_(newDefaults); // eslint-disable-line

  textures.setTextureDefaults_(newDefaults); // eslint-disable-line
}

var prefixRE = /^(.*?)_/;

function addExtensionToContext(gl, extensionName) {
  utils.glEnumToString(gl, 0);
  var ext = gl.getExtension(extensionName);

  if (ext) {
    var enums = {};
    var fnSuffix = prefixRE.exec(extensionName)[1];
    var enumSuffix = '_' + fnSuffix;

    for (var key in ext) {
      var value = ext[key];
      var isFunc = typeof value === 'function';
      var suffix = isFunc ? fnSuffix : enumSuffix;
      var name = key; // examples of where this is not true are WEBGL_compressed_texture_s3tc
      // and WEBGL_compressed_texture_pvrtc

      if (key.endsWith(suffix)) {
        name = key.substring(0, key.length - suffix.length);
      }

      if (gl[name] !== undefined) {
        if (!isFunc && gl[name] !== value) {
          helper.warn(name, gl[name], value, key);
        }
      } else {
        if (isFunc) {
          gl[name] = function (origFn) {
            return function () {
              return origFn.apply(ext, arguments);
            };
          }(value);
        } else {
          gl[name] = value;
          enums[name] = value;
        }
      }
    } // pass the modified enums to glEnumToString


    enums.constructor = {
      name: ext.constructor.name
    };
    utils.glEnumToString(enums, 0);
  }

  return ext;
}
/*
 * If you're wondering why the code doesn't just iterate
 * over all extensions using `gl.getExtensions` is that it's possible
 * some future extension is incompatible with this code. Rather than
 * have thing suddenly break it seems better to manually add to this
 * list.
 *
 */


var supportedExtensions = ['ANGLE_instanced_arrays', 'EXT_blend_minmax', 'EXT_color_buffer_float', 'EXT_color_buffer_half_float', 'EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2', 'EXT_frag_depth', 'EXT_sRGB', 'EXT_shader_texture_lod', 'EXT_texture_filter_anisotropic', 'OES_element_index_uint', 'OES_standard_derivatives', 'OES_texture_float', 'OES_texture_float_linear', 'OES_texture_half_float', 'OES_texture_half_float_linear', 'OES_vertex_array_object', 'WEBGL_color_buffer_float', 'WEBGL_compressed_texture_atc', 'WEBGL_compressed_texture_etc1', 'WEBGL_compressed_texture_pvrtc', 'WEBGL_compressed_texture_s3tc', 'WEBGL_compressed_texture_s3tc_srgb', 'WEBGL_depth_texture', 'WEBGL_draw_buffers'];
/**
 * Attempts to enable all of the following extensions
 * and add their functions and constants to the
 * `WebGLRenderingContext` using their normal non-extension like names.
 *
 *      ANGLE_instanced_arrays
 *      EXT_blend_minmax
 *      EXT_color_buffer_float
 *      EXT_color_buffer_half_float
 *      EXT_disjoint_timer_query
 *      EXT_disjoint_timer_query_webgl2
 *      EXT_frag_depth
 *      EXT_sRGB
 *      EXT_shader_texture_lod
 *      EXT_texture_filter_anisotropic
 *      OES_element_index_uint
 *      OES_standard_derivatives
 *      OES_texture_float
 *      OES_texture_float_linear
 *      OES_texture_half_float
 *      OES_texture_half_float_linear
 *      OES_vertex_array_object
 *      WEBGL_color_buffer_float
 *      WEBGL_compressed_texture_atc
 *      WEBGL_compressed_texture_etc1
 *      WEBGL_compressed_texture_pvrtc
 *      WEBGL_compressed_texture_s3tc
 *      WEBGL_compressed_texture_s3tc_srgb
 *      WEBGL_depth_texture
 *      WEBGL_draw_buffers
 *
 * For example if `ANGLE_instanced_arrays` exists then the functions
 * `drawArraysInstanced`, `drawElementsInstanced`, `vertexAttribDivisor`
 * and the constant `VERTEX_ATTRIB_ARRAY_DIVISOR` are added to the
 * `WebGLRenderingContext`.
 *
 * Note that if you want to know if the extension exists you should
 * probably call `gl.getExtension` for each extension. Alternatively
 * you can check for the existance of the functions or constants that
 * are expected to be added. For example
 *
 *    if (gl.drawBuffers) {
 *      // Either WEBGL_draw_buffers was enabled OR you're running in WebGL2
 *      ....
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @memberOf module:twgl
 */

function addExtensionsToContext(gl) {
  for (var ii = 0; ii < supportedExtensions.length; ++ii) {
    addExtensionToContext(gl, supportedExtensions[ii]);
  }
}
/**
 * Creates a webgl context.
 * @param {HTMLCanvasElement} canvas The canvas tag to get
 *     context from. If one is not passed in one will be
 *     created.
 * @return {WebGLRenderingContext} The created context.
 */


function create3DContext(canvas, opt_attribs) {
  var names = ["webgl", "experimental-webgl"];
  var context = null;

  for (var ii = 0; ii < names.length; ++ii) {
    context = canvas.getContext(names[ii], opt_attribs);

    if (context) {
      if (defaults.addExtensionsToContext) {
        addExtensionsToContext(context);
      }

      break;
    }
  }

  return context;
}
/**
 * Gets a WebGL1 context.
 *
 * Note: Will attempt to enable Vertex Array Objects
 * and add WebGL2 entry points. (unless you first set defaults with
 * `twgl.setDefaults({enableVertexArrayObjects: false})`;
 *
 * @param {HTMLCanvasElement} canvas a canvas element.
 * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes
 * @memberOf module:twgl
 */


function getWebGLContext(canvas, opt_attribs) {
  var gl = create3DContext(canvas, opt_attribs);
  return gl;
}
/**
 * Creates a webgl context.
 *
 * Will return a WebGL2 context if possible.
 *
 * You can check if it's WebGL2 with
 *
 *     twgl.isWebGL2(gl);
 *
 * @param {HTMLCanvasElement} canvas The canvas tag to get
 *     context from. If one is not passed in one will be
 *     created.
 * @return {WebGLRenderingContext} The created context.
 */


function createContext(canvas, opt_attribs) {
  var names = ["webgl2", "webgl", "experimental-webgl"];
  var context = null;

  for (var ii = 0; ii < names.length; ++ii) {
    context = canvas.getContext(names[ii], opt_attribs);

    if (context) {
      if (defaults.addExtensionsToContext) {
        addExtensionsToContext(context);
      }

      break;
    }
  }

  return context;
}
/**
 * Gets a WebGL context.  Will create a WebGL2 context if possible.
 *
 * You can check if it's WebGL2 with
 *
 *    function isWebGL2(gl) {
 *      return gl.getParameter(gl.VERSION).indexOf("WebGL 2.0 ") == 0;
 *    }
 *
 * Note: For a WebGL1 context will attempt to enable Vertex Array Objects
 * and add WebGL2 entry points. (unless you first set defaults with
 * `twgl.setDefaults({enableVertexArrayObjects: false})`;
 *
 * @param {HTMLCanvasElement} canvas a canvas element.
 * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes
 * @return {WebGLRenderingContext} The created context.
 * @memberOf module:twgl
 */


function getContext(canvas, opt_attribs) {
  var gl = createContext(canvas, opt_attribs);
  return gl;
}
/**
 * Resize a canvas to match the size it's displayed.
 * @param {HTMLCanvasElement} canvas The canvas to resize.
 * @param {number} [multiplier] So you can pass in `window.devicePixelRatio` or other scale value if you want to.
 * @return {boolean} true if the canvas was resized.
 * @memberOf module:twgl
 */


function resizeCanvasToDisplaySize(canvas, multiplier) {
  multiplier = multiplier || 1;
  multiplier = Math.max(0, multiplier);
  var width = canvas.clientWidth * multiplier | 0;
  var height = canvas.clientHeight * multiplier | 0;

  if (canvas.width !== width || canvas.height !== height) {
    canvas.width = width;
    canvas.height = height;
    return true;
  }

  return false;
}

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.drawBufferInfo = drawBufferInfo;
exports.drawObjectList = drawObjectList;

var programs = _interopRequireWildcard(__webpack_require__(5));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/*
 * Copyright 2015, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Drawing related functions
 *
 * For backward compatibily they are available at both `twgl.draw` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/draw
 */

/**
 * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate
 *
 * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself
 * but calling this means if you switch from indexed data to non-indexed
 * data you don't have to remember to update your draw call.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} bufferInfo A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays} or
 *   a VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}
 * @param {enum} [type] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...). Defaults to `gl.TRIANGLES`
 * @param {number} [count] An optional count. Defaults to bufferInfo.numElements
 * @param {number} [offset] An optional offset. Defaults to 0.
 * @param {number} [instanceCount] An optional instanceCount. if set then `drawArraysInstanced` or `drawElementsInstanced` will be called
 * @memberOf module:twgl/draw
 */
function drawBufferInfo(gl, bufferInfo, type, count, offset, instanceCount) {
  type = type === undefined ? gl.TRIANGLES : type;
  var indices = bufferInfo.indices;
  var elementType = bufferInfo.elementType;
  var numElements = count === undefined ? bufferInfo.numElements : count;
  offset = offset === undefined ? 0 : offset;

  if (elementType || indices) {
    if (instanceCount !== undefined) {
      gl.drawElementsInstanced(type, numElements, elementType === undefined ? gl.UNSIGNED_SHORT : bufferInfo.elementType, offset, instanceCount);
    } else {
      gl.drawElements(type, numElements, elementType === undefined ? gl.UNSIGNED_SHORT : bufferInfo.elementType, offset);
    }
  } else {
    if (instanceCount !== undefined) {
      gl.drawArraysInstanced(type, offset, numElements, instanceCount);
    } else {
      gl.drawArrays(type, offset, numElements);
    }
  }
}
/**
 * A DrawObject is useful for putting objects in to an array and passing them to {@link module:twgl.drawObjectList}.
 *
 * You need either a `BufferInfo` or a `VertexArrayInfo`.
 *
 * @typedef {Object} DrawObject
 * @property {boolean} [active] whether or not to draw. Default = `true` (must be `false` to be not true). In otherwords `undefined` = `true`
 * @property {number} [type] type to draw eg. `gl.TRIANGLES`, `gl.LINES`, etc...
 * @property {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}
 * @property {module:twgl.BufferInfo} [bufferInfo] A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays}
 * @property {module:twgl.VertexArrayInfo} [vertexArrayInfo] A VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}
 * @property {Object<string, ?>} uniforms The values for the uniforms.
 *   You can pass multiple objects by putting them in an array. For example
 *
 *     var sharedUniforms = {
 *       u_fogNear: 10,
 *       u_projection: ...
 *       ...
 *     };
 *
 *     var localUniforms = {
 *       u_world: ...
 *       u_diffuseColor: ...
 *     };
 *
 *     var drawObj = {
 *       ...
 *       uniforms: [sharedUniforms, localUniforms],
 *     };
 *
 * @property {number} [offset] the offset to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to 0.
 * @property {number} [count] the count to pass to `gl.drawArrays` or `gl.drawElemnts`. Defaults to bufferInfo.numElements.
 * @property {number} [instanceCount] the number of instances. Defaults to undefined.
 * @memberOf module:twgl
 */

/**
 * Draws a list of objects
 * @param {DrawObject[]} objectsToDraw an array of objects to draw.
 * @memberOf module:twgl/draw
 */


function drawObjectList(gl, objectsToDraw) {
  var lastUsedProgramInfo = null;
  var lastUsedBufferInfo = null;
  objectsToDraw.forEach(function (object) {
    if (object.active === false) {
      return;
    }

    var programInfo = object.programInfo;
    var bufferInfo = object.vertexArrayInfo || object.bufferInfo;
    var bindBuffers = false;
    var type = object.type === undefined ? gl.TRIANGLES : object.type;

    if (programInfo !== lastUsedProgramInfo) {
      lastUsedProgramInfo = programInfo;
      gl.useProgram(programInfo.program); // We have to rebind buffers when changing programs because we
      // only bind buffers the program uses. So if 2 programs use the same
      // bufferInfo but the 1st one uses only positions the when the
      // we switch to the 2nd one some of the attributes will not be on.

      bindBuffers = true;
    } // Setup all the needed attributes.


    if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {
      if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject && !bufferInfo.vertexArrayObject) {
        gl.bindVertexArray(null);
      }

      lastUsedBufferInfo = bufferInfo;
      programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);
    } // Set the uniforms.


    programs.setUniforms(programInfo, object.uniforms); // Draw

    drawBufferInfo(gl, bufferInfo, type, object.count, object.offset, object.instanceCount);
  });

  if (lastUsedBufferInfo.vertexArrayObject) {
    gl.bindVertexArray(null);
  }
}

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.bindFramebufferInfo = bindFramebufferInfo;
exports.createFramebufferInfo = createFramebufferInfo;
exports.resizeFramebufferInfo = resizeFramebufferInfo;

var textures = _interopRequireWildcard(__webpack_require__(8));

var helper = _interopRequireWildcard(__webpack_require__(0));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/*
 * Copyright 2015, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Framebuffer related functions
 *
 * For backward compatibily they are available at both `twgl.framebuffer` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/framebuffers
 */
// make sure we don't see a global gl
var gl = undefined; // eslint-disable-line

var UNSIGNED_BYTE = 0x1401;
/* PixelFormat */

var DEPTH_COMPONENT = 0x1902;
var RGBA = 0x1908;
/* Framebuffer Object. */

var RGBA4 = 0x8056;
var RGB5_A1 = 0x8057;
var RGB565 = 0x8D62;
var DEPTH_COMPONENT16 = 0x81A5;
var STENCIL_INDEX = 0x1901;
var STENCIL_INDEX8 = 0x8D48;
var DEPTH_STENCIL = 0x84F9;
var COLOR_ATTACHMENT0 = 0x8CE0;
var DEPTH_ATTACHMENT = 0x8D00;
var STENCIL_ATTACHMENT = 0x8D20;
var DEPTH_STENCIL_ATTACHMENT = 0x821A;
/* TextureWrapMode */

var REPEAT = 0x2901; // eslint-disable-line

var CLAMP_TO_EDGE = 0x812F;
var MIRRORED_REPEAT = 0x8370; // eslint-disable-line

/* TextureMagFilter */

var NEAREST = 0x2600; // eslint-disable-line

var LINEAR = 0x2601;
/* TextureMinFilter */

var NEAREST_MIPMAP_NEAREST = 0x2700; // eslint-disable-line

var LINEAR_MIPMAP_NEAREST = 0x2701; // eslint-disable-line

var NEAREST_MIPMAP_LINEAR = 0x2702; // eslint-disable-line

var LINEAR_MIPMAP_LINEAR = 0x2703; // eslint-disable-line

/**
 * The options for a framebuffer attachment.
 *
 * Note: For a `format` that is a texture include all the texture
 * options from {@link module:twgl.TextureOptions} for example
 * `min`, `mag`, `clamp`, etc... Note that unlike {@link module:twgl.TextureOptions}
 * `auto` defaults to `false` for attachment textures but `min` and `mag` default
 * to `gl.LINEAR` and `wrap` defaults to `CLAMP_TO_EDGE`
 *
 * @typedef {Object} AttachmentOptions
 * @property {number} [attach] The attachment point. Defaults
 *   to `gl.COLOR_ATTACTMENT0 + ndx` unless type is a depth or stencil type
 *   then it's gl.DEPTH_ATTACHMENT or `gl.DEPTH_STENCIL_ATTACHMENT` depending
 *   on the format or attachment type.
 * @property {number} [format] The format. If one of `gl.RGBA4`,
 *   `gl.RGB565`, `gl.RGB5_A1`, `gl.DEPTH_COMPONENT16`,
 *   `gl.STENCIL_INDEX8` or `gl.DEPTH_STENCIL` then will create a
 *   renderbuffer. Otherwise will create a texture. Default = `gl.RGBA`
 * @property {number} [type] The type. Used for texture. Default = `gl.UNSIGNED_BYTE`.
 * @property {number} [target] The texture target for `gl.framebufferTexture2D`.
 *   Defaults to `gl.TEXTURE_2D`. Set to appropriate face for cube maps.
 * @property {number} [level] level for `gl.framebufferTexture2D`. Defaults to 0.
 * @property {WebGLObject} [attachment] An existing renderbuffer or texture.
 *    If provided will attach this Object. This allows you to share
 *    attachemnts across framebuffers.
 * @memberOf module:twgl
 */

var defaultAttachments = [{
  format: RGBA,
  type: UNSIGNED_BYTE,
  min: LINEAR,
  wrap: CLAMP_TO_EDGE
}, {
  format: DEPTH_STENCIL
}];
var attachmentsByFormat = {};
attachmentsByFormat[DEPTH_STENCIL] = DEPTH_STENCIL_ATTACHMENT;
attachmentsByFormat[STENCIL_INDEX] = STENCIL_ATTACHMENT;
attachmentsByFormat[STENCIL_INDEX8] = STENCIL_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT16] = DEPTH_ATTACHMENT;

function getAttachmentPointForFormat(format) {
  return attachmentsByFormat[format];
}

var renderbufferFormats = {};
renderbufferFormats[RGBA4] = true;
renderbufferFormats[RGB5_A1] = true;
renderbufferFormats[RGB565] = true;
renderbufferFormats[DEPTH_STENCIL] = true;
renderbufferFormats[DEPTH_COMPONENT16] = true;
renderbufferFormats[STENCIL_INDEX] = true;
renderbufferFormats[STENCIL_INDEX8] = true;

function isRenderbufferFormat(format) {
  return renderbufferFormats[format];
}
/**
 * @typedef {Object} FramebufferInfo
 * @property {WebGLFramebuffer} framebuffer The WebGLFramebuffer for this framebufferInfo
 * @property {WebGLObject[]} attachments The created attachments in the same order as passed in to {@link module:twgl.createFramebufferInfo}.
 * @memberOf module:twgl
 */

/**
 * Creates a framebuffer and attachments.
 *
 * This returns a {@link module:twgl.FramebufferInfo} because it needs to return the attachments as well as the framebuffer.
 *
 * The simplest usage
 *
 *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer
 *     const fbi = twgl.createFramebufferInfo(gl);
 *
 * More complex usage
 *
 *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer
 *     const attachments = [
 *       { format: RGB565, mag: NEAREST },
 *       { format: STENCIL_INDEX8 },
 *     ]
 *     const fbi = twgl.createFramebufferInfo(gl, attachments);
 *
 * Passing in a specific size
 *
 *     const width = 256;
 *     const height = 256;
 *     const fbi = twgl.createFramebufferInfo(gl, attachments, width, height);
 *
 * **Note!!** It is up to you to check if the framebuffer is renderable by calling `gl.checkFramebufferStatus`.
 * [WebGL only guarantees 3 combinations of attachments work](https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.6).
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.AttachmentOptions[]} [attachments] which attachments to create. If not provided the default is a framebuffer with an
 *    `RGBA`, `UNSIGNED_BYTE` texture `COLOR_ATTACHMENT0` and a `DEPTH_STENCIL` renderbuffer `DEPTH_STENCIL_ATTACHMENT`.
 * @param {number} [width] the width for the attachments. Default = size of drawingBuffer
 * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer
 * @return {module:twgl.FramebufferInfo} the framebuffer and attachments.
 * @memberOf module:twgl/framebuffers
 */


function createFramebufferInfo(gl, attachments, width, height) {
  var target = gl.FRAMEBUFFER;
  var fb = gl.createFramebuffer();
  gl.bindFramebuffer(target, fb);
  width = width || gl.drawingBufferWidth;
  height = height || gl.drawingBufferHeight;
  attachments = attachments || defaultAttachments;
  var colorAttachmentCount = 0;
  var framebufferInfo = {
    framebuffer: fb,
    attachments: [],
    width: width,
    height: height
  };
  attachments.forEach(function (attachmentOptions) {
    var attachment = attachmentOptions.attachment;
    var format = attachmentOptions.format;
    var attachmentPoint = getAttachmentPointForFormat(format);

    if (!attachmentPoint) {
      attachmentPoint = COLOR_ATTACHMENT0 + colorAttachmentCount++;
    }

    if (!attachment) {
      if (isRenderbufferFormat(format)) {
        attachment = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);
        gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);
      } else {
        var textureOptions = Object.assign({}, attachmentOptions);
        textureOptions.width = width;
        textureOptions.height = height;

        if (textureOptions.auto === undefined) {
          textureOptions.auto = false;
          textureOptions.min = textureOptions.min || textureOptions.minMag || gl.LINEAR;
          textureOptions.mag = textureOptions.mag || textureOptions.minMag || gl.LINEAR;
          textureOptions.wrapS = textureOptions.wrapS || textureOptions.wrap || gl.CLAMP_TO_EDGE;
          textureOptions.wrapT = textureOptions.wrapT || textureOptions.wrap || gl.CLAMP_TO_EDGE;
        }

        attachment = textures.createTexture(gl, textureOptions);
      }
    }

    if (helper.isRenderbuffer(gl, attachment)) {
      gl.framebufferRenderbuffer(target, attachmentPoint, gl.RENDERBUFFER, attachment);
    } else if (helper.isTexture(gl, attachment)) {
      gl.framebufferTexture2D(target, attachmentPoint, attachmentOptions.texTarget || gl.TEXTURE_2D, attachment, attachmentOptions.level || 0);
    } else {
      throw "unknown attachment type";
    }

    framebufferInfo.attachments.push(attachment);
  });
  return framebufferInfo;
}
/**
 * Resizes the attachments of a framebuffer.
 *
 * You need to pass in the same `attachments` as you passed in {@link module:twgl.createFramebufferInfo}
 * because TWGL has no idea the format/type of each attachment.
 *
 * The simplest usage
 *
 *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer
 *     const fbi = twgl.createFramebufferInfo(gl);
 *
 *     ...
 *
 *     function render() {
 *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {
 *         // resize the attachments
 *         twgl.resizeFramebufferInfo(gl, fbi);
 *       }
 *
 * More complex usage
 *
 *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer
 *     const attachments = [
 *       { format: RGB565, mag: NEAREST },
 *       { format: STENCIL_INDEX8 },
 *     ]
 *     const fbi = twgl.createFramebufferInfo(gl, attachments);
 *
 *     ...
 *
 *     function render() {
 *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {
 *         // resize the attachments to match
 *         twgl.resizeFramebufferInfo(gl, fbi, attachments);
 *       }
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.FramebufferInfo} framebufferInfo a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.
 * @param {module:twgl.AttachmentOptions[]} [attachments] the same attachments options as passed to {@link module:twgl.createFramebufferInfo}.
 * @param {number} [width] the width for the attachments. Default = size of drawingBuffer
 * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer
 * @memberOf module:twgl/framebuffers
 */


function resizeFramebufferInfo(gl, framebufferInfo, attachments, width, height) {
  width = width || gl.drawingBufferWidth;
  height = height || gl.drawingBufferHeight;
  framebufferInfo.width = width;
  framebufferInfo.height = height;
  attachments = attachments || defaultAttachments;
  attachments.forEach(function (attachmentOptions, ndx) {
    var attachment = framebufferInfo.attachments[ndx];
    var format = attachmentOptions.format;

    if (helper.isRenderbuffer(gl, attachment)) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);
      gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);
    } else if (helper.isTexture(gl, attachment)) {
      textures.resizeTexture(gl, attachment, attachmentOptions, width, height);
    } else {
      throw "unknown attachment type";
    }
  });
}
/**
 * Binds a framebuffer
 *
 * This function pretty much soley exists because I spent hours
 * trying to figure out why something I wrote wasn't working only
 * to realize I forget to set the viewport dimensions.
 * My hope is this function will fix that.
 *
 * It is effectively the same as
 *
 *     gl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);
 *     gl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.FramebufferInfo} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.
 *   If not passed will bind the canvas.
 * @param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.
 * @memberOf module:twgl/framebuffers
 */


function bindFramebufferInfo(gl, framebufferInfo, target) {
  target = target || gl.FRAMEBUFFER;

  if (framebufferInfo) {
    gl.bindFramebuffer(target, framebufferInfo.framebuffer);
    gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);
  } else {
    gl.bindFramebuffer(target, null);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.createVertexArrayInfo = createVertexArrayInfo;
exports.createVAOAndSetAttributes = createVAOAndSetAttributes;
exports.createVAOFromBufferInfo = createVAOFromBufferInfo;

var programs = _interopRequireWildcard(__webpack_require__(5));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/*
 * Copyright 2015, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * vertex array object related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibily they are available at both `twgl.attributes` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/vertexArrays
 */

/**
 * @typedef {Object} VertexArrayInfo
 * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
 * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..
 * @property {WebGLVertexArrayObject} [vertexArrayObject] a vertex array object
 * @memberOf module:twgl
 */

/**
 * Creates a VertexArrayInfo from a BufferInfo and one or more ProgramInfos
 *
 * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to
 * {@link module:twgl:drawBufferInfo}.
 *
 * > **IMPORTANT:** Vertex Array Objects are **not** a direct analog for a BufferInfo. Vertex Array Objects
 *   assign buffers to specific attributes at creation time. That means they can only be used with programs
 *   who's attributes use the same attribute locations for the same purposes.
 *
 * > Bind your attribute locations by passing an array of attribute names to {@link module:twgl.createProgramInfo}
 *   or use WebGL 2's GLSL ES 3's `layout(location = <num>)` to make sure locations match.
 *
 * also
 *
 * > **IMPORTANT:** After calling twgl.setBuffersAndAttribute with a BufferInfo that uses a Vertex Array Object
 *   that Vertex Array Object will be bound. That means **ANY MANIPULATION OF ELEMENT_ARRAY_BUFFER or ATTRIBUTES**
 *   will affect the Vertex Array Object state.
 *
 * > Call `gl.bindVertexArray(null)` to get back manipulating the global attributes and ELEMENT_ARRAY_BUFFER.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.ProgramInfo|module:twgl.ProgramInfo[]} programInfo a programInfo or array of programInfos
 * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
 *
 *    You need to make sure every attribute that will be used is bound. So for example assume shader 1
 *    uses attributes A, B, C and shader 2 uses attributes A, B, D. If you only pass in the programInfo
 *    for shader 1 then only attributes A, B, and C will have their attributes set because TWGL doesn't
 *    now attribute D's location.
 *
 *    So, you can pass in both shader 1 and shader 2's programInfo
 *
 * @return {module:twgl.VertexArrayInfo} The created VertexArrayInfo
 *
 * @memberOf module:twgl/vertexArrays
 */
function createVertexArrayInfo(gl, programInfos, bufferInfo) {
  var vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  if (!programInfos.length) {
    programInfos = [programInfos];
  }

  programInfos.forEach(function (programInfo) {
    programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);
  });
  gl.bindVertexArray(null);
  return {
    numElements: bufferInfo.numElements,
    elementType: bufferInfo.elementType,
    vertexArrayObject: vao
  };
}
/**
 * Creates a vertex array object and then sets the attributes on it
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
 * @param {Object.<string, module:twgl.AttribInfo>} attribs AttribInfos mapped by attribute name.
 * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
 * @memberOf module:twgl/vertexArrays
 */


function createVAOAndSetAttributes(gl, setters, attribs, indices) {
  var vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  programs.setAttributes(setters, attribs);

  if (indices) {
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);
  } // We unbind this because otherwise any change to ELEMENT_ARRAY_BUFFER
  // like when creating buffers for other stuff will mess up this VAO's binding


  gl.bindVertexArray(null);
  return vao;
}
/**
 * Creates a vertex array object and then sets the attributes
 * on it
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {Object.<string, function>| module:twgl.ProgramInfo} programInfo as returned from createProgramInfo or Attribute setters as returned from createAttributeSetters
 * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
 * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
 * @memberOf module:twgl/vertexArrays
 */


function createVAOFromBufferInfo(gl, programInfo, bufferInfo) {
  return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);
}

/***/ })
/******/ ]);
});

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Coord3 {
    constructor(coord) {
        this.x = coord.x;
        this.y = coord.y;
        this.z = coord.z;
    }
    scaled(factor) {
        return Coord3.scale(this, factor);
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    normalized() {
        return Coord3.scale(this, 1 / this.length());
    }
    static distance(a, b) {
        return Coord3.subtract(a, b).length();
    }
    static add(a, b) {
        return new Coord3({
            x: a.x + b.x,
            y: a.y + b.y,
            z: a.z + b.z,
        });
    }
    static subtract(a, b) {
        return new Coord3({
            x: a.x - b.x,
            y: a.y - b.y,
            z: a.z - b.z,
        });
    }
    static scale(coord, factor) {
        return new Coord3({
            x: coord.x * factor,
            y: coord.y * factor,
            z: coord.z * factor,
        });
    }
}
exports.Coord3 = Coord3;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Coord2 {
    constructor(coord) {
        this.x = coord.x;
        this.y = coord.y;
    }
    scaled(factor) {
        return Coord2.scale(this, factor);
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    normalized() {
        return Coord2.scale(this, 1 / this.length());
    }
    static distance(a, b) {
        return Coord2.subtract(a, b).length();
    }
    static add(a, b) {
        return new Coord2({
            x: a.x + b.x,
            y: a.y + b.y,
        });
    }
    static subtract(a, b) {
        return new Coord2({
            x: a.x - b.x,
            y: a.y - b.y,
        });
    }
    static scale(coord, factor) {
        return new Coord2({
            x: coord.x * factor,
            y: coord.y * factor,
        });
    }
}
exports.Coord2 = Coord2;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const functions_1 = __webpack_require__(1);
const Renderer = __webpack_require__(0);
class Piece {
    constructor(options) {
        this.color = options.color;
        this.colorIsVisible = true;
        this.picked = false;
        this.frameCoroutine = this.makeFrameCoroutine();
    }
    setPicked(picked) {
        this.picked = picked;
    }
    *makeFrameCoroutine() {
        yield* functions_1.waitMs(1000);
        this.colorIsVisible = false;
    }
    draw(position) {
        Renderer.draw(this.picked || this.colorIsVisible ? this.color : -1, position);
    }
}
exports.Piece = Piece;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Board_1 = __webpack_require__(2);
class GameMode1p {
    constructor() {
        this.board = new Board_1.Board({ gameMode: this });
        this.frameCoroutine = this.makeFrameCoroutine();
    }
    onUnlockedPair(_board) {
        console.log("unlocked pair");
        // TODO
    }
    onGameOver(_board) {
        console.log("game over");
        // TODO
    }
    onWin(_board) {
        console.log("win");
        // TODO
    }
    *makeFrameCoroutine() {
        for (;;) {
            // The player board.
            const deltaTime = yield;
            const next = this.board.frameCoroutine.next(deltaTime);
            // Yes, I could have used a simple for-of, but I expect to add more stuff to run in concurrently.
            if (next.done) {
                return;
            }
        }
    }
    draw() {
        // The player board.
        this.board.draw();
    }
}
exports.GameMode1p = GameMode1p;


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjA1Y2JhNDIxYTZlNzZmNDA4ZTAiLCJ3ZWJwYWNrOi8vLy4vc3JjL1JlbmRlcmVyLnRzIiwid2VicGFjazovLy8uL3NyYy9mdW5jdGlvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0JvYXJkLnRzIiwid2VicGFjazovLy8uL3NyYy9tYWluLnRzIiwid2VicGFjazovLy8uL3NyYy9BcHAudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3Z2wuanMvZGlzdC80LngvdHdnbC1mdWxsLmpzIiwid2VicGFjazovLy8uL3NyYy9Db29yZDMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0Nvb3JkMi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvUGllY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0dhbWVNb2RlMXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7O0FDNURBLG9DQUFnQztBQUNoQywyQ0FBMEU7QUFDMUUsdUNBQWdDO0FBRWhDLGtDQUFrQztBQUNyQixjQUFNLEdBQUcsUUFBUSxDQUFDLG9CQUFvQixDQUNsRCxRQUFRLENBQ1IsQ0FBQyxDQUFDLENBQXNCLENBQUM7QUFDYixVQUFFLEdBQUcsY0FBTSxDQUFDLFVBQVUsQ0FBQyxP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QyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ3hDLEtBQUssRUFBRSxJQUFJLGVBQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7WUFDdkMsTUFBTSxFQUFFLElBQUksZUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztTQUN4QztRQUNEO1lBQ0MsS0FBSyxFQUFFLElBQUksZUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUN2QyxLQUFLLEVBQUUsSUFBSSxlQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ3ZDLE1BQU0sRUFBRSxJQUFJLGVBQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztTQUN6QztRQUVEO1lBQ0MsS0FBSyxFQUFFLElBQUksZUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUN2QyxLQUFLLEVBQUUsSUFBSSxlQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ3ZDLE1BQU0sRUFBRSxJQUFJLGVBQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7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QSwyREFBMkQ7QUFDM0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxnRkFBZ0Y7QUFDakY7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxvQkFBb0I7QUFDL0IsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixXQUFXLG9CQUFvQjtBQUMvQixXQUFXLG9CQUFvQjtBQUMvQixZQUFZLG9CQUFvQjtBQUNoQztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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RXJCOztBQUVBLG9DQUFvQzs7QUFFcEMsbUNBQW1DOztBQUVuQyxtQ0FBbUM7O0FBRW5DLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUMsSUFBSSxFQUFFLENBQUM7SUFDbkIsQ0FBQztDQUNEO0FBekNELGdDQXlDQyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvZGlzdC9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBiMDVjYmE0MjFhNmU3NmY0MDhlMCIsImltcG9ydCB7IENvb3JkMiB9IGZyb20gXCIuL0Nvb3JkMlwiO1xuaW1wb3J0ICogYXMgdHdnbCBmcm9tIFwidHdnbC5qc1wiO1xuaW1wb3J0IHsgbWVzaFRvV2ViZ2xBcnJheXMsIG1ha2VUZXNzZWxhdGVkU3BoZXJlTWVzaCB9IGZyb20gXCIuL2Z1bmN0aW9uc1wiO1xuaW1wb3J0IHsgQm9hcmQgfSBmcm9tIFwiLi9Cb2FyZFwiO1xuXG4vLyBUT0RPOiBNYWtlIGl0IG93bmVkIGJ1IHRoZSBhcHA/XG5leHBvcnQgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXG5cdFwiY2FudmFzXCIsXG4pWzBdIGFzIEhUTUxDYW52YXNFbGVtZW50O1xuZXhwb3J0IGNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKSBhcyBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG5cbmxldCBwcm9ncmFtSW5mbzogdHdnbC5Qcm9ncmFtSW5mbztcbmxldCB0ZXh0dXJlczoge1xuXHRba2V5OiBzdHJpbmddOiBXZWJHTFRleHR1cmU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcblx0dHdnbC5yZXNpemVDYW52YXNUb0Rpc3BsYXlTaXplKGNhbnZhcywgd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuXG5cdGNvbnN0IHByb2dyYW0gPSB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU291cmNlcyhnbCwgW1xuXHRcdGBcblx0XHRcdHVuaWZvcm0gbWF0NCB1X3dvcmxkVmlld1Byb2plY3Rpb247XG5cdFx0XHR1bmlmb3JtIHZlYzMgdV9saWdodFdvcmxkUG9zO1xuXHRcdFx0dW5pZm9ybSBtYXQ0IHVfd29ybGQ7XG5cdFx0XHR1bmlmb3JtIG1hdDQgdV9tb2RlbDtcblx0XHRcdHVuaWZvcm0gbWF0NCB1X3ZpZXdJbnZlcnNlO1xuXHRcdFx0dW5pZm9ybSBtYXQ0IHVfd29ybGRJbnZlcnNlVHJhbnNwb3NlO1xuXHRcdFx0dW5pZm9ybSB2ZWM0IHVfcG9zaXRpb247XG5cblx0XHRcdGF0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9uO1xuXHRcdFx0YXR0cmlidXRlIHZlYzMgbm9ybWFsO1xuXHRcdFx0YXR0cmlidXRlIHZlYzMgdGV4Q29vcmQ7XG5cblx0XHRcdHZhcnlpbmcgdmVjNCB2X3Bvc2l0aW9uO1xuXHRcdFx0dmFyeWluZyB2ZWMzIHZfbm9ybWFsO1xuXHRcdFx0dmFyeWluZyB2ZWMzIHZfdGV4Q29vcmQ7XG5cdFx0XHR2YXJ5aW5nIHZlYzMgdl9zdXJmYWNlVG9MaWdodDtcblx0XHRcdHZhcnlpbmcgdmVjMyB2X3N1cmZhY2VUb1ZpZXc7XG5cblx0XHRcdHZvaWQgbWFpbigpIHtcblx0XHRcdFx0dl9wb3NpdGlvbiA9IHVfd29ybGRWaWV3UHJvamVjdGlvbiAqICgodV9tb2RlbCAqIHBvc2l0aW9uKSArIHVfcG9zaXRpb24pO1xuXHRcdFx0XHR2X25vcm1hbCA9ICh1X3dvcmxkSW52ZXJzZVRyYW5zcG9zZSAqIHVfbW9kZWwgKiB2ZWM0KG5vcm1hbCwgMCkpLnh5ejtcblx0XHRcdFx0dl90ZXhDb29yZCA9IHRleENvb3JkO1xuXHRcdFx0XHR2X3N1cmZhY2VUb0xpZ2h0ID0gdV9saWdodFdvcmxkUG9zIC0gKHVfd29ybGQgKiBwb3NpdGlvbikueHl6O1xuXHRcdFx0XHR2X3N1cmZhY2VUb1ZpZXcgPSAodV92aWV3SW52ZXJzZVszXSAtICh1X3dvcmxkICogcG9zaXRpb24pKS54eXo7XG5cdFx0XHRcdGdsX1Bvc2l0aW9uID0gdl9wb3NpdGlvbjtcblx0XHRcdH1cblx0XHRgLFxuXHRcdGBcblx0XHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG5cdFx0XHR2YXJ5aW5nIHZlYzQgdl9wb3NpdGlvbjtcblx0XHRcdHZhcnlpbmcgdmVjMyB2X25vcm1hbDtcblx0XHRcdHZhcnlpbmcgdmVjMyB2X3RleENvb3JkO1xuXHRcdFx0dmFyeWluZyB2ZWMzIHZfc3VyZmFjZVRvTGlnaHQ7XG5cdFx0XHR2YXJ5aW5nIHZlYzMgdl9zdXJmYWNlVG9WaWV3O1xuXG5cdFx0XHR1bmlmb3JtIHZlYzQgdV9saWdodENvbG9yO1xuXHRcdFx0dW5pZm9ybSB2ZWM0IHVfYW1iaWVudDtcblx0XHRcdHVuaWZvcm0gdmVjNCB1X3NwZWN1bGFyO1xuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X3NoaW5pbmVzcztcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV9zcGVjdWxhckZhY3Rvcjtcblx0XHRcdHVuaWZvcm0gc2FtcGxlckN1YmUgdV9kaWZmdXNlTWFwO1xuXG5cdFx0XHR2ZWM0IGxpdChmbG9hdCBsICxmbG9hdCBoLCBmbG9hdCBtKSB7XG5cdFx0XHRcdHJldHVybiB2ZWM0KFxuXHRcdFx0XHRcdDEuMCxcblx0XHRcdFx0XHRtYXgobCwgMC4wKSxcblx0XHRcdFx0XHQobCA+IDAuMCkgPyBwb3cobWF4KDAuMCwgaCksIG0pIDogMC4wLFxuXHRcdFx0XHRcdDEuMFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHR2b2lkIG1haW4oKSB7XG5cdFx0XHRcdHZlYzQgZGlmZnVzZUNvbG9yID0gdGV4dHVyZUN1YmUodV9kaWZmdXNlTWFwLCBub3JtYWxpemUodl90ZXhDb29yZCkpO1xuXHRcdFx0XHR2ZWMzIGFfbm9ybWFsID0gbm9ybWFsaXplKHZfbm9ybWFsKTtcblx0XHRcdFx0dmVjMyBzdXJmYWNlVG9MaWdodCA9IG5vcm1hbGl6ZSh2X3N1cmZhY2VUb0xpZ2h0KTtcblx0XHRcdFx0dmVjMyBzdXJmYWNlVG9WaWV3ID0gbm9ybWFsaXplKHZfc3VyZmFjZVRvVmlldyk7XG5cdFx0XHRcdHZlYzMgaGFsZlZlY3RvciA9IG5vcm1hbGl6ZShzdXJmYWNlVG9MaWdodCArIHN1cmZhY2VUb1ZpZXcpO1xuXHRcdFx0XHR2ZWM0IGxpdFIgPSBsaXQoXG5cdFx0XHRcdFx0ZG90KGFfbm9ybWFsLCBzdXJmYWNlVG9MaWdodCksXG5cdFx0XHRcdFx0ZG90KGFfbm9ybWFsLCBoYWxmVmVjdG9yKSxcblx0XHRcdFx0XHR1X3NoaW5pbmVzc1xuXHRcdFx0XHQpO1xuXHRcdFx0XHR2ZWM0IG91dENvbG9yID0gdmVjNChcblx0XHRcdFx0XHQodV9saWdodENvbG9yICogKFxuXHRcdFx0XHRcdFx0ZGlmZnVzZUNvbG9yICogbGl0Ui55ICsgZGlmZnVzZUNvbG9yICogdV9hbWJpZW50ICtcblx0XHRcdFx0XHRcdHVfc3BlY3VsYXIgKiBsaXRSLnogKiB1X3NwZWN1bGFyRmFjdG9yXG5cdFx0XHRcdFx0KSkucmdiLFxuXHRcdFx0XHRcdGRpZmZ1c2VDb2xvci5hXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IG91dENvbG9yO1xuXHRcdFx0fVxuXHRcdGAsXG5cdF0pO1xuXG5cdGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcblx0Z2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG5cblx0dGV4dHVyZXMgPSB0d2dsLmNyZWF0ZVRleHR1cmVzKGdsLCB7XG5cdFx0ZWFydGg6IHtcblx0XHRcdHRhcmdldDogZ2wuVEVYVFVSRV9DVUJFX01BUCxcblx0XHRcdHNyYzogXCJncmFwaGljcy9lYXJ0aC5qcGdcIixcblx0XHR9LFxuXHRcdGdsb2JlOiB7XG5cdFx0XHR0YXJnZXQ6IGdsLlRFWFRVUkVfQ1VCRV9NQVAsXG5cdFx0XHRzcmM6IFwiZ3JhcGhpY3MvZ2xvYmUuanBnXCIsXG5cdFx0fSxcblx0XHRleWU6IHtcblx0XHRcdHRhcmdldDogZ2wuVEVYVFVSRV9DVUJFX01BUCxcblx0XHRcdHNyYzogXCJncmFwaGljcy9leWUuanBnXCIsXG5cdFx0fSxcblx0XHRvbmVCYWxsOiB7XG5cdFx0XHR0YXJnZXQ6IGdsLlRFWFRVUkVfQ1VCRV9NQVAsXG5cdFx0XHRzcmM6IFwiZ3JhcGhpY3MvMS1iYWxsLmpwZ1wiLFxuXHRcdH0sXG5cdFx0dGhpcnRlZW5CYWxsOiB7XG5cdFx0XHR0YXJnZXQ6IGdsLlRFWFRVUkVfQ1VCRV9NQVAsXG5cdFx0XHRzcmM6IFwiZ3JhcGhpY3MvMTMtYmFsbC5qcGdcIixcblx0XHR9LFxuXHRcdHZvbGxleToge1xuXHRcdFx0dGFyZ2V0OiBnbC5URVhUVVJFX0NVQkVfTUFQLFxuXHRcdFx0c3JjOiBcImdyYXBoaWNzL3ZvbGxleS5qcGdcIixcblx0XHR9LFxuXHRcdHRlbm5pczoge1xuXHRcdFx0dGFyZ2V0OiBnbC5URVhUVVJFX0NVQkVfTUFQLFxuXHRcdFx0c3JjOiBcImdyYXBoaWNzL3Rlbm5pcy5qcGdcIixcblx0XHR9LFxuXHRcdHNvY2Nlcjoge1xuXHRcdFx0dGFyZ2V0OiBnbC5URVhUVVJFX0NVQkVfTUFQLFxuXHRcdFx0c3JjOiBcImdyYXBoaWNzL3NvY2Nlci5qcGdcIixcblx0XHR9LFxuXHRcdGFuaW1hdG9yOiB7XG5cdFx0XHR0YXJnZXQ6IGdsLlRFWFRVUkVfQ1VCRV9NQVAsXG5cdFx0XHRzcmM6IFwiZ3JhcGhpY3MvYW5pbWF0b3IuanBnXCIsXG5cdFx0fSxcblx0XHRqdXBpdGVyOiB7XG5cdFx0XHR0YXJnZXQ6IGdsLlRFWFRVUkVfQ1VCRV9NQVAsXG5cdFx0XHRzcmM6IFwiZ3JhcGhpY3MvanVwaXRlci5qcGdcIixcblx0XHR9LFxuXHRcdHBva2U6IHtcblx0XHRcdHRhcmdldDogZ2wuVEVYVFVSRV9DVUJFX01BUCxcblx0XHRcdHNyYzogXCJncmFwaGljcy9wb2tlLnBuZ1wiLFxuXHRcdH0sXG5cdFx0YmFsYW5jZToge1xuXHRcdFx0dGFyZ2V0OiBnbC5URVhUVVJFX0NVQkVfTUFQLFxuXHRcdFx0c3JjOiBcImdyYXBoaWNzL2JhbGFuY2UuanBnXCIsXG5cdFx0fSxcblx0XHRiYXNrZXQ6IHtcblx0XHRcdHRhcmdldDogZ2wuVEVYVFVSRV9DVUJFX01BUCxcblx0XHRcdHNyYzogXCJncmFwaGljcy9iYXNrZXQuanBnXCIsXG5cdFx0fSxcblx0fSk7XG5cblx0cHJvZ3JhbUluZm8gPSBwcm9ncmFtICYmIHR3Z2wuY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSkhO1xuXG5cdGdsLnZpZXdwb3J0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XG5cdGdsLnVzZVByb2dyYW0ocHJvZ3JhbUluZm8ucHJvZ3JhbSk7XG5cblx0dHdnbC5zZXRCdWZmZXJzQW5kQXR0cmlidXRlcyhnbCwgcHJvZ3JhbUluZm8sIGJ1ZmZlckluZm8pO1xuXG5cdGNvbnN0IGFzcGVjdCA9IGdsLmNhbnZhcy5jbGllbnRXaWR0aCAvIGdsLmNhbnZhcy5jbGllbnRIZWlnaHQ7XG5cdGNvbnN0IGJvYXJkV2lkdGggPSBCb2FyZC5zaXplLnggKyAyO1xuXHRjb25zdCBib2FyZEhlaWdodCA9IEJvYXJkLnNpemUueSArIDI7XG5cdGNvbnN0IGhhbGZWaXNpYmxlV2lkdGggPSBNYXRoLm1heChib2FyZFdpZHRoLCBib2FyZFdpZHRoICogYXNwZWN0KSAvIDI7XG5cdGNvbnN0IGhhbGZWaXNpYmxlSGVpZ2h0ID0gTWF0aC5tYXgoYm9hcmRIZWlnaHQsIGJvYXJkSGVpZ2h0IC8gYXNwZWN0KSAvIDI7XG5cdGNvbnN0IHpOZWFyID0gMC41O1xuXHRjb25zdCB6RmFyID0gMzA7XG5cdGNvbnN0IHByb2plY3Rpb24gPSB0d2dsLm00Lm9ydGhvKFxuXHRcdC1oYWxmVmlzaWJsZVdpZHRoLFxuXHRcdGhhbGZWaXNpYmxlV2lkdGgsXG5cdFx0LWhhbGZWaXNpYmxlSGVpZ2h0LFxuXHRcdGhhbGZWaXNpYmxlSGVpZ2h0LFxuXHRcdHpOZWFyLFxuXHRcdHpGYXIsXG5cdCk7XG5cdGNvbnN0IGV5ZSA9IFsxLCA0LCAxMl07XG5cdGNvbnN0IHRhcmdldCA9IFswLCAwLCAwXTtcblx0Y29uc3QgdXAgPSBbMCwgMSwgMF07XG5cblx0Y29uc3QgY2FtZXJhID0gdHdnbC5tNC5sb29rQXQoZXllLCB0YXJnZXQsIHVwKTtcblx0Y29uc3QgdmlldyA9IHR3Z2wubTQuaW52ZXJzZShjYW1lcmEpO1xuXHRjb25zdCB2aWV3UHJvamVjdGlvbiA9IHR3Z2wubTQubXVsdGlwbHkocHJvamVjdGlvbiwgdmlldyk7XG5cdGNvbnN0IHdvcmxkID0gdHdnbC5tNC5yb3RhdGlvblkoMCk7XG5cblx0dHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywge1xuXHRcdHVfbGlnaHRXb3JsZFBvczogWy00LCA4LCAxMF0sXG5cdFx0dV9saWdodENvbG9yOiBbMSwgMC44LCAwLjgsIDFdLFxuXHRcdHVfYW1iaWVudDogWzAuNSwgMC41LCAwLjUsIDFdLFxuXHRcdHVfc3BlY3VsYXI6IFswLjUsIDAuNSwgMC41LCAxXSxcblx0XHR1X3NoaW5pbmVzczogNTAsXG5cdFx0dV9zcGVjdWxhckZhY3RvcjogMSxcblx0XHR1X3ZpZXdJbnZlcnNlOiBjYW1lcmEsXG5cdFx0dV93b3JsZDogd29ybGQsXG5cdFx0dV93b3JsZEludmVyc2VUcmFuc3Bvc2U6IHR3Z2wubTQudHJhbnNwb3NlKHR3Z2wubTQuaW52ZXJzZSh3b3JsZCkpLFxuXHRcdHVfd29ybGRWaWV3UHJvamVjdGlvbjogdHdnbC5tNC5tdWx0aXBseSh2aWV3UHJvamVjdGlvbiwgd29ybGQpLFxuXHR9KTtcblxuXHRjbGVhcigpO1xufVxuXG5jb25zdCBiYWxsQXJyYXlzID0gbWVzaFRvV2ViZ2xBcnJheXMobWFrZVRlc3NlbGF0ZWRTcGhlcmVNZXNoKDAuNCwgOCkpO1xuY29uc3QgYnVmZmVySW5mbyA9IHR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMoZ2wsIGJhbGxBcnJheXMpO1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG5cdGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXcoY29sb3I6IG51bWJlciwgcG9zaXRpb246IENvb3JkMikge1xuXHRjb25zdCBtb2RlbCA9IHR3Z2wubTQubXVsdGlwbHkoXG5cdFx0dHdnbC5tNC5yb3RhdGlvblkobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKSxcblx0XHR0d2dsLm00LnJvdGF0aW9uWChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEzNDEpLFxuXHQpO1xuXG5cdHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIHtcblx0XHR1X21vZGVsOiBtb2RlbCxcblx0XHR1X2RpZmZ1c2VNYXA6XG5cdFx0XHR0ZXh0dXJlc1tPYmplY3Qua2V5cyh0ZXh0dXJlcylbY29sb3IgJSBPYmplY3Qua2V5cyh0ZXh0dXJlcykubGVuZ3RoXV0sXG5cdFx0dV9wb3NpdGlvbjogW3Bvc2l0aW9uLngsIHBvc2l0aW9uLnksIDAsIDBdLFxuXHR9KTtcblxuXHR0d2dsLmRyYXdCdWZmZXJJbmZvKGdsLCBidWZmZXJJbmZvKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9SZW5kZXJlci50cyIsIi8vIGltcG9ydCB7IENvb3JkMiB9IGZyb20gXCIuL0Nvb3JkMlwiO1xuaW1wb3J0ICogYXMgdHdnbCBmcm9tIFwidHdnbC5qc1wiO1xuaW1wb3J0IHsgQ29vcmQzIH0gZnJvbSBcIi4vQ29vcmQzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiogd2FpdE1zKGR1cmF0aW9uOiBudW1iZXIpOiBJdGVyYWJsZUl0ZXJhdG9yPHZvaWQ+IHtcblx0bGV0IGVsYXBzZWRUaW1lID0gMDtcblxuXHR3aGlsZSAoZWxhcHNlZFRpbWUgPCBkdXJhdGlvbikge1xuXHRcdGNvbnN0IGRlbHRhVGltZTogbnVtYmVyID0geWllbGQ7XG5cdFx0ZWxhcHNlZFRpbWUgKz0gZGVsdGFUaW1lO1xuXHR9XG5cblx0cmV0dXJuIGVsYXBzZWRUaW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHJhbmdlKGZyb206IG51bWJlciwgdG86IG51bWJlcik6IEl0ZXJhYmxlSXRlcmF0b3I8bnVtYmVyPiB7XG5cdGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87ICsraSkge1xuXHRcdHlpZWxkIGk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUVsZW1lbnQ8VD4oYXJyYXk6IFJlYWRvbmx5QXJyYXk8VD4pIHtcblx0cmV0dXJuIGFycmF5W01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFycmF5Lmxlbmd0aCldIGFzIFQgfCB1bmRlZmluZWQ7XG59XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjQ1MDk1NC9ob3ctdG8tcmFuZG9taXplLWEtamF2YXNjcmlwdC1hcnJheVxuZXhwb3J0IGZ1bmN0aW9uIGZpc2hlcllhdGVzQXJyYXlTaHVmZmxlPFQ+KG15QXJyYXk6IEFycmF5PFQ+KSB7XG5cdGxldCBpID0gbXlBcnJheS5sZW5ndGg7XG5cdGlmIChpID09PSAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHdoaWxlICgtLWkpIHtcblx0XHRjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG5cdFx0Y29uc3QgdGVtcGkgPSBteUFycmF5W2ldO1xuXHRcdGNvbnN0IHRlbXBqID0gbXlBcnJheVtqXTtcblx0XHRteUFycmF5W2ldID0gdGVtcGo7XG5cdFx0bXlBcnJheVtqXSA9IHRlbXBpO1xuXHR9XG59XG5cbmludGVyZmFjZSBWZXJ0ZXgge1xuXHRwb3NpdGlvbjogQ29vcmQzO1xuXHRub3JtYWw6IENvb3JkMztcblx0dGV4Q29vcmQ6IENvb3JkMztcbn1cbmludGVyZmFjZSBNZXNoIHtcblx0dmVydGljZXM6IFJlYWRvbmx5QXJyYXk8VmVydGV4Pjtcblx0aW5kaWNlczogUmVhZG9ubHlBcnJheTxudW1iZXI+O1xufVxuaW50ZXJmYWNlIE11dGFibGVNZXNoIHtcblx0dmVydGljZXM6IEFycmF5PFZlcnRleD47XG5cdGluZGljZXM6IEFycmF5PG51bWJlcj47XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVRlc3NlbGF0ZWRDdWJlTWVzaCh0ZXNzZWxhdGlvbjogbnVtYmVyKTogTWVzaCB7XG5cdGZ1bmN0aW9uIG1ha2VTaWRlKHVBeGlzOiBDb29yZDMsIHZBeGlzOiBDb29yZDMsIG5vcm1hbDogQ29vcmQzKTogTWVzaCB7XG5cdFx0Y29uc3QgdmVydGljZXM6IEFycmF5PFZlcnRleD4gPSBbXTtcblx0XHRjb25zdCBpbmRpY2VzOiBBcnJheTxudW1iZXI+ID0gW107XG5cblx0XHRmb3IgKGxldCB2ID0gMDsgdiA8PSB0ZXNzZWxhdGlvbjsgKyt2KSB7XG5cdFx0XHRjb25zdCB2RmFjdG9yID0gdiAvIHRlc3NlbGF0aW9uO1xuXG5cdFx0XHRmb3IgKGxldCB1ID0gMDsgdSA8PSB0ZXNzZWxhdGlvbjsgKyt1KSB7XG5cdFx0XHRcdGNvbnN0IHVGYWN0b3IgPSB1IC8gdGVzc2VsYXRpb247XG5cblx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBDb29yZDMuYWRkKFxuXHRcdFx0XHRcdENvb3JkMy5hZGQoXG5cdFx0XHRcdFx0XHR1QXhpcy5zY2FsZWQoLTEgKyAyICogdUZhY3RvciksXG5cdFx0XHRcdFx0XHR2QXhpcy5zY2FsZWQoLTEgKyAyICogdkZhY3RvciksXG5cdFx0XHRcdFx0KSxcblx0XHRcdFx0XHRub3JtYWwsXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCh7XG5cdFx0XHRcdFx0cG9zaXRpb24sXG5cdFx0XHRcdFx0bm9ybWFsLFxuXHRcdFx0XHRcdHRleENvb3JkOiBwb3NpdGlvbi5ub3JtYWxpemVkKCksXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAobGV0IHYgPSAwOyB2IDwgdGVzc2VsYXRpb247ICsrdikge1xuXHRcdFx0Zm9yIChsZXQgdSA9IDA7IHUgPCB0ZXNzZWxhdGlvbjsgKyt1KSB7XG5cdFx0XHRcdGNvbnN0IGkgPSB1ICsgdiAqICh0ZXNzZWxhdGlvbiArIDEpO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goaSwgaSArIDEsIGkgKyAodGVzc2VsYXRpb24gKyAxKSk7XG5cdFx0XHRcdGluZGljZXMucHVzaChpICsgMSwgaSArIDEgKyAodGVzc2VsYXRpb24gKyAxKSwgaSArICh0ZXNzZWxhdGlvbiArIDEpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dmVydGljZXMsXG5cdFx0XHRpbmRpY2VzLFxuXHRcdH07XG5cdH1cblxuXHRjb25zdCBzaWRlQXJndW1lbnRzID0gW1xuXHRcdHtcblx0XHRcdHVBeGlzOiBuZXcgQ29vcmQzKHsgeDogMCwgeTogMSwgejogMCB9KSxcblx0XHRcdHZBeGlzOiBuZXcgQ29vcmQzKHsgeDogMCwgeTogMCwgejogMSB9KSxcblx0XHRcdG5vcm1hbDogbmV3IENvb3JkMyh7IHg6IDEsIHk6IDAsIHo6IDAgfSksXG5cdFx0fSxcblx0XHR7XG5cdFx0XHR1QXhpczogbmV3IENvb3JkMyh7IHg6IDAsIHk6IC0xLCB6OiAwIH0pLFxuXHRcdFx0dkF4aXM6IG5ldyBDb29yZDMoeyB4OiAwLCB5OiAwLCB6OiAxIH0pLFxuXHRcdFx0bm9ybWFsOiBuZXcgQ29vcmQzKHsgeDogLTEsIHk6IDAsIHo6IDAgfSksXG5cdFx0fSxcblx0XHR7XG5cdFx0XHR1QXhpczogbmV3IENvb3JkMyh7IHg6IC0xLCB5OiAwLCB6OiAwIH0pLFxuXHRcdFx0dkF4aXM6IG5ldyBDb29yZDMoeyB4OiAwLCB5OiAwLCB6OiAxIH0pLFxuXHRcdFx0bm9ybWFsOiBuZXcgQ29vcmQzKHsgeDogMCwgeTogMSwgejogMCB9KSxcblx0XHR9LFxuXHRcdHtcblx0XHRcdHVBeGlzOiBuZXcgQ29vcmQzKHsgeDogMSwgeTogMCwgejogMCB9KSxcblx0XHRcdHZBeGlzOiBuZXcgQ29vcmQzKHsgeDogMCwgeTogMCwgejogMSB9KSxcblx0XHRcdG5vcm1hbDogbmV3IENvb3JkMyh7IHg6IDAsIHk6IC0xLCB6OiAwIH0pLFxuXHRcdH0sXG5cblx0XHR7XG5cdFx0XHR1QXhpczogbmV3IENvb3JkMyh7IHg6IDEsIHk6IDAsIHo6IDAgfSksXG5cdFx0XHR2QXhpczogbmV3IENvb3JkMyh7IHg6IDAsIHk6IDEsIHo6IDAgfSksXG5cdFx0XHRub3JtYWw6IG5ldyBDb29yZDMoeyB4OiAwLCB5OiAwLCB6OiAxIH0pLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0dUF4aXM6IG5ldyBDb29yZDMoeyB4OiAxLCB5OiAwLCB6OiAwIH0pLFxuXHRcdFx0dkF4aXM6IG5ldyBDb29yZDMoeyB4OiAwLCB5OiAtMSwgejogMCB9KSxcblx0XHRcdG5vcm1hbDogbmV3IENvb3JkMyh7IHg6IDAsIHk6IDAsIHo6IC0xIH0pLFxuXHRcdH0sXG5cdF07XG5cblx0cmV0dXJuIG1lcmdlTWVzaGVzKFxuXHRcdHNpZGVBcmd1bWVudHMubWFwKCh7IHVBeGlzLCB2QXhpcywgbm9ybWFsIH0pID0+XG5cdFx0XHRtYWtlU2lkZSh1QXhpcywgdkF4aXMsIG5vcm1hbCksXG5cdFx0KSxcblx0KTtcbn1cbmZ1bmN0aW9uIG1lcmdlTWVzaGVzKG1lc2hlczogUmVhZG9ubHlBcnJheTxNZXNoPik6IE1lc2gge1xuXHRsZXQgaW5kZXhTdGFydCA9IDA7XG5cdHJldHVybiBtZXNoZXMucmVkdWNlKFxuXHRcdChzb0ZhcjogTXV0YWJsZU1lc2gsIGN1cnJlbnQpID0+IHtcblx0XHRcdHNvRmFyLnZlcnRpY2VzLnB1c2goLi4uY3VycmVudC52ZXJ0aWNlcyk7XG5cdFx0XHRzb0Zhci5pbmRpY2VzLnB1c2goLi4uY3VycmVudC5pbmRpY2VzLm1hcChpbmRleCA9PiBpbmRleCArIGluZGV4U3RhcnQpKTtcblx0XHRcdGluZGV4U3RhcnQgKz0gY3VycmVudC52ZXJ0aWNlcy5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gc29GYXI7XG5cdFx0fSxcblx0XHR7XG5cdFx0XHR2ZXJ0aWNlczogW10sXG5cdFx0XHRpbmRpY2VzOiBbXSxcblx0XHR9IGFzIE11dGFibGVNZXNoLFxuXHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVRlc3NlbGF0ZWRTcGhlcmVNZXNoKFxuXHRyYWRpdXM6IG51bWJlcixcblx0dGVzc2VsYXRpb246IG51bWJlcixcbik6IE1lc2gge1xuXHRjb25zdCBtZXNoID0gbWFrZVRlc3NlbGF0ZWRDdWJlTWVzaCh0ZXNzZWxhdGlvbikgYXMgTXV0YWJsZU1lc2g7XG5cblx0bWVzaC52ZXJ0aWNlcyA9IG1lc2gudmVydGljZXMubWFwKHZlcnRleCA9PiB7XG5cdFx0Y29uc3Qgbm9ybWFsaXplZFBvc2l0aW9uID0gdmVydGV4LnBvc2l0aW9uLm5vcm1hbGl6ZWQoKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cG9zaXRpb246IG5vcm1hbGl6ZWRQb3NpdGlvbi5zY2FsZWQocmFkaXVzKSxcblx0XHRcdG5vcm1hbDogbm9ybWFsaXplZFBvc2l0aW9uLFxuXHRcdFx0dGV4Q29vcmQ6IHZlcnRleC50ZXhDb29yZCxcblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gbWVzaDtcbn1cblxuLy8gZnVuY3Rpb24gY29vcmQyVG9Ud2dsVmVjMihjb29yZDogQ29vcmQyKTogQXJyYXk8bnVtYmVyPiB7XG4vLyBcdHJldHVybiBbY29vcmQueCwgY29vcmQueV07XG4vLyB9XG5mdW5jdGlvbiBjb29yZDNUb1R3Z2xWZWMzKGNvb3JkOiBDb29yZDMpOiBBcnJheTxudW1iZXI+IHtcblx0cmV0dXJuIFtjb29yZC54LCBjb29yZC55LCBjb29yZC56XTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtZXNoVG9XZWJnbEFycmF5cyhtZXNoOiBNZXNoKTogdHdnbC5BcnJheXMge1xuXHRyZXR1cm4ge1xuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRudW1Db21wb25lbnRzOiAzLFxuXHRcdFx0ZGF0YTogbWVzaC52ZXJ0aWNlc1xuXHRcdFx0XHQubWFwKHZlcnRleCA9PiB2ZXJ0ZXgucG9zaXRpb24pXG5cdFx0XHRcdC5tYXAoY29vcmQzVG9Ud2dsVmVjMylcblx0XHRcdFx0LnJlZHVjZSgoc29GYXIsIGN1cnJlbnQpID0+IHtcblx0XHRcdFx0XHRzb0Zhci5wdXNoKC4uLmN1cnJlbnQpO1xuXHRcdFx0XHRcdHJldHVybiBzb0Zhcjtcblx0XHRcdFx0fSwgW10pLFxuXHRcdH0sXG5cdFx0bm9ybWFsOiB7XG5cdFx0XHRudW1Db21wb25lbnRzOiAzLFxuXHRcdFx0ZGF0YTogbWVzaC52ZXJ0aWNlc1xuXHRcdFx0XHQubWFwKHZlcnRleCA9PiB2ZXJ0ZXgubm9ybWFsKVxuXHRcdFx0XHQubWFwKGNvb3JkM1RvVHdnbFZlYzMpXG5cdFx0XHRcdC5yZWR1Y2UoKHNvRmFyLCBjdXJyZW50KSA9PiB7XG5cdFx0XHRcdFx0c29GYXIucHVzaCguLi5jdXJyZW50KTtcblx0XHRcdFx0XHRyZXR1cm4gc29GYXI7XG5cdFx0XHRcdH0sIFtdKSxcblx0XHR9LFxuXHRcdHRleENvb3JkOiB7XG5cdFx0XHRudW1Db21wb25lbnRzOiAzLFxuXHRcdFx0ZGF0YTogbWVzaC52ZXJ0aWNlc1xuXHRcdFx0XHQubWFwKHZlcnRleCA9PiB2ZXJ0ZXgudGV4Q29vcmQpXG5cdFx0XHRcdC5tYXAoY29vcmQzVG9Ud2dsVmVjMylcblx0XHRcdFx0LnJlZHVjZSgoc29GYXIsIGN1cnJlbnQpID0+IHtcblx0XHRcdFx0XHRzb0Zhci5wdXNoKC4uLmN1cnJlbnQpO1xuXHRcdFx0XHRcdHJldHVybiBzb0Zhcjtcblx0XHRcdFx0fSwgW10pLFxuXHRcdH0sXG5cdFx0aW5kaWNlczogeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBtZXNoLmluZGljZXMgYXMgQXJyYXk8bnVtYmVyPiB9LFxuXHR9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Z1bmN0aW9ucy50cyIsImltcG9ydCB7IENvb3JkMiB9IGZyb20gXCIuL0Nvb3JkMlwiO1xuaW1wb3J0IHsgR2FtZU1vZGUgfSBmcm9tIFwiLi9HYW1lTW9kZVwiO1xuaW1wb3J0IHsgUGllY2UgfSBmcm9tIFwiLi9QaWVjZVwiO1xuaW1wb3J0IHsgd2FpdE1zLCByYW5nZSwgcmFuZG9tRWxlbWVudCB9IGZyb20gXCIuL2Z1bmN0aW9uc1wiO1xuaW1wb3J0ICogYXMgUmVuZGVyZXIgZnJvbSBcIi4vUmVuZGVyZXJcIjtcblxuZXhwb3J0IGNsYXNzIEJvYXJkIHtcblx0Z2FtZU1vZGU6IEdhbWVNb2RlO1xuXHRmcmFtZUNvcm91dGluZTogSXRlcmFibGVJdGVyYXRvcjx2b2lkPjtcblx0cGllY2VzOiBBcnJheTxQaWVjZSB8IHVuZGVmaW5lZD47XG5cdHF1ZXVlZFBpZWNlOiBQaWVjZTtcblx0cGlja2VkUGllY2U6IFBpZWNlIHwgdW5kZWZpbmVkO1xuXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnM6IHsgZ2FtZU1vZGU6IEdhbWVNb2RlIH0pIHtcblx0XHR0aGlzLmdhbWVNb2RlID0gb3B0aW9ucy5nYW1lTW9kZTtcblxuXHRcdHRoaXMuZnJhbWVDb3JvdXRpbmUgPSB0aGlzLm1ha2VGcmFtZUNvcm91dGluZSgpO1xuXHRcdHRoaXMucGlja2VkUGllY2UgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5waWVjZXMgPSBbXTtcblx0XHR0aGlzLnF1ZXVlZFBpZWNlID0gbmV3IFBpZWNlKHtcblx0XHRcdGNvbG9yOiB0aGlzLnJhbmRvbUNvbG9yKCksXG5cdFx0fSk7XG5cdFx0dGhpcy5xdWV1ZWRQaWVjZS5zZXRQaWNrZWQodHJ1ZSk7XG5cblx0XHRSZW5kZXJlci5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGV2ZW50ID0+IHtcblx0XHRcdGNvbnN0IGFzcGVjdCA9IFJlbmRlcmVyLmNhbnZhcy5jbGllbnRXaWR0aCAvIFJlbmRlcmVyLmNhbnZhcy5jbGllbnRIZWlnaHQ7XG5cdFx0XHRjb25zdCBib2FyZFdpZHRoID0gQm9hcmQuc2l6ZS54ICsgMjtcblx0XHRcdGNvbnN0IGJvYXJkSGVpZ2h0ID0gQm9hcmQuc2l6ZS55ICsgMjtcblx0XHRcdGNvbnN0IHZpc2libGVXaWR0aCA9IE1hdGgubWF4KGJvYXJkV2lkdGgsIGJvYXJkV2lkdGggKiBhc3BlY3QpO1xuXHRcdFx0Y29uc3QgdmlzaWJsZUhlaWdodCA9IE1hdGgubWF4KGJvYXJkSGVpZ2h0LCBib2FyZEhlaWdodCAvIGFzcGVjdCk7XG5cblx0XHRcdGNvbnN0IG1vdXNlV29ybGRDb29yZFggPVxuXHRcdFx0XHQoZXZlbnQub2Zmc2V0WCAvIFJlbmRlcmVyLmNhbnZhcy5jbGllbnRXaWR0aCAtIDAuNSkgKiB2aXNpYmxlV2lkdGg7XG5cdFx0XHRjb25zdCBtb3VzZVdvcmxkQ29vcmRZID1cblx0XHRcdFx0LShldmVudC5vZmZzZXRZIC8gUmVuZGVyZXIuY2FudmFzLmNsaWVudEhlaWdodCAtIDAuNSkgKiB2aXNpYmxlSGVpZ2h0O1xuXG5cdFx0XHRjb25zdCB4ID0gTWF0aC5mbG9vcihtb3VzZVdvcmxkQ29vcmRYICsgQm9hcmQuc2l6ZS54IC8gMik7XG5cdFx0XHRjb25zdCB5ID0gTWF0aC5mbG9vcihtb3VzZVdvcmxkQ29vcmRZICsgQm9hcmQuc2l6ZS55IC8gMik7XG5cblx0XHRcdGlmICh4ID49IDAgJiYgeCA8IEJvYXJkLnNpemUueCAmJiB5ID49IDAgJiYgeSA8IEJvYXJkLnNpemUueSkge1xuXHRcdFx0XHR0aGlzLnBpY2soQm9hcmQuY29vcmRUb0luZGV4KG5ldyBDb29yZDIoeyB4LCB5IH0pKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRzdGF0aWMgc2l6ZSA9IG5ldyBDb29yZDIoeyB4OiA0LCB5OiA0IH0pO1xuXHRzdGF0aWMgbnVtQ29sb3JzID0gMTM7XG5cblx0c3RhdGljIHh5VG9JbmRleCh4OiBudW1iZXIsIHk6IG51bWJlcikge1xuXHRcdHJldHVybiB4ICsgeSAqIEJvYXJkLnNpemUueDtcblx0fVxuXG5cdHN0YXRpYyBjb29yZFRvSW5kZXgoY29vcmQ6IENvb3JkMikge1xuXHRcdHJldHVybiBCb2FyZC54eVRvSW5kZXgoY29vcmQueCwgY29vcmQueSk7XG5cdH1cblxuXHRzdGF0aWMgaW5kZXhUb0Nvb3JkKGluZGV4OiBudW1iZXIpIHtcblx0XHRyZXR1cm4gbmV3IENvb3JkMih7XG5cdFx0XHR4OiBpbmRleCAlIEJvYXJkLnNpemUueCxcblx0XHRcdHk6IE1hdGguZmxvb3IoaW5kZXggLyBCb2FyZC5zaXplLngpLFxuXHRcdH0pO1xuXHR9XG5cblx0cGljayhpbmRleDogbnVtYmVyKSB7XG5cdFx0Y29uc3QgcGllY2UgPSB0aGlzLnBpZWNlc1tpbmRleF07XG5cblx0XHRpZiAocGllY2UgJiYgIXRoaXMucGlja2VkUGllY2UpIHtcblx0XHRcdHRoaXMucGlja2VkUGllY2UgPSBwaWVjZTtcblx0XHRcdHRoaXMucGlja2VkUGllY2Uuc2V0UGlja2VkKHRydWUpO1xuXHRcdH1cblx0fVxuXG5cdGFkZFBpZWNlKGNvbG9yOiBudW1iZXIpIHtcblx0XHRjb25zdCBwaWVjZUFkZE9yZGVyID0gQXJyYXkuZnJvbShcblx0XHRcdHJhbmdlKDAsIEJvYXJkLnNpemUueCAqIEJvYXJkLnNpemUueSksXG5cdFx0KS5zb3J0KChhLCBiKSA9PiB7XG5cdFx0XHQvLyBNZWFzc3VyZSBmcm9tIGNlbnRlci5cblx0XHRcdGNvbnN0IGNlbnRlciA9IG5ldyBDb29yZDIoe1xuXHRcdFx0XHR4OiAoQm9hcmQuc2l6ZS54IC0gMSkgLyAyLFxuXHRcdFx0XHR5OiAoQm9hcmQuc2l6ZS55IC0gMSkgLyAyLFxuXHRcdFx0fSk7XG5cdFx0XHQvLyBXaXRoIGEgc21hbGwgb2Zmc2V0IHRvIG1ha2UgaXQgZGV0ZXJtaW5pc3RpYy5cblx0XHRcdGNlbnRlci54ICs9IDAuMTtcblx0XHRcdGNlbnRlci54ICs9IDAuMjtcblxuXHRcdFx0Ly8gT3JkZXIgYnkgZGlzdGFuY2UuXG5cdFx0XHRjb25zdCBBID0gQ29vcmQyLmRpc3RhbmNlKEJvYXJkLmluZGV4VG9Db29yZChhKSwgY2VudGVyKTtcblx0XHRcdGNvbnN0IEIgPSBDb29yZDIuZGlzdGFuY2UoQm9hcmQuaW5kZXhUb0Nvb3JkKGIpLCBjZW50ZXIpO1xuXHRcdFx0cmV0dXJuIEEgLSBCO1xuXHRcdH0pO1xuXG5cdFx0Zm9yIChjb25zdCBpbmRleCBvZiBwaWVjZUFkZE9yZGVyKSB7XG5cdFx0XHRpZiAoIXRoaXMucGllY2VzW2luZGV4XSkge1xuXHRcdFx0XHR0aGlzLnBpZWNlc1tpbmRleF0gPSBuZXcgUGllY2Uoe1xuXHRcdFx0XHRcdGNvbG9yLFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmFuZG9tQ29sb3JGcm9tRXhpc3RpbmcoKSB7XG5cdFx0Y29uc3QgcG9zc2libGVDb2xvcnMgPSBBcnJheS5mcm9tKFxuXHRcdFx0bmV3IFNldCh0aGlzLnBpZWNlcy5maWx0ZXIocGllY2UgPT4gISFwaWVjZSkubWFwKHBpZWNlID0+IHBpZWNlIS5jb2xvcikpLFxuXHRcdCk7XG5cdFx0cmV0dXJuIHJhbmRvbUVsZW1lbnQocG9zc2libGVDb2xvcnMpO1xuXHR9XG5cblx0cmFuZG9tQ29sb3IoKSB7XG5cdFx0Y29uc3QgcG9zc2libGVDb2xvcnMgPSBBcnJheS5mcm9tKHJhbmdlKDAsIEJvYXJkLm51bUNvbG9ycykpO1xuXHRcdHJldHVybiByYW5kb21FbGVtZW50KHBvc3NpYmxlQ29sb3JzKSE7XG5cdH1cblxuXHQqbWFrZUZyYW1lQ29yb3V0aW5lKCk6IEl0ZXJhYmxlSXRlcmF0b3I8dm9pZD4ge1xuXHRcdGNvbnN0IGdhbWVGbG93Q29yb3V0aW5lID0gdGhpcy5nYW1lRmxvd0Nvcm91dGluZSgpO1xuXG5cdFx0Ly8gUnVuIHRoZSBnYW1lZmxvdyBhbmQgcGllY2VzIGNvcm91dGluZXMgY29uY3VycmVudGx5LlxuXHRcdGZvciAoOzspIHtcblx0XHRcdGNvbnN0IGRlbHRhVGltZTogbnVtYmVyID0geWllbGQ7XG5cblx0XHRcdGNvbnN0IHBpZWNlQ29yb3V0aW5lcyA9IHRoaXMucGllY2VzXG5cdFx0XHRcdC5maWx0ZXIocGllY2UgPT4gISFwaWVjZSlcblx0XHRcdFx0Lm1hcChwaWVjZSA9PiBwaWVjZSEuZnJhbWVDb3JvdXRpbmUpO1xuXG5cdFx0XHRjb25zdCBhbGxDb3JvdXRpbmVzID0gW1xuXHRcdFx0XHRnYW1lRmxvd0Nvcm91dGluZSxcblx0XHRcdFx0dGhpcy5xdWV1ZWRQaWVjZS5mcmFtZUNvcm91dGluZSxcblx0XHRcdFx0Li4ucGllY2VDb3JvdXRpbmVzLFxuXHRcdFx0XTtcblxuXHRcdFx0YWxsQ29yb3V0aW5lcy5mb3JFYWNoKGNvcm91dGluZSA9PiBjb3JvdXRpbmUubmV4dChkZWx0YVRpbWUpKTtcblx0XHR9XG5cdH1cblxuXHQqZ2FtZUZsb3dDb3JvdXRpbmUoKSB7XG5cdFx0Ly8gR2l2ZSB0aGUgcGxheWVyIGEgY2hhbmNlIHRvIHNlZSB0aGUgcXVldWVkIHBpZWNlLlxuXHRcdHlpZWxkKiB3YWl0TXMoMTAwMCk7XG5cblx0XHR5aWVsZCogdGhpcy5pbml0aWFsaXphdGlvbkNvcm91dGluZSgpO1xuXG5cdFx0Ly8gTm9ybWFsIGdhbWVwbGF5LlxuXHRcdGZvciAoOzspIHtcblx0XHRcdGlmICh0aGlzLnBpY2tlZFBpZWNlKSB7XG5cdFx0XHRcdC8vIEdpdmUgdGhlIHBsYXllciBhIGNoYW5jZSB0byBjb21wYXJlIHRoZSBwaWVjZXMgdmlzdWFsbHkuXG5cdFx0XHRcdHlpZWxkKiB3YWl0TXMoMTAwMCk7XG5cblx0XHRcdFx0aWYgKHRoaXMucGlja2VkUGllY2UuY29sb3IgPT0gdGhpcy5xdWV1ZWRQaWVjZS5jb2xvcikge1xuXHRcdFx0XHRcdC8vIFRoZSBwbGF5ZXIgZm91bmQgYSBwYWlyLlxuXG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBwaWNrZWQgcGllY2UgZnJvbSB0aGUgYm9hcmQuXG5cdFx0XHRcdFx0dGhpcy5waWVjZXMgPSB0aGlzLnBpZWNlcy5tYXAoXG5cdFx0XHRcdFx0XHRwaWVjZSA9PiAocGllY2UgIT0gdGhpcy5waWNrZWRQaWVjZSA/IHBpZWNlIDogdW5kZWZpbmVkKSxcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gTm90aWZ5IHRoZSBnYW1lIG1vZGUuXG5cdFx0XHRcdFx0dGhpcy5nYW1lTW9kZS5vblVubG9ja2VkUGFpcih0aGlzKTtcblxuXHRcdFx0XHRcdGlmICh0aGlzLnBpZWNlcy5maWx0ZXIocGllY2UgPT4gISFwaWVjZSkubGVuZ3RoIDwgMikge1xuXHRcdFx0XHRcdFx0dGhpcy5nYW1lTW9kZS5vbldpbih0aGlzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gUHVuaXNoIHBsYXllci5cblx0XHRcdFx0XHRjb25zdCBhZGRlZFBpZWNlU3VjY2Vzc2Z1bGx5ID0gdGhpcy5hZGRQaWVjZSh0aGlzLnF1ZXVlZFBpZWNlIS5jb2xvcik7XG5cblx0XHRcdFx0XHQvLyBEZXRlY3QgZ2FtZSBvdmVyLlxuXHRcdFx0XHRcdGlmICghYWRkZWRQaWVjZVN1Y2Nlc3NmdWxseSkge1xuXHRcdFx0XHRcdFx0dGhpcy5nYW1lTW9kZS5vbkdhbWVPdmVyKHRoaXMpO1xuXG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBDbGVhciBib2FyZCBhbmltYXRpb24uXG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRPRE86IFNob3VsZCBub3QgcXVldWUgdXAgc2FtZSBjb2xvciB0d2ljZSBpbiBhIHJvdy5cblx0XHRcdFx0Ly8gUXVldWUgdXAgYSBuZXcgcGllY2UuXG5cdFx0XHRcdHRoaXMucXVldWVkUGllY2UgPSBuZXcgUGllY2Uoe1xuXHRcdFx0XHRcdGNvbG9yOiB0aGlzLnJhbmRvbUNvbG9yRnJvbUV4aXN0aW5nKCkhLFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy5xdWV1ZWRQaWVjZS5zZXRQaWNrZWQodHJ1ZSk7XG5cblx0XHRcdFx0Ly8gUmVzZXQgdGhlIHBpY2tlZCBwaWVjZS5cblx0XHRcdFx0dGhpcy5waWNrZWRQaWVjZS5zZXRQaWNrZWQoZmFsc2UpO1xuXHRcdFx0XHR0aGlzLnBpY2tlZFBpZWNlID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0eWllbGQ7XG5cdFx0fVxuXHR9XG5cblx0KmluaXRpYWxpemF0aW9uQ29yb3V0aW5lKCkge1xuXHRcdC8vIEFkZCBpbml0aWFsIHBpZWNlcy5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IEJvYXJkLnNpemUueCAqIEJvYXJkLnNpemUueSAqIDAuNzU7ICsraSkge1xuXHRcdFx0Y29uc3QgY29sb3IgPSB0aGlzLnJhbmRvbUNvbG9yKCk7XG5cdFx0XHR0aGlzLmFkZFBpZWNlKGNvbG9yKTtcblx0XHRcdHlpZWxkKiB3YWl0TXMoMTAwKTtcblx0XHR9XG5cdH1cblxuXHRkcmF3KCkge1xuXHRcdFJlbmRlcmVyLmNsZWFyKCk7XG5cblx0XHR0aGlzLnF1ZXVlZFBpZWNlLmRyYXcoXG5cdFx0XHRDb29yZDIuYWRkKEJvYXJkLnNpemUuc2NhbGVkKDAuNSksIG5ldyBDb29yZDIoeyB4OiAwLjUsIHk6IDAuNSB9KSksXG5cdFx0KTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgQm9hcmQuc2l6ZS54ICogQm9hcmQuc2l6ZS55OyArK2kpIHtcblx0XHRcdGNvbnN0IHBpZWNlID0gdGhpcy5waWVjZXNbaV07XG5cdFx0XHRpZiAocGllY2UpIHtcblx0XHRcdFx0cGllY2UuZHJhdyhcblx0XHRcdFx0XHRDb29yZDIuYWRkKFxuXHRcdFx0XHRcdFx0Q29vcmQyLmFkZChCb2FyZC5pbmRleFRvQ29vcmQoaSksIEJvYXJkLnNpemUuc2NhbGVkKC0wLjUpKSxcblx0XHRcdFx0XHRcdG5ldyBDb29yZDIoeyB4OiAwLjUsIHk6IDAuNSB9KSxcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0JvYXJkLnRzIiwiaW1wb3J0IHsgQXBwIH0gZnJvbSBcIi4vQXBwXCI7XG5cbmNvbnN0IGFwcCA9IG5ldyBBcHAoKTtcblxudHJ5IHtcblx0YXBwLnN0YXJ0R2FtZSgpO1xufSBjYXRjaCAoZXJyb3IpIHtcblx0Y29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBzdGFydCBnYW1lLlwiLCBlcnJvcik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWFpbi50cyIsImltcG9ydCAqIGFzIFJlbmRlcmVyIGZyb20gXCIuL1JlbmRlcmVyXCI7XG5pbXBvcnQgeyBHYW1lTW9kZSB9IGZyb20gXCIuL0dhbWVNb2RlXCI7XG5pbXBvcnQgeyBHYW1lTW9kZTFwIH0gZnJvbSBcIi4vR2FtZU1vZGUxcFwiO1xuXG5leHBvcnQgY2xhc3MgQXBwIHtcblx0Z2FtZU1vZGU6IEdhbWVNb2RlO1xuXG5cdGxhc3RSZW5kZXJUaW1lOiBudW1iZXI7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5nYW1lTW9kZSA9IG5ldyBHYW1lTW9kZTFwKCk7XG5cdFx0dGhpcy5sYXN0UmVuZGVyVGltZSA9IDA7XG5cdH1cblxuXHRhc3luYyBzdGFydEdhbWUoKSB7XG5cdFx0Ly8gU2V0IHVwIHRoZSByZW5kZXJlci5cblx0XHR0aGlzLnN0YXJ0UmVuZGVyTG9vcCgpO1xuXHR9XG5cblx0c3RhcnRSZW5kZXJMb29wKCkge1xuXG5cdFx0UmVuZGVyZXIuaW5pdCgpO1xuXG5cdFx0Y29uc3QgcmVxdWVzdEFuaW1GcmFtZTogKFxuXHRcdFx0Y2FsbGJhY2s6IChjdXJyZW50VGltZTogbnVtYmVyKSA9PiB2b2lkLFxuXHRcdCkgPT4gdm9pZCA9ICgoKSA9PiB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHRcdCh3aW5kb3cgYXMgYW55KS53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdFx0KHdpbmRvdyBhcyBhbnkpLm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0XHQod2luZG93IGFzIGFueSkub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0XHQod2luZG93IGFzIGFueSkubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdFx0KGNhbGxiYWNrID0+IHtcblx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXHRcdH0pKCk7XG5cblx0XHQvLyBTdGFydCB0aGUgbG9vcC5cblx0XHQvLyBUT0RPOiBDb252ZXJ0IHRvIGdlbmVyYXRvcj9cblx0XHRjb25zdCBsb29wID0gKGN1cnJlbnRUaW1lOiBudW1iZXIpID0+IHtcblx0XHRcdHRoaXMucmVuZGVyKGN1cnJlbnRUaW1lKTtcblx0XHRcdHJlcXVlc3RBbmltRnJhbWUobG9vcCk7XG5cdFx0fTtcblx0XHRyZXF1ZXN0QW5pbUZyYW1lKGxvb3ApO1xuXHR9XG5cblx0cmVuZGVyKGN1cnJlbnRUaW1lOiBudW1iZXIpIHtcblx0XHQvLyBDYWxjdWxhdGUgZGVsdGEgdGltZS4gQ2FwIGl0IHRvIG1ha2UgZGVidWdnaW5nIGVhc2llci5cblx0XHRjb25zdCBkZWx0YVRpbWUgPSBNYXRoLm1pbihjdXJyZW50VGltZSAtIHRoaXMubGFzdFJlbmRlclRpbWUsIDEwMCk7XG5cdFx0dGhpcy5sYXN0UmVuZGVyVGltZSA9IGN1cnJlbnRUaW1lO1xuXG5cdFx0Ly8gLy8gRHJhdyB0aGUgYm9hcmQgYmFja2dyb3VuZC5cblx0XHQvLyB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDEpXCI7XG5cdFx0Ly8gdGhpcy5jb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKSk7XG5cblx0XHQvLyBCb2FyZHMgYW5kIGF2YXRhcnMuXG5cdFx0dGhpcy5nYW1lTW9kZS5mcmFtZUNvcm91dGluZS5uZXh0KGRlbHRhVGltZSk7XG5cdFx0dGhpcy5nYW1lTW9kZS5kcmF3KCk7XG5cblx0XHQvLyBGUFMgY291bnRlci5cblx0XHQvLyB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gXCJibGFja1wiO1xuXHRcdC8vIHRoaXMuY29udGV4dC5mb250ID0gXCIxNnB4IFBhbGF0aW5vXCI7XG5cdFx0Ly8gdGhpcy5jb250ZXh0LmZpbGxUZXh0KFwiRlBTOiBcIiArIE1hdGguZmxvb3IoMTAwMC9kZWx0YVRpbWUpLCAxMCwgMjApO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQXBwLnRzIiwiLyohXG4gKiBAbGljZW5zZSB0d2dsLmpzIDQuNC4wIENvcHlyaWdodCAoYykgMjAxNSwgR3JlZ2cgVGF2YXJlcyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogQXZhaWxhYmxlIHZpYSB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2dyZWdnbWFuL3R3Z2wuanMgZm9yIGRldGFpbHNcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widHdnbFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJ0d2dsXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA5KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29weUV4aXN0aW5nUHJvcGVydGllcyA9IGNvcHlFeGlzdGluZ1Byb3BlcnRpZXM7XG5leHBvcnRzLmNvcHlOYW1lZFByb3BlcnRpZXMgPSBjb3B5TmFtZWRQcm9wZXJ0aWVzO1xuZXhwb3J0cy5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuZXhwb3J0cy5pc1JlbmRlcmJ1ZmZlciA9IGlzUmVuZGVyYnVmZmVyO1xuZXhwb3J0cy5pc1NoYWRlciA9IGlzU2hhZGVyO1xuZXhwb3J0cy5pc1RleHR1cmUgPSBpc1RleHR1cmU7XG5leHBvcnRzLmlzU2FtcGxlciA9IGlzU2FtcGxlcjtcbmV4cG9ydHMud2FybiA9IGV4cG9ydHMuZXJyb3IgPSB2b2lkIDA7XG5cbnZhciBfZ2xvYmFsT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLypcbiAqIENvcHlyaWdodCAyMDE1LCBHcmVnZyBUYXZhcmVzLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuICogaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuICogZGlzdHJpYnV0aW9uLlxuICogICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiBHcmVnZyBUYXZhcmVzLiBub3IgdGhlIG5hbWVzIG9mIGhpc1xuICogY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qKlxuICogQ29weSBuYW1lZCBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gbmFtZXMgbmFtZXMgb2YgcHJvcGVydGllcyB0byBjb3B5XG4gKiBAcGFyYW0ge29iamVjdH0gc3JjIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtvYmplY3R9IGRzdCBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKi9cbmZ1bmN0aW9uIGNvcHlOYW1lZFByb3BlcnRpZXMobmFtZXMsIHNyYywgZHN0KSB7XG4gIG5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSBzcmNbbmFtZV07XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZHN0W25hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgZnJvbSBzb3VyY2UgdG8gZGVzdCBvbmx5IGlmIGEgbWF0Y2hpbmcga2V5IGlzIGluIGRlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCA/Pn0gc3JjIHRoZSBzb3VyY2VcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsID8+fSBkc3QgdGhlIGRlc3RcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHlFeGlzdGluZ1Byb3BlcnRpZXMoc3JjLCBkc3QpIHtcbiAgT2JqZWN0LmtleXMoZHN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoZHN0Lmhhc093blByb3BlcnR5KGtleSkgJiYgc3JjLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGVycm9yID0gX2dsb2JhbE9iamVjdC5kZWZhdWx0LmNvbnNvbGUgJiYgX2dsb2JhbE9iamVjdC5kZWZhdWx0LmNvbnNvbGUuZXJyb3IgJiYgdHlwZW9mIF9nbG9iYWxPYmplY3QuZGVmYXVsdC5jb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBfZ2xvYmFsT2JqZWN0LmRlZmF1bHQuY29uc29sZS5lcnJvci5iaW5kKF9nbG9iYWxPYmplY3QuZGVmYXVsdC5jb25zb2xlKSA6IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xudmFyIHdhcm4gPSBfZ2xvYmFsT2JqZWN0LmRlZmF1bHQuY29uc29sZSAmJiBfZ2xvYmFsT2JqZWN0LmRlZmF1bHQuY29uc29sZS53YXJuICYmIHR5cGVvZiBfZ2xvYmFsT2JqZWN0LmRlZmF1bHQuY29uc29sZS53YXJuID09PSBcImZ1bmN0aW9uXCIgPyBfZ2xvYmFsT2JqZWN0LmRlZmF1bHQuY29uc29sZS53YXJuLmJpbmQoX2dsb2JhbE9iamVjdC5kZWZhdWx0LmNvbnNvbGUpIDogZnVuY3Rpb24gKCkge307XG5leHBvcnRzLndhcm4gPSB3YXJuO1xudmFyIHJlcEJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNCdWZmZXIoZ2wsIHQpIHtcbiAgaWYgKCFyZXBCdWZmZXIpIHtcbiAgICByZXBCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgfVxuXG4gIHJldHVybiB0IGluc3RhbmNlb2YgcmVwQnVmZmVyLmNvbnN0cnVjdG9yO1xufVxuXG52YXIgcmVwUmVuZGVyYnVmZmVyO1xuXG5mdW5jdGlvbiBpc1JlbmRlcmJ1ZmZlcihnbCwgdCkge1xuICBpZiAoIXJlcFJlbmRlcmJ1ZmZlcikge1xuICAgIHJlcFJlbmRlcmJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICB9XG5cbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiByZXBSZW5kZXJidWZmZXIuY29uc3RydWN0b3I7XG59XG5cbnZhciByZXBTaGFkZXI7XG5cbmZ1bmN0aW9uIGlzU2hhZGVyKGdsLCB0KSB7XG4gIGlmICghcmVwU2hhZGVyKSB7XG4gICAgcmVwU2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICB9XG5cbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiByZXBTaGFkZXIuY29uc3RydWN0b3I7XG59XG5cbnZhciByZXBUZXh0dXJlO1xuXG5mdW5jdGlvbiBpc1RleHR1cmUoZ2wsIHQpIHtcbiAgaWYgKCFyZXBUZXh0dXJlKSB7XG4gICAgcmVwVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgfVxuXG4gIHJldHVybiB0IGluc3RhbmNlb2YgcmVwVGV4dHVyZS5jb25zdHJ1Y3Rvcjtcbn1cblxudmFyIHJlcFNhbXBsZXI7XG5cbmZ1bmN0aW9uIGlzU2FtcGxlcihnbCwgdCkge1xuICBpZiAoIXJlcFNhbXBsZXIpIHtcbiAgICBpZiAoZ2wuY3JlYXRlU2FtcGxlcikge1xuICAgICAgcmVwU2FtcGxlciA9IGdsLmNyZWF0ZVNhbXBsZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBpdCBjYW4ndCBiZSBhIHNhbXBsZXIgaWYgdGhpcyBpcyBub3QgV2ViR0wyXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiByZXBTYW1wbGVyLmNvbnN0cnVjdG9yO1xufVxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZ2V0R0xUeXBlRm9yVHlwZWRBcnJheSA9IGdldEdMVHlwZUZvclR5cGVkQXJyYXk7XG5leHBvcnRzLmdldEdMVHlwZUZvclR5cGVkQXJyYXlUeXBlID0gZ2V0R0xUeXBlRm9yVHlwZWRBcnJheVR5cGU7XG5leHBvcnRzLmdldFR5cGVkQXJyYXlUeXBlRm9yR0xUeXBlID0gZ2V0VHlwZWRBcnJheVR5cGVGb3JHTFR5cGU7XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSB2b2lkIDA7XG5cbnZhciBfZ2xvYmFsT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLypcbiAqIENvcHlyaWdodCAyMDE1LCBHcmVnZyBUYXZhcmVzLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuICogaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuICogZGlzdHJpYnV0aW9uLlxuICogICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiBHcmVnZyBUYXZhcmVzLiBub3IgdGhlIG5hbWVzIG9mIGhpc1xuICogY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qKlxuICogTG93IGxldmVsIHNoYWRlciB0eXBlZCBhcnJheSByZWxhdGVkIGZ1bmN0aW9uc1xuICpcbiAqIFlvdSBzaG91bGQgZ2VuZXJhbGx5IG5vdCBuZWVkIHRvIHVzZSB0aGVzZSBmdW5jdGlvbnMuIFRoZXkgYXJlIHByb3ZpZGVkXG4gKiBmb3IgdGhvc2UgY2FzZXMgd2hlcmUgeW91J3JlIGRvaW5nIHNvbWV0aGluZyBvdXQgb2YgdGhlIG9yZGluYXJ5XG4gKiBhbmQgeW91IG5lZWQgbG93ZXIgbGV2ZWwgYWNjZXNzLlxuICpcbiAqIEZvciBiYWNrd2FyZCBjb21wYXRpYmlseSB0aGV5IGFyZSBhdmFpbGFibGUgYXQgYm90aCBgdHdnbC50eXBlZEFycmF5YCBhbmQgYHR3Z2xgXG4gKiBpdHNlbGZcbiAqXG4gKiBTZWUge0BsaW5rIG1vZHVsZTp0d2dsfSBmb3IgY29yZSBmdW5jdGlvbnNcbiAqXG4gKiBAbW9kdWxlIHR3Z2wvdHlwZWRBcnJheVxuICovXG4vLyBtYWtlIHN1cmUgd2UgZG9uJ3Qgc2VlIGEgZ2xvYmFsIGdsXG52YXIgZ2wgPSB1bmRlZmluZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyogRGF0YVR5cGUgKi9cblxudmFyIEJZVEUgPSAweDE0MDA7XG52YXIgVU5TSUdORURfQllURSA9IDB4MTQwMTtcbnZhciBTSE9SVCA9IDB4MTQwMjtcbnZhciBVTlNJR05FRF9TSE9SVCA9IDB4MTQwMztcbnZhciBJTlQgPSAweDE0MDQ7XG52YXIgVU5TSUdORURfSU5UID0gMHgxNDA1O1xudmFyIEZMT0FUID0gMHgxNDA2O1xudmFyIFVOU0lHTkVEX1NIT1JUXzRfNF80XzQgPSAweDgwMzM7XG52YXIgVU5TSUdORURfU0hPUlRfNV81XzVfMSA9IDB4ODAzNDtcbnZhciBVTlNJR05FRF9TSE9SVF81XzZfNSA9IDB4ODM2MztcbnZhciBIQUxGX0ZMT0FUID0gMHgxNDBCO1xudmFyIFVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFViA9IDB4ODM2ODtcbnZhciBVTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWID0gMHg4QzNCO1xudmFyIFVOU0lHTkVEX0lOVF81XzlfOV85X1JFViA9IDB4OEMzRTtcbnZhciBGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVYgPSAweDhEQUQ7XG52YXIgVU5TSUdORURfSU5UXzI0XzggPSAweDg0RkE7XG52YXIgZ2xUeXBlVG9UeXBlZEFycmF5ID0ge307XG57XG4gIHZhciB0dCA9IGdsVHlwZVRvVHlwZWRBcnJheTtcbiAgdHRbQllURV0gPSBJbnQ4QXJyYXk7XG4gIHR0W1VOU0lHTkVEX0JZVEVdID0gVWludDhBcnJheTtcbiAgdHRbU0hPUlRdID0gSW50MTZBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRdID0gVWludDE2QXJyYXk7XG4gIHR0W0lOVF0gPSBJbnQzMkFycmF5O1xuICB0dFtVTlNJR05FRF9JTlRdID0gVWludDMyQXJyYXk7XG4gIHR0W0ZMT0FUXSA9IEZsb2F0MzJBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRfNF80XzRfNF0gPSBVaW50MTZBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRfNV81XzVfMV0gPSBVaW50MTZBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRfNV82XzVdID0gVWludDE2QXJyYXk7XG4gIHR0W0hBTEZfRkxPQVRdID0gVWludDE2QXJyYXk7XG4gIHR0W1VOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVl0gPSBVaW50MzJBcnJheTtcbiAgdHRbVU5TSUdORURfSU5UXzEwRl8xMUZfMTFGX1JFVl0gPSBVaW50MzJBcnJheTtcbiAgdHRbVU5TSUdORURfSU5UXzVfOV85XzlfUkVWXSA9IFVpbnQzMkFycmF5O1xuICB0dFtGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVZdID0gVWludDMyQXJyYXk7XG4gIHR0W1VOU0lHTkVEX0lOVF8yNF84XSA9IFVpbnQzMkFycmF5O1xufVxuLyoqXG4gKiBHZXQgdGhlIEdMIHR5cGUgZm9yIGEgdHlwZWRBcnJheVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IHR5cGVkQXJyYXkgYSB0eXBlZEFycmF5XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBHTCB0eXBlIGZvciBhcnJheS4gRm9yIGV4YW1wbGUgcGFzcyBpbiBhbiBgSW50OEFycmF5YCBhbmQgYGdsLkJZVEVgIHdpbGxcbiAqICAgYmUgcmV0dXJuZWQuIFBhc3MgaW4gYSBgVWludDMyQXJyYXlgIGFuZCBgZ2wuVU5TSUdORURfSU5UYCB3aWxsIGJlIHJldHVybmVkXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdHlwZWRBcnJheVxuICovXG5cbmZ1bmN0aW9uIGdldEdMVHlwZUZvclR5cGVkQXJyYXkodHlwZWRBcnJheSkge1xuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSkge1xuICAgIHJldHVybiBCWVRFO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBVTlNJR05FRF9CWVRFO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICByZXR1cm4gVU5TSUdORURfQllURTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkpIHtcbiAgICByZXR1cm4gU0hPUlQ7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgIHJldHVybiBVTlNJR05FRF9TSE9SVDtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHtcbiAgICByZXR1cm4gSU5UO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICByZXR1cm4gVU5TSUdORURfSU5UO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgcmV0dXJuIEZMT0FUO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIHRocm93IFwidW5zdXBwb3J0ZWQgdHlwZWQgYXJyYXkgdHlwZVwiO1xufVxuLyoqXG4gKiBHZXQgdGhlIEdMIHR5cGUgZm9yIGEgdHlwZWRBcnJheSB0eXBlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld1R5cGV9IHR5cGVkQXJyYXlUeXBlIGEgdHlwZWRBcnJheSBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgR0wgdHlwZSBmb3IgdHlwZS4gRm9yIGV4YW1wbGUgcGFzcyBpbiBgSW50OEFycmF5YCBhbmQgYGdsLkJZVEVgIHdpbGxcbiAqICAgYmUgcmV0dXJuZWQuIFBhc3MgaW4gYFVpbnQzMkFycmF5YCBhbmQgYGdsLlVOU0lHTkVEX0lOVGAgd2lsbCBiZSByZXR1cm5lZFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3R5cGVkQXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEdMVHlwZUZvclR5cGVkQXJyYXlUeXBlKHR5cGVkQXJyYXlUeXBlKSB7XG4gIGlmICh0eXBlZEFycmF5VHlwZSA9PT0gSW50OEFycmF5KSB7XG4gICAgcmV0dXJuIEJZVEU7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIFVOU0lHTkVEX0JZVEU7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBVaW50OENsYW1wZWRBcnJheSkge1xuICAgIHJldHVybiBVTlNJR05FRF9CWVRFO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5VHlwZSA9PT0gSW50MTZBcnJheSkge1xuICAgIHJldHVybiBTSE9SVDtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IFVpbnQxNkFycmF5KSB7XG4gICAgcmV0dXJuIFVOU0lHTkVEX1NIT1JUO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXG4gIGlmICh0eXBlZEFycmF5VHlwZSA9PT0gSW50MzJBcnJheSkge1xuICAgIHJldHVybiBJTlQ7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBVaW50MzJBcnJheSkge1xuICAgIHJldHVybiBVTlNJR05FRF9JTlQ7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBGbG9hdDMyQXJyYXkpIHtcbiAgICByZXR1cm4gRkxPQVQ7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgdGhyb3cgXCJ1bnN1cHBvcnRlZCB0eXBlZCBhcnJheSB0eXBlXCI7XG59XG4vKipcbiAqIEdldCB0aGUgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IgZm9yIGEgZ2l2ZW4gR0wgdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgdGhlIEdMIHR5cGUuIChlZzogYGdsLlVOU0lHTkVEX0lOVGApXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gdGhlIGNvbnN0cnVjdG9yIGZvciBhIHRoZSBjb3JyZXNwb25kaW5nIHR5cGVkIGFycmF5LiAoZWcuIGBVaW50MzJBcnJheWApLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3R5cGVkQXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFR5cGVkQXJyYXlUeXBlRm9yR0xUeXBlKHR5cGUpIHtcbiAgdmFyIENUT1IgPSBnbFR5cGVUb1R5cGVkQXJyYXlbdHlwZV07XG5cbiAgaWYgKCFDVE9SKSB7XG4gICAgdGhyb3cgXCJ1bmtub3duIGdsIHR5cGVcIjtcbiAgfVxuXG4gIHJldHVybiBDVE9SO1xufVxuXG52YXIgaXNBcnJheUJ1ZmZlciA9IF9nbG9iYWxPYmplY3QuZGVmYXVsdC5TaGFyZWRBcnJheUJ1ZmZlciA/IGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJPclNoYXJlZEFycmF5QnVmZmVyKGEpIHtcbiAgcmV0dXJuIGEgJiYgYS5idWZmZXIgJiYgKGEuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgYS5idWZmZXIgaW5zdGFuY2VvZiBfZ2xvYmFsT2JqZWN0LmRlZmF1bHQuU2hhcmVkQXJyYXlCdWZmZXIpO1xufSA6IGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIoYSkge1xuICByZXR1cm4gYSAmJiBhLmJ1ZmZlciAmJiBhLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufTtcbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIGdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbj8gZ2xvYmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbjogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG5leHBvcnRzLmRlZmF1bHQgPSBnbG9iYWw7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNyb3NzID0gY3Jvc3M7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLmRpc3RhbmNlU3EgPSBkaXN0YW5jZVNxO1xuZXhwb3J0cy5kaXZpZGUgPSBkaXZpZGU7XG5leHBvcnRzLmRpdlNjYWxhciA9IGRpdlNjYWxhcjtcbmV4cG9ydHMuZG90ID0gZG90O1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xuZXhwb3J0cy5sZW5ndGhTcSA9IGxlbmd0aFNxO1xuZXhwb3J0cy5tdWxTY2FsYXIgPSBtdWxTY2FsYXI7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5zZXREZWZhdWx0VHlwZSA9IHNldERlZmF1bHRUeXBlO1xuZXhwb3J0cy5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMTUsIEdyZWdnIFRhdmFyZXMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4gKiBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4gKiBkaXN0cmlidXRpb24uXG4gKiAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdyZWdnIFRhdmFyZXMuIG5vciB0aGUgbmFtZXMgb2YgaGlzXG4gKiBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuLyoqXG4gKlxuICogVmVjMyBtYXRoIG1hdGggZnVuY3Rpb25zLlxuICpcbiAqIEFsbW9zdCBhbGwgZnVuY3Rpb25zIHRha2UgYW4gb3B0aW9uYWwgYGRzdGAgYXJndW1lbnQuIElmIGl0IGlzIG5vdCBwYXNzZWQgaW4gdGhlXG4gKiBmdW5jdGlvbnMgd2lsbCBjcmVhdGUgYSBuZXcgVmVjMy4gSW4gb3RoZXIgd29yZHMgeW91IGNhbiBkbyB0aGlzXG4gKlxuICogICAgIHZhciB2ID0gdjMuY3Jvc3ModjEsIHYyKTsgIC8vIENyZWF0ZXMgYSBuZXcgVmVjMyB3aXRoIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHYxIHggdjIuXG4gKlxuICogb3JcbiAqXG4gKiAgICAgdmFyIHYzID0gdjMuY3JlYXRlKCk7XG4gKiAgICAgdjMuY3Jvc3ModjEsIHYyLCB2KTsgIC8vIFB1dHMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdjEgeCB2MiBpbiB2XG4gKlxuICogVGhlIGZpcnN0IHN0eWxlIGlzIG9mdGVuIGVhc2llciBidXQgZGVwZW5kaW5nIG9uIHdoZXJlIGl0J3MgdXNlZCBpdCBnZW5lcmF0ZXMgZ2FyYmFnZSB3aGVyZVxuICogYXMgdGhlcmUgaXMgYWxtb3N0IG5ldmVyIGFsbG9jYXRpb24gd2l0aCB0aGUgc2Vjb25kIHN0eWxlLlxuICpcbiAqIEl0IGlzIGFsd2F5cyBzYXZlIHRvIHBhc3MgYW55IHZlY3RvciBhcyB0aGUgZGVzdGluYXRpb24uIFNvIGZvciBleGFtcGxlXG4gKlxuICogICAgIHYzLmNyb3NzKHYxLCB2MiwgdjEpOyAgLy8gUHV0cyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2MSB4IHYyIGluIHYxXG4gKlxuICogQG1vZHVsZSB0d2dsL3YzXG4gKi9cbnZhciBWZWNUeXBlID0gRmxvYXQzMkFycmF5O1xuLyoqXG4gKiBBIEphdmFTY3JpcHQgYXJyYXkgd2l0aCAzIHZhbHVlcyBvciBhIEZsb2F0MzJBcnJheSB3aXRoIDMgdmFsdWVzLlxuICogV2hlbiBjcmVhdGVkIGJ5IHRoZSBsaWJyYXJ5IHdpbGwgY3JlYXRlIHRoZSBkZWZhdWx0IHR5cGUgd2hpY2ggaXMgYEZsb2F0MzJBcnJheWBcbiAqIGJ1dCBjYW4gYmUgc2V0IGJ5IGNhbGxpbmcge0BsaW5rIG1vZHVsZTp0d2dsL3YzLnNldERlZmF1bHRUeXBlfS5cbiAqIEB0eXBlZGVmIHsobnVtYmVyW118RmxvYXQzMkFycmF5KX0gVmVjM1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIHRoaXMgbGlicmFyeSBjcmVhdGVzIGZvciBhIFZlYzNcbiAqIEBwYXJhbSB7Y29uc3RydWN0b3J9IGN0b3IgdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZS4gRWl0aGVyIGBGbG9hdDMyQXJyYXlgIG9yIGBBcnJheWBcbiAqIEByZXR1cm4ge2NvbnN0cnVjdG9yfSBwcmV2aW91cyBjb25zdHJ1Y3RvciBmb3IgVmVjM1xuICovXG5cbmZ1bmN0aW9uIHNldERlZmF1bHRUeXBlKGN0b3IpIHtcbiAgdmFyIG9sZFR5cGUgPSBWZWNUeXBlO1xuICBWZWNUeXBlID0gY3RvcjtcbiAgcmV0dXJuIG9sZFR5cGU7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB2ZWMzOyBtYXkgYmUgY2FsbGVkIHdpdGggeCwgeSwgeiB0byBzZXQgaW5pdGlhbCB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtWZWMzfSB0aGUgY3JlYXRlZCB2ZWN0b3JcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlKHgsIHksIHopIHtcbiAgdmFyIGRzdCA9IG5ldyBWZWNUeXBlKDMpO1xuXG4gIGlmICh4KSB7XG4gICAgZHN0WzBdID0geDtcbiAgfVxuXG4gIGlmICh5KSB7XG4gICAgZHN0WzFdID0geTtcbiAgfVxuXG4gIGlmICh6KSB7XG4gICAgZHN0WzJdID0gejtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlY3RvcnM7IGFzc3VtZXMgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gYWRkKGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IGFbMF0gKyBiWzBdO1xuICBkc3RbMV0gPSBhWzFdICsgYlsxXTtcbiAgZHN0WzJdID0gYVsyXSArIGJbMl07XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFN1YnRyYWN0cyB0d28gdmVjdG9ycy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcbiAgZHN0WzBdID0gYVswXSAtIGJbMF07XG4gIGRzdFsxXSA9IGFbMV0gLSBiWzFdO1xuICBkc3RbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gb24gdHdvIHZlY3RvcnMuXG4gKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdCwgcmV0dXJuc1xuICogKDEgLSB0KSAqIGEgKyB0ICogYi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IEludGVycG9sYXRpb24gY29lZmZpY2llbnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC4uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlcnAoYSwgYiwgdCwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcbiAgZHN0WzBdID0gKDEgLSB0KSAqIGFbMF0gKyB0ICogYlswXTtcbiAgZHN0WzFdID0gKDEgLSB0KSAqIGFbMV0gKyB0ICogYlsxXTtcbiAgZHN0WzJdID0gKDEgLSB0KSAqIGFbMl0gKyB0ICogYlsyXTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogTXV0aXBsaWVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gayBUaGUgc2NhbGFyLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gZHN0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBtdWxTY2FsYXIodiwgaywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcbiAgZHN0WzBdID0gdlswXSAqIGs7XG4gIGRzdFsxXSA9IHZbMV0gKiBrO1xuICBkc3RbMl0gPSB2WzJdICogaztcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogRGl2aWRlcyBhIHZlY3RvciBieSBhIHNjYWxhci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGsgVGhlIHNjYWxhci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGRzdC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gZGl2U2NhbGFyKHYsIGssIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IHZbMF0gLyBrO1xuICBkc3RbMV0gPSB2WzFdIC8gaztcbiAgZHN0WzJdID0gdlsyXSAvIGs7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzOyBhc3N1bWVzIGJvdGggdmVjdG9ycyBoYXZlXG4gKiB0aHJlZSBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBiIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHZlY3RvciBhIGNyb3NzIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyb3NzKGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIHZhciB0MSA9IGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl07XG4gIHZhciB0MiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIGRzdFswXSA9IGFbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV07XG4gIGRzdFsxXSA9IHQxO1xuICBkc3RbMl0gPSB0MjtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzOyBhc3N1bWVzIGJvdGggdmVjdG9ycyBoYXZlXG4gKiB0aHJlZSBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBiIE9wZXJhbmQgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBkb3QgcHJvZHVjdFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IHZlY3Rvci5cbiAqIEByZXR1cm4ge251bWJlcn0gbGVuZ3RoIG9mIHZlY3Rvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gbGVuZ3RoKHYpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdICsgdlsyXSAqIHZbMl0pO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgdmVjdG9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlbmd0aFNxKHYpIHtcbiAgcmV0dXJuIHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0gKyB2WzJdICogdlsyXTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgZHggPSBhWzBdIC0gYlswXTtcbiAgdmFyIGR5ID0gYVsxXSAtIGJbMV07XG4gIHZhciBkeiA9IGFbMl0gLSBiWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBkaXN0YW5jZVNxKGEsIGIpIHtcbiAgdmFyIGR4ID0gYVswXSAtIGJbMF07XG4gIHZhciBkeSA9IGFbMV0gLSBiWzFdO1xuICB2YXIgZHogPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcbn1cbi8qKlxuICogRGl2aWRlcyBhIHZlY3RvciBieSBpdHMgRXVjbGlkZWFuIGxlbmd0aCBhbmQgcmV0dXJucyB0aGUgcXVvdGllbnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgVGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSBub3JtYWxpemVkIHZlY3Rvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKGEsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIHZhciBsZW5TcSA9IGFbMF0gKiBhWzBdICsgYVsxXSAqIGFbMV0gKyBhWzJdICogYVsyXTtcbiAgdmFyIGxlbiA9IE1hdGguc3FydChsZW5TcSk7XG5cbiAgaWYgKGxlbiA+IDAuMDAwMDEpIHtcbiAgICBkc3RbMF0gPSBhWzBdIC8gbGVuO1xuICAgIGRzdFsxXSA9IGFbMV0gLyBsZW47XG4gICAgZHN0WzJdID0gYVsyXSAvIGxlbjtcbiAgfSBlbHNlIHtcbiAgICBkc3RbMF0gPSAwO1xuICAgIGRzdFsxXSA9IDA7XG4gICAgZHN0WzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIE5lZ2F0ZXMgYSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IC12LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBuZWdhdGUodiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcbiAgZHN0WzBdID0gLXZbMF07XG4gIGRzdFsxXSA9IC12WzFdO1xuICBkc3RbMl0gPSAtdlsyXTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ29waWVzIGEgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC4uXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBBIGNvcHkgb2Ygdi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gY29weSh2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuICBkc3RbMF0gPSB2WzBdO1xuICBkc3RbMV0gPSB2WzFdO1xuICBkc3RbMl0gPSB2WzJdO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC4uXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBUaGUgdmVjdG9yIG9mIHByb2R1Y3RzIG9mIGVudHJpZXMgb2YgYSBhbmRcbiAqICAgICBiLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseShhLCBiLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuICBkc3RbMF0gPSBhWzBdICogYlswXTtcbiAgZHN0WzFdID0gYVsxXSAqIGJbMV07XG4gIGRzdFsyXSA9IGFbMl0gKiBiWzJdO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC4uXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBUaGUgdmVjdG9yIG9mIHF1b3RpZW50cyBvZiBlbnRyaWVzIG9mIGEgYW5kXG4gKiAgICAgYi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5cblxuZnVuY3Rpb24gZGl2aWRlKGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG4gIGRzdFswXSA9IGFbMF0gLyBiWzBdO1xuICBkc3RbMV0gPSBhWzFdIC8gYlsxXTtcbiAgZHN0WzJdID0gYVsyXSAvIGJbMl07XG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5pc1dlYkdMMSA9IGlzV2ViR0wxO1xuZXhwb3J0cy5pc1dlYkdMMiA9IGlzV2ViR0wyO1xuZXhwb3J0cy5nbEVudW1Ub1N0cmluZyA9IHZvaWQgMDtcblxuLypcbiAqIENvcHlyaWdodCAyMDE3LCBHcmVnZyBUYXZhcmVzLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuICogaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuICogZGlzdHJpYnV0aW9uLlxuICogICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiBHcmVnZyBUYXZhcmVzLiBub3IgdGhlIG5hbWVzIG9mIGhpc1xuICogY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qKlxuICogR2V0cyB0aGUgZ2wgdmVyc2lvbiBhcyBhIG51bWJlclxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHZlcnNpb24gb2YgZ2xcbiAqL1xuLy9mdW5jdGlvbiBnZXRWZXJzaW9uQXNOdW1iZXIoZ2wpIHtcbi8vICByZXR1cm4gcGFyc2VGbG9hdChnbC5nZXRQYXJhbWV0ZXIoZ2wuVkVSU0lPTikuc3Vic3RyKDYpKTtcbi8vfVxuXG4vKipcbiAqIENoZWNrIGlmIGNvbnRleHQgaXMgV2ViR0wgMi4wXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEByZXR1cm4ge2Jvb2x9IHRydWUgaWYgaXQncyBXZWJHTCAyLjBcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5mdW5jdGlvbiBpc1dlYkdMMihnbCkge1xuICAvLyBUaGlzIGlzIHRoZSBjb3JyZWN0IGNoZWNrIGJ1dCBpdCdzIHNsb3dcbiAgLy8gIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuVkVSU0lPTikuaW5kZXhPZihcIldlYkdMIDIuMFwiKSA9PT0gMDtcbiAgLy8gVGhpcyBtaWdodCBhbHNvIGJlIHRoZSBjb3JyZWN0IGNoZWNrIGJ1dCBJJ20gYXNzdW1pbmcgaXQncyBzbG93LWlzaFxuICAvLyByZXR1cm4gZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICByZXR1cm4gISFnbC50ZXhTdG9yYWdlMkQ7XG59XG4vKipcbiAqIENoZWNrIGlmIGNvbnRleHQgaXMgV2ViR0wgMS4wXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEByZXR1cm4ge2Jvb2x9IHRydWUgaWYgaXQncyBXZWJHTCAxLjBcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cblxuZnVuY3Rpb24gaXNXZWJHTDEoZ2wpIHtcbiAgLy8gVGhpcyBpcyB0aGUgY29ycmVjdCBjaGVjayBidXQgaXQncyBzbG93XG4gIC8vIGNvbnN0IHZlcnNpb24gPSBnZXRWZXJzaW9uQXNOdW1iZXIoZ2wpO1xuICAvLyByZXR1cm4gdmVyc2lvbiA8PSAxLjAgJiYgdmVyc2lvbiA+IDAuMDsgIC8vIGJlY2F1c2UgYXMgb2YgMjAxNi81IEVkZ2UgcmV0dXJucyAwLjk2XG4gIC8vIFRoaXMgbWlnaHQgYWxzbyBiZSB0aGUgY29ycmVjdCBjaGVjayBidXQgSSdtIGFzc3VtaW5nIGl0J3Mgc2xvdy1pc2hcbiAgLy8gcmV0dXJuIGdsIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICByZXR1cm4gIWdsLnRleFN0b3JhZ2UyRDtcbn1cbi8qKlxuICogR2V0cyBhIHN0cmluZyBmb3IgV2ViR0wgZW51bVxuICpcbiAqIE5vdGU6IFNldmVyYWwgZW51bXMgYXJlIHRoZSBzYW1lLiBXaXRob3V0IG1vcmVcbiAqIGNvbnRleHQgKHdoaWNoIGZ1bmN0aW9uKSBpdCdzIGltcG9zc2libGUgdG8gYWx3YXlzXG4gKiBnaXZlIHRoZSBjb3JyZWN0IGVudW0uIEFzIGl0IGlzLCBmb3IgbWF0Y2hpbmcgdmFsdWVzXG4gKiBpdCBnaXZlcyBhbGwgZW51bXMuIENoZWNraW5nIHRoZSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0XG4gKiB0aGF0IG1lYW5zXG4gKlxuICogICAgICAwICAgICA9IFpFUk8gfCBQT0lOVCB8IE5PTkUgfCBOT19FUlJPUlxuICogICAgICAxICAgICA9IE9ORSB8IExJTkVTIHwgU1lOQ19GTFVTSF9DT01NQU5EU19CSVRcbiAqICAgICAgMzI3NzcgPSBCTEVORF9FUVVBVElPTl9SR0IgfCBCTEVORF9FUVVBVElPTl9SR0JcbiAqICAgICAgMzY2NjIgPSBDT1BZX1JFQURfQlVGRkVSIHwgQ09QWV9SRUFEX0JVRkZFUl9CSU5ESU5HXG4gKiAgICAgIDM2NjYzID0gQ09QWV9XUklURV9CVUZGRVIgfCBDT1BZX1dSSVRFX0JVRkZFUl9CSU5ESU5HXG4gKiAgICAgIDM2MDA2ID0gRlJBTUVCVUZGRVJfQklORElORyB8IERSQVdfRlJBTUVCVUZGRVJfQklORElOR1xuICpcbiAqIEl0J3MgYWxzbyBub3QgdXNlZnVsIGZvciBiaXRzIHJlYWxseSB1bmxlc3MgeW91IHBhc3MgaW4gaW5kaXZpZHVhbCBiaXRzLlxuICogSW4gb3RoZXIgd29yZHNcbiAqXG4gKiAgICAgY29uc3QgYml0cyA9IGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUO1xuICogICAgIHR3Z2wuZ2xFbnVtVG9TdHJpbmcoZ2wsIGJpdHMpOyAgLy8gbm90IGdvaW5nIHRvIHdvcmtcbiAqXG4gKiBOb3RlIHRoYXQgc29tZSBlbnVtcyBvbmx5IGV4aXN0IG9uIGV4dGVuc2lvbnMuIElmIHlvdVxuICogd2FudCB0aGVtIHRvIHNob3cgdXAgeW91IG5lZWQgdG8gcGFzcyB0aGUgZXh0ZW5zaW9uIGF0IGxlYXN0XG4gKiBvbmNlLiBGb3IgZXhhbXBsZVxuICpcbiAqICAgICBjb25zdCBleHQgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjYCk7XG4gKiAgICAgaWYgKGV4dCkge1xuICogICAgICAgIHR3Z2wuZ2xFbnVtVG9TdHJpbmcoZXh0LCAwKTsgIC8vIGp1c3QgcHJpbWUgdGhlIGZ1bmN0aW9uXG4gKlxuICogICAgICAgIC4ubGF0ZXIuLlxuICpcbiAqICAgICAgICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IGV4dC5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xuICogICAgICAgIGNvbnNvbGUubG9nKHR3Z2wuZ2xFbnVtVG9TdHJpbmcoZ2wsIGludGVybmFsRm9ybWF0KSk7XG4gKlxuICogTm90aWNlIEkgZGlkbid0IGhhdmUgdG8gcGFzcyB0aGUgZXh0ZW5zaW9uIHRoZSBzZWNvbmQgdGltZS4gVGhpcyBtZWFuc1xuICogeW91IGNhbiBoYXZlIHBsYWNlIHRoYXQgZ2VuZXJpY2FsbHkgZ2V0cyBhbiBlbnVtIGZvciB0ZXh0dXJlIGZvcm1hdHMgZm9yIGV4YW1wbGUuXG4gKiBhbmQgYXMgbG9uZyBhcyB5b3UgcHJpbWVkIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBleHRlbnNpb25zXG4gKlxuICogSWYgeW91J3JlIHVzaW5nIGB0d2dsLmFkZEV4dGVuc2lvbnNUb0NvbnRleHRgIHRvIGVuYWJsZSB5b3VyIGV4dGVuc2lvbnNcbiAqIHRoZW4gdHdnbCB3aWxsIGF1dG9tYXRpY2FsbHkgZ2V0IHRoZSBleHRlbnNpb24ncyBlbnVtcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dHxFeHRlbnNpb259IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0IG9yIGFueSBleHRlbnNpb24gb2JqZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdGhlIHZhbHVlIG9mIHRoZSBlbnVtIHlvdSB3YW50IHRvIGxvb2sgdXAuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG5cbnZhciBnbEVudW1Ub1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhhdmVFbnVtc0ZvclR5cGUgPSB7fTtcbiAgdmFyIGVudW1zID0ge307XG5cbiAgZnVuY3Rpb24gYWRkRW51bXMoZ2wpIHtcbiAgICB2YXIgdHlwZSA9IGdsLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICBpZiAoIWhhdmVFbnVtc0ZvclR5cGVbdHlwZV0pIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBnbCkge1xuICAgICAgICBpZiAodHlwZW9mIGdsW2tleV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gZW51bXNbZ2xba2V5XV07XG4gICAgICAgICAgZW51bXNbZ2xba2V5XV0gPSBleGlzdGluZyA/IFwiXCIuY29uY2F0KGV4aXN0aW5nLCBcIiB8IFwiKS5jb25jYXQoa2V5KSA6IGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBoYXZlRW51bXNGb3JUeXBlW3R5cGVdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gZ2xFbnVtVG9TdHJpbmcoZ2wsIHZhbHVlKSB7XG4gICAgYWRkRW51bXMoZ2wpO1xuICAgIHJldHVybiBlbnVtc1t2YWx1ZV0gfHwgXCIweFwiICsgdmFsdWUudG9TdHJpbmcoMTYpO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLmdsRW51bVRvU3RyaW5nID0gZ2xFbnVtVG9TdHJpbmc7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzID0gY3JlYXRlQXR0cmlidXRlU2V0dGVycztcbmV4cG9ydHMuY3JlYXRlUHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW07XG5leHBvcnRzLmNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyA9IGNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cztcbmV4cG9ydHMuY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2VzID0gY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2VzO1xuZXhwb3J0cy5jcmVhdGVQcm9ncmFtSW5mbyA9IGNyZWF0ZVByb2dyYW1JbmZvO1xuZXhwb3J0cy5jcmVhdGVQcm9ncmFtSW5mb0Zyb21Qcm9ncmFtID0gY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbTtcbmV4cG9ydHMuY3JlYXRlVW5pZm9ybVNldHRlcnMgPSBjcmVhdGVVbmlmb3JtU2V0dGVycztcbmV4cG9ydHMuY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtID0gY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtO1xuZXhwb3J0cy5jcmVhdGVVbmlmb3JtQmxvY2tJbmZvRnJvbVByb2dyYW0gPSBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvRnJvbVByb2dyYW07XG5leHBvcnRzLmNyZWF0ZVVuaWZvcm1CbG9ja0luZm8gPSBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvO1xuZXhwb3J0cy5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjayA9IGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrO1xuZXhwb3J0cy5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFja0luZm8gPSBjcmVhdGVUcmFuc2Zvcm1GZWVkYmFja0luZm87XG5leHBvcnRzLmJpbmRUcmFuc2Zvcm1GZWVkYmFja0luZm8gPSBiaW5kVHJhbnNmb3JtRmVlZGJhY2tJbmZvO1xuZXhwb3J0cy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcbmV4cG9ydHMuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXMgPSBzZXRCdWZmZXJzQW5kQXR0cmlidXRlcztcbmV4cG9ydHMuc2V0VW5pZm9ybXMgPSBzZXRVbmlmb3JtcztcbmV4cG9ydHMuc2V0VW5pZm9ybUJsb2NrID0gc2V0VW5pZm9ybUJsb2NrO1xuZXhwb3J0cy5zZXRCbG9ja1VuaWZvcm1zID0gc2V0QmxvY2tVbmlmb3JtcztcbmV4cG9ydHMuYmluZFVuaWZvcm1CbG9jayA9IGJpbmRVbmlmb3JtQmxvY2s7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xuXG52YXIgaGVscGVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygwKSk7XG5cbnZhciBfZ2xvYmFsT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMTUsIEdyZWdnIFRhdmFyZXMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4gKiBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4gKiBkaXN0cmlidXRpb24uXG4gKiAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdyZWdnIFRhdmFyZXMuIG5vciB0aGUgbmFtZXMgb2YgaGlzXG4gKiBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuLyoqXG4gKiBMb3cgbGV2ZWwgc2hhZGVyIHByb2dyYW0gcmVsYXRlZCBmdW5jdGlvbnNcbiAqXG4gKiBZb3Ugc2hvdWxkIGdlbmVyYWxseSBub3QgbmVlZCB0byB1c2UgdGhlc2UgZnVuY3Rpb25zLiBUaGV5IGFyZSBwcm92aWRlZFxuICogZm9yIHRob3NlIGNhc2VzIHdoZXJlIHlvdSdyZSBkb2luZyBzb21ldGhpbmcgb3V0IG9mIHRoZSBvcmRpbmFyeVxuICogYW5kIHlvdSBuZWVkIGxvd2VyIGxldmVsIGFjY2Vzcy5cbiAqXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbHkgdGhleSBhcmUgYXZhaWxhYmxlIGF0IGJvdGggYHR3Z2wucHJvZ3JhbXNgIGFuZCBgdHdnbGBcbiAqIGl0c2VsZlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2x9IGZvciBjb3JlIGZ1bmN0aW9uc1xuICpcbiAqIEBtb2R1bGUgdHdnbC9wcm9ncmFtc1xuICovXG52YXIgZXJyb3IgPSBoZWxwZXIuZXJyb3I7XG52YXIgd2FybiA9IGhlbHBlci53YXJuO1xudmFyIGdldEVsZW1lbnRCeUlkID0gX2dsb2JhbE9iamVjdC5kZWZhdWx0ICYmIF9nbG9iYWxPYmplY3QuZGVmYXVsdC5kb2N1bWVudCAmJiBfZ2xvYmFsT2JqZWN0LmRlZmF1bHQuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQgPyBfZ2xvYmFsT2JqZWN0LmRlZmF1bHQuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQuYmluZChfZ2xvYmFsT2JqZWN0LmRlZmF1bHQuZG9jdW1lbnQpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbnVsbDtcbn07XG52YXIgRkxPQVQgPSAweDE0MDY7XG52YXIgRkxPQVRfVkVDMiA9IDB4OEI1MDtcbnZhciBGTE9BVF9WRUMzID0gMHg4QjUxO1xudmFyIEZMT0FUX1ZFQzQgPSAweDhCNTI7XG52YXIgSU5UID0gMHgxNDA0O1xudmFyIElOVF9WRUMyID0gMHg4QjUzO1xudmFyIElOVF9WRUMzID0gMHg4QjU0O1xudmFyIElOVF9WRUM0ID0gMHg4QjU1O1xudmFyIEJPT0wgPSAweDhCNTY7XG52YXIgQk9PTF9WRUMyID0gMHg4QjU3O1xudmFyIEJPT0xfVkVDMyA9IDB4OEI1ODtcbnZhciBCT09MX1ZFQzQgPSAweDhCNTk7XG52YXIgRkxPQVRfTUFUMiA9IDB4OEI1QTtcbnZhciBGTE9BVF9NQVQzID0gMHg4QjVCO1xudmFyIEZMT0FUX01BVDQgPSAweDhCNUM7XG52YXIgU0FNUExFUl8yRCA9IDB4OEI1RTtcbnZhciBTQU1QTEVSX0NVQkUgPSAweDhCNjA7XG52YXIgU0FNUExFUl8zRCA9IDB4OEI1RjtcbnZhciBTQU1QTEVSXzJEX1NIQURPVyA9IDB4OEI2MjtcbnZhciBGTE9BVF9NQVQyeDMgPSAweDhCNjU7XG52YXIgRkxPQVRfTUFUMng0ID0gMHg4QjY2O1xudmFyIEZMT0FUX01BVDN4MiA9IDB4OEI2NztcbnZhciBGTE9BVF9NQVQzeDQgPSAweDhCNjg7XG52YXIgRkxPQVRfTUFUNHgyID0gMHg4QjY5O1xudmFyIEZMT0FUX01BVDR4MyA9IDB4OEI2QTtcbnZhciBTQU1QTEVSXzJEX0FSUkFZID0gMHg4REMxO1xudmFyIFNBTVBMRVJfMkRfQVJSQVlfU0hBRE9XID0gMHg4REM0O1xudmFyIFNBTVBMRVJfQ1VCRV9TSEFET1cgPSAweDhEQzU7XG52YXIgVU5TSUdORURfSU5UID0gMHgxNDA1O1xudmFyIFVOU0lHTkVEX0lOVF9WRUMyID0gMHg4REM2O1xudmFyIFVOU0lHTkVEX0lOVF9WRUMzID0gMHg4REM3O1xudmFyIFVOU0lHTkVEX0lOVF9WRUM0ID0gMHg4REM4O1xudmFyIElOVF9TQU1QTEVSXzJEID0gMHg4RENBO1xudmFyIElOVF9TQU1QTEVSXzNEID0gMHg4RENCO1xudmFyIElOVF9TQU1QTEVSX0NVQkUgPSAweDhEQ0M7XG52YXIgSU5UX1NBTVBMRVJfMkRfQVJSQVkgPSAweDhEQ0Y7XG52YXIgVU5TSUdORURfSU5UX1NBTVBMRVJfMkQgPSAweDhERDI7XG52YXIgVU5TSUdORURfSU5UX1NBTVBMRVJfM0QgPSAweDhERDM7XG52YXIgVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRSA9IDB4OERENDtcbnZhciBVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWSA9IDB4OERENztcbnZhciBURVhUVVJFXzJEID0gMHgwREUxO1xudmFyIFRFWFRVUkVfQ1VCRV9NQVAgPSAweDg1MTM7XG52YXIgVEVYVFVSRV8zRCA9IDB4ODA2RjtcbnZhciBURVhUVVJFXzJEX0FSUkFZID0gMHg4QzFBO1xudmFyIHR5cGVNYXAgPSB7fTtcbi8qKlxuICogUmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBiaW5kIHBvaW50IGZvciBhIGdpdmVuIHNhbXBsZXIgdHlwZVxuICovXG5cbmZ1bmN0aW9uIGdldEJpbmRQb2ludEZvclNhbXBsZXJUeXBlKGdsLCB0eXBlKSB7XG4gIHJldHVybiB0eXBlTWFwW3R5cGVdLmJpbmRQb2ludDtcbn0gLy8gVGhpcyBraW5kIG9mIHN1Y2tzISBJZiB5b3UgY291bGQgY29tcG9zZSBmdW5jdGlvbnMgYXMgaW4gYHZhciBmbiA9IGdsW25hbWVdO2Bcbi8vIHRoaXMgY29kZSBjb3VsZCBiZSBhIGxvdCBzbWFsbGVyIGJ1dCB0aGF0IGlzIHNhZGx5IHJlYWxseSBzbG93IChUX1QpXG5cblxuZnVuY3Rpb24gZmxvYXRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0QXJyYXlTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdFZlYzJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0yZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdFZlYzNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdFZlYzRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm00ZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludEFycmF5U2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50VmVjMlNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludFZlYzNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRWZWM0U2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtNGl2KGxvY2F0aW9uLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdWludFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTF1aShsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVpbnRBcnJheVNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTF1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1aW50VmVjMlNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTJ1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1aW50VmVjM1NldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTN1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1aW50VmVjNFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybTR1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdE1hdDJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYobG9jYXRpb24sIGZhbHNlLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvYXRNYXQzU2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0NFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdE1hdDIzU2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4MngzZnYobG9jYXRpb24sIGZhbHNlLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvYXRNYXQzMlNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDN4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0MjRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm1NYXRyaXgyeDRmdihsb2NhdGlvbiwgZmFsc2UsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdE1hdDQyU2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4NHgyZnYobG9jYXRpb24sIGZhbHNlLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvYXRNYXQzNFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDN4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0NDNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0eDNmdihsb2NhdGlvbiwgZmFsc2UsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzYW1wbGVyU2V0dGVyKGdsLCB0eXBlLCB1bml0LCBsb2NhdGlvbikge1xuICB2YXIgYmluZFBvaW50ID0gZ2V0QmluZFBvaW50Rm9yU2FtcGxlclR5cGUoZ2wsIHR5cGUpO1xuICByZXR1cm4gdXRpbHMuaXNXZWJHTDIoZ2wpID8gZnVuY3Rpb24gKHRleHR1cmVPclBhaXIpIHtcbiAgICB2YXIgdGV4dHVyZTtcbiAgICB2YXIgc2FtcGxlcjtcblxuICAgIGlmIChoZWxwZXIuaXNUZXh0dXJlKGdsLCB0ZXh0dXJlT3JQYWlyKSkge1xuICAgICAgdGV4dHVyZSA9IHRleHR1cmVPclBhaXI7XG4gICAgICBzYW1wbGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dHVyZSA9IHRleHR1cmVPclBhaXIudGV4dHVyZTtcbiAgICAgIHNhbXBsZXIgPSB0ZXh0dXJlT3JQYWlyLnNhbXBsZXI7XG4gICAgfVxuXG4gICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB1bml0KTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoYmluZFBvaW50LCB0ZXh0dXJlKTtcbiAgICBnbC5iaW5kU2FtcGxlcih1bml0LCBzYW1wbGVyKTtcbiAgfSA6IGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB1bml0KTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoYmluZFBvaW50LCB0ZXh0dXJlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2FtcGxlckFycmF5U2V0dGVyKGdsLCB0eXBlLCB1bml0LCBsb2NhdGlvbiwgc2l6ZSkge1xuICB2YXIgYmluZFBvaW50ID0gZ2V0QmluZFBvaW50Rm9yU2FtcGxlclR5cGUoZ2wsIHR5cGUpO1xuICB2YXIgdW5pdHMgPSBuZXcgSW50MzJBcnJheShzaXplKTtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc2l6ZTsgKytpaSkge1xuICAgIHVuaXRzW2lpXSA9IHVuaXQgKyBpaTtcbiAgfVxuXG4gIHJldHVybiB1dGlscy5pc1dlYkdMMihnbCkgPyBmdW5jdGlvbiAodGV4dHVyZXMpIHtcbiAgICBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB1bml0cyk7XG4gICAgdGV4dHVyZXMuZm9yRWFjaChmdW5jdGlvbiAodGV4dHVyZU9yUGFpciwgaW5kZXgpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB1bml0c1tpbmRleF0pO1xuICAgICAgdmFyIHRleHR1cmU7XG4gICAgICB2YXIgc2FtcGxlcjtcblxuICAgICAgaWYgKGhlbHBlci5pc1RleHR1cmUoZ2wsIHRleHR1cmVPclBhaXIpKSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlT3JQYWlyO1xuICAgICAgICBzYW1wbGVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlT3JQYWlyLnRleHR1cmU7XG4gICAgICAgIHNhbXBsZXIgPSB0ZXh0dXJlT3JQYWlyLnNhbXBsZXI7XG4gICAgICB9XG5cbiAgICAgIGdsLmJpbmRTYW1wbGVyKHVuaXQsIHNhbXBsZXIpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoYmluZFBvaW50LCB0ZXh0dXJlKTtcbiAgICB9KTtcbiAgfSA6IGZ1bmN0aW9uICh0ZXh0dXJlcykge1xuICAgIGdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHVuaXRzKTtcbiAgICB0ZXh0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXh0dXJlLCBpbmRleCkge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHVuaXRzW2luZGV4XSk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShiaW5kUG9pbnQsIHRleHR1cmUpO1xuICAgIH0pO1xuICB9O1xufVxuXG50eXBlTWFwW0ZMT0FUXSA9IHtcbiAgVHlwZTogRmxvYXQzMkFycmF5LFxuICBzaXplOiA0LFxuICBzZXR0ZXI6IGZsb2F0U2V0dGVyLFxuICBhcnJheVNldHRlcjogZmxvYXRBcnJheVNldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfVkVDMl0gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogOCxcbiAgc2V0dGVyOiBmbG9hdFZlYzJTZXR0ZXJcbn07XG50eXBlTWFwW0ZMT0FUX1ZFQzNdID0ge1xuICBUeXBlOiBGbG9hdDMyQXJyYXksXG4gIHNpemU6IDEyLFxuICBzZXR0ZXI6IGZsb2F0VmVjM1NldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfVkVDNF0gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogMTYsXG4gIHNldHRlcjogZmxvYXRWZWM0U2V0dGVyXG59O1xudHlwZU1hcFtJTlRdID0ge1xuICBUeXBlOiBJbnQzMkFycmF5LFxuICBzaXplOiA0LFxuICBzZXR0ZXI6IGludFNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IGludEFycmF5U2V0dGVyXG59O1xudHlwZU1hcFtJTlRfVkVDMl0gPSB7XG4gIFR5cGU6IEludDMyQXJyYXksXG4gIHNpemU6IDgsXG4gIHNldHRlcjogaW50VmVjMlNldHRlclxufTtcbnR5cGVNYXBbSU5UX1ZFQzNdID0ge1xuICBUeXBlOiBJbnQzMkFycmF5LFxuICBzaXplOiAxMixcbiAgc2V0dGVyOiBpbnRWZWMzU2V0dGVyXG59O1xudHlwZU1hcFtJTlRfVkVDNF0gPSB7XG4gIFR5cGU6IEludDMyQXJyYXksXG4gIHNpemU6IDE2LFxuICBzZXR0ZXI6IGludFZlYzRTZXR0ZXJcbn07XG50eXBlTWFwW1VOU0lHTkVEX0lOVF0gPSB7XG4gIFR5cGU6IFVpbnQzMkFycmF5LFxuICBzaXplOiA0LFxuICBzZXR0ZXI6IHVpbnRTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiB1aW50QXJyYXlTZXR0ZXJcbn07XG50eXBlTWFwW1VOU0lHTkVEX0lOVF9WRUMyXSA9IHtcbiAgVHlwZTogVWludDMyQXJyYXksXG4gIHNpemU6IDgsXG4gIHNldHRlcjogdWludFZlYzJTZXR0ZXJcbn07XG50eXBlTWFwW1VOU0lHTkVEX0lOVF9WRUMzXSA9IHtcbiAgVHlwZTogVWludDMyQXJyYXksXG4gIHNpemU6IDEyLFxuICBzZXR0ZXI6IHVpbnRWZWMzU2V0dGVyXG59O1xudHlwZU1hcFtVTlNJR05FRF9JTlRfVkVDNF0gPSB7XG4gIFR5cGU6IFVpbnQzMkFycmF5LFxuICBzaXplOiAxNixcbiAgc2V0dGVyOiB1aW50VmVjNFNldHRlclxufTtcbnR5cGVNYXBbQk9PTF0gPSB7XG4gIFR5cGU6IFVpbnQzMkFycmF5LFxuICBzaXplOiA0LFxuICBzZXR0ZXI6IGludFNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IGludEFycmF5U2V0dGVyXG59O1xudHlwZU1hcFtCT09MX1ZFQzJdID0ge1xuICBUeXBlOiBVaW50MzJBcnJheSxcbiAgc2l6ZTogOCxcbiAgc2V0dGVyOiBpbnRWZWMyU2V0dGVyXG59O1xudHlwZU1hcFtCT09MX1ZFQzNdID0ge1xuICBUeXBlOiBVaW50MzJBcnJheSxcbiAgc2l6ZTogMTIsXG4gIHNldHRlcjogaW50VmVjM1NldHRlclxufTtcbnR5cGVNYXBbQk9PTF9WRUM0XSA9IHtcbiAgVHlwZTogVWludDMyQXJyYXksXG4gIHNpemU6IDE2LFxuICBzZXR0ZXI6IGludFZlYzRTZXR0ZXJcbn07XG50eXBlTWFwW0ZMT0FUX01BVDJdID0ge1xuICBUeXBlOiBGbG9hdDMyQXJyYXksXG4gIHNpemU6IDE2LFxuICBzZXR0ZXI6IGZsb2F0TWF0MlNldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfTUFUM10gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogMzYsXG4gIHNldHRlcjogZmxvYXRNYXQzU2V0dGVyXG59O1xudHlwZU1hcFtGTE9BVF9NQVQ0XSA9IHtcbiAgVHlwZTogRmxvYXQzMkFycmF5LFxuICBzaXplOiA2NCxcbiAgc2V0dGVyOiBmbG9hdE1hdDRTZXR0ZXJcbn07XG50eXBlTWFwW0ZMT0FUX01BVDJ4M10gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogMjQsXG4gIHNldHRlcjogZmxvYXRNYXQyM1NldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfTUFUMng0XSA9IHtcbiAgVHlwZTogRmxvYXQzMkFycmF5LFxuICBzaXplOiAzMixcbiAgc2V0dGVyOiBmbG9hdE1hdDI0U2V0dGVyXG59O1xudHlwZU1hcFtGTE9BVF9NQVQzeDJdID0ge1xuICBUeXBlOiBGbG9hdDMyQXJyYXksXG4gIHNpemU6IDI0LFxuICBzZXR0ZXI6IGZsb2F0TWF0MzJTZXR0ZXJcbn07XG50eXBlTWFwW0ZMT0FUX01BVDN4NF0gPSB7XG4gIFR5cGU6IEZsb2F0MzJBcnJheSxcbiAgc2l6ZTogNDgsXG4gIHNldHRlcjogZmxvYXRNYXQzNFNldHRlclxufTtcbnR5cGVNYXBbRkxPQVRfTUFUNHgyXSA9IHtcbiAgVHlwZTogRmxvYXQzMkFycmF5LFxuICBzaXplOiAzMixcbiAgc2V0dGVyOiBmbG9hdE1hdDQyU2V0dGVyXG59O1xudHlwZU1hcFtGTE9BVF9NQVQ0eDNdID0ge1xuICBUeXBlOiBGbG9hdDMyQXJyYXksXG4gIHNpemU6IDQ4LFxuICBzZXR0ZXI6IGZsb2F0TWF0NDNTZXR0ZXJcbn07XG50eXBlTWFwW1NBTVBMRVJfMkRdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8yRFxufTtcbnR5cGVNYXBbU0FNUExFUl9DVUJFXSA9IHtcbiAgVHlwZTogbnVsbCxcbiAgc2l6ZTogMCxcbiAgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLFxuICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLFxuICBiaW5kUG9pbnQ6IFRFWFRVUkVfQ1VCRV9NQVBcbn07XG50eXBlTWFwW1NBTVBMRVJfM0RdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8zRFxufTtcbnR5cGVNYXBbU0FNUExFUl8yRF9TSEFET1ddID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8yRFxufTtcbnR5cGVNYXBbU0FNUExFUl8yRF9BUlJBWV0gPSB7XG4gIFR5cGU6IG51bGwsXG4gIHNpemU6IDAsXG4gIHNldHRlcjogc2FtcGxlclNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlcixcbiAgYmluZFBvaW50OiBURVhUVVJFXzJEX0FSUkFZXG59O1xudHlwZU1hcFtTQU1QTEVSXzJEX0FSUkFZX1NIQURPV10gPSB7XG4gIFR5cGU6IG51bGwsXG4gIHNpemU6IDAsXG4gIHNldHRlcjogc2FtcGxlclNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlcixcbiAgYmluZFBvaW50OiBURVhUVVJFXzJEX0FSUkFZXG59O1xudHlwZU1hcFtTQU1QTEVSX0NVQkVfU0hBRE9XXSA9IHtcbiAgVHlwZTogbnVsbCxcbiAgc2l6ZTogMCxcbiAgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLFxuICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLFxuICBiaW5kUG9pbnQ6IFRFWFRVUkVfQ1VCRV9NQVBcbn07XG50eXBlTWFwW0lOVF9TQU1QTEVSXzJEXSA9IHtcbiAgVHlwZTogbnVsbCxcbiAgc2l6ZTogMCxcbiAgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLFxuICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLFxuICBiaW5kUG9pbnQ6IFRFWFRVUkVfMkRcbn07XG50eXBlTWFwW0lOVF9TQU1QTEVSXzNEXSA9IHtcbiAgVHlwZTogbnVsbCxcbiAgc2l6ZTogMCxcbiAgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLFxuICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLFxuICBiaW5kUG9pbnQ6IFRFWFRVUkVfM0Rcbn07XG50eXBlTWFwW0lOVF9TQU1QTEVSX0NVQkVdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV9DVUJFX01BUFxufTtcbnR5cGVNYXBbSU5UX1NBTVBMRVJfMkRfQVJSQVldID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8yRF9BUlJBWVxufTtcbnR5cGVNYXBbVU5TSUdORURfSU5UX1NBTVBMRVJfMkRdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8yRFxufTtcbnR5cGVNYXBbVU5TSUdORURfSU5UX1NBTVBMRVJfM0RdID0ge1xuICBUeXBlOiBudWxsLFxuICBzaXplOiAwLFxuICBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsXG4gIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsXG4gIGJpbmRQb2ludDogVEVYVFVSRV8zRFxufTtcbnR5cGVNYXBbVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRV0gPSB7XG4gIFR5cGU6IG51bGwsXG4gIHNpemU6IDAsXG4gIHNldHRlcjogc2FtcGxlclNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlcixcbiAgYmluZFBvaW50OiBURVhUVVJFX0NVQkVfTUFQXG59O1xudHlwZU1hcFtVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWV0gPSB7XG4gIFR5cGU6IG51bGwsXG4gIHNpemU6IDAsXG4gIHNldHRlcjogc2FtcGxlclNldHRlcixcbiAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlcixcbiAgYmluZFBvaW50OiBURVhUVVJFXzJEX0FSUkFZXG59O1xuXG5mdW5jdGlvbiBmbG9hdEF0dHJpYlNldHRlcihnbCwgaW5kZXgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGIuYnVmZmVyKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpbmRleCwgYi5udW1Db21wb25lbnRzIHx8IGIuc2l6ZSwgYi50eXBlIHx8IGdsLkZMT0FULCBiLm5vcm1hbGl6ZSB8fCBmYWxzZSwgYi5zdHJpZGUgfHwgMCwgYi5vZmZzZXQgfHwgMCk7XG5cbiAgICBpZiAoYi5kaXZpc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoaW5kZXgsIGIuZGl2aXNvcik7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRBdHRyaWJTZXR0ZXIoZ2wsIGluZGV4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYikge1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBiLmJ1ZmZlcik7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgIGdsLnZlcnRleEF0dHJpYklQb2ludGVyKGluZGV4LCBiLm51bUNvbXBvbmVudHMgfHwgYi5zaXplLCBiLnR5cGUgfHwgZ2wuSU5ULCBiLnN0cmlkZSB8fCAwLCBiLm9mZnNldCB8fCAwKTtcblxuICAgIGlmIChiLmRpdmlzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihpbmRleCwgYi5kaXZpc29yKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1hdEF0dHJpYlNldHRlcihnbCwgaW5kZXgsIHR5cGVJbmZvKSB7XG4gIHZhciBkZWZhdWx0U2l6ZSA9IHR5cGVJbmZvLnNpemU7XG4gIHZhciBjb3VudCA9IHR5cGVJbmZvLmNvdW50O1xuICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYi5idWZmZXIpO1xuICAgIHZhciBudW1Db21wb25lbnRzID0gYi5zaXplIHx8IGIubnVtQ29tcG9uZW50cyB8fCBkZWZhdWx0U2l6ZTtcbiAgICB2YXIgc2l6ZSA9IG51bUNvbXBvbmVudHMgLyBjb3VudDtcbiAgICB2YXIgdHlwZSA9IGIudHlwZSB8fCBnbC5GTE9BVDtcbiAgICB2YXIgdHlwZUluZm8gPSB0eXBlTWFwW3R5cGVdO1xuICAgIHZhciBzdHJpZGUgPSB0eXBlSW5mby5zaXplICogbnVtQ29tcG9uZW50cztcbiAgICB2YXIgbm9ybWFsaXplID0gYi5ub3JtYWxpemUgfHwgZmFsc2U7XG4gICAgdmFyIG9mZnNldCA9IGIub2Zmc2V0IHx8IDA7XG4gICAgdmFyIHJvd09mZnNldCA9IHN0cmlkZSAvIGNvdW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCArIGkpO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpbmRleCArIGksIHNpemUsIHR5cGUsIG5vcm1hbGl6ZSwgc3RyaWRlLCBvZmZzZXQgKyByb3dPZmZzZXQgKiBpKTtcblxuICAgICAgaWYgKGIuZGl2aXNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoaW5kZXggKyBpLCBiLmRpdmlzb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIGF0dHJUeXBlTWFwID0ge307XG5hdHRyVHlwZU1hcFtGTE9BVF0gPSB7XG4gIHNpemU6IDQsXG4gIHNldHRlcjogZmxvYXRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtGTE9BVF9WRUMyXSA9IHtcbiAgc2l6ZTogOCxcbiAgc2V0dGVyOiBmbG9hdEF0dHJpYlNldHRlclxufTtcbmF0dHJUeXBlTWFwW0ZMT0FUX1ZFQzNdID0ge1xuICBzaXplOiAxMixcbiAgc2V0dGVyOiBmbG9hdEF0dHJpYlNldHRlclxufTtcbmF0dHJUeXBlTWFwW0ZMT0FUX1ZFQzRdID0ge1xuICBzaXplOiAxNixcbiAgc2V0dGVyOiBmbG9hdEF0dHJpYlNldHRlclxufTtcbmF0dHJUeXBlTWFwW0lOVF0gPSB7XG4gIHNpemU6IDQsXG4gIHNldHRlcjogaW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbSU5UX1ZFQzJdID0ge1xuICBzaXplOiA4LFxuICBzZXR0ZXI6IGludEF0dHJpYlNldHRlclxufTtcbmF0dHJUeXBlTWFwW0lOVF9WRUMzXSA9IHtcbiAgc2l6ZTogMTIsXG4gIHNldHRlcjogaW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbSU5UX1ZFQzRdID0ge1xuICBzaXplOiAxNixcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtVTlNJR05FRF9JTlRdID0ge1xuICBzaXplOiA0LFxuICBzZXR0ZXI6IGludEF0dHJpYlNldHRlclxufTtcbmF0dHJUeXBlTWFwW1VOU0lHTkVEX0lOVF9WRUMyXSA9IHtcbiAgc2l6ZTogOCxcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtVTlNJR05FRF9JTlRfVkVDM10gPSB7XG4gIHNpemU6IDEyLFxuICBzZXR0ZXI6IGludEF0dHJpYlNldHRlclxufTtcbmF0dHJUeXBlTWFwW1VOU0lHTkVEX0lOVF9WRUM0XSA9IHtcbiAgc2l6ZTogMTYsXG4gIHNldHRlcjogaW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbQk9PTF0gPSB7XG4gIHNpemU6IDQsXG4gIHNldHRlcjogaW50QXR0cmliU2V0dGVyXG59O1xuYXR0clR5cGVNYXBbQk9PTF9WRUMyXSA9IHtcbiAgc2l6ZTogOCxcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtCT09MX1ZFQzNdID0ge1xuICBzaXplOiAxMixcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtCT09MX1ZFQzRdID0ge1xuICBzaXplOiAxNixcbiAgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXJcbn07XG5hdHRyVHlwZU1hcFtGTE9BVF9NQVQyXSA9IHtcbiAgc2l6ZTogNCxcbiAgc2V0dGVyOiBtYXRBdHRyaWJTZXR0ZXIsXG4gIGNvdW50OiAyXG59O1xuYXR0clR5cGVNYXBbRkxPQVRfTUFUM10gPSB7XG4gIHNpemU6IDksXG4gIHNldHRlcjogbWF0QXR0cmliU2V0dGVyLFxuICBjb3VudDogM1xufTtcbmF0dHJUeXBlTWFwW0ZMT0FUX01BVDRdID0ge1xuICBzaXplOiAxNixcbiAgc2V0dGVyOiBtYXRBdHRyaWJTZXR0ZXIsXG4gIGNvdW50OiA0XG59OyAvLyBtYWtlIHN1cmUgd2UgZG9uJ3Qgc2VlIGEgZ2xvYmFsIGdsXG5cbnZhciBnbCA9IHVuZGVmaW5lZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIEVycm9yIENhbGxiYWNrXG4gKiBAY2FsbGJhY2sgRXJyb3JDYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IG1zZyBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsaW5lT2Zmc2V0XSBhbW91bnQgdG8gYWRkIHRvIGxpbmUgbnVtYmVyXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG5mdW5jdGlvbiBhZGRMaW5lTnVtYmVycyhzcmMsIGxpbmVPZmZzZXQpIHtcbiAgbGluZU9mZnNldCA9IGxpbmVPZmZzZXQgfHwgMDtcbiAgKytsaW5lT2Zmc2V0O1xuICByZXR1cm4gc3JjLnNwbGl0KFwiXFxuXCIpLm1hcChmdW5jdGlvbiAobGluZSwgbmR4KSB7XG4gICAgcmV0dXJuIG5keCArIGxpbmVPZmZzZXQgKyBcIjogXCIgKyBsaW5lO1xuICB9KS5qb2luKFwiXFxuXCIpO1xufVxuXG52YXIgc3BhY2VSRSA9IC9eWyBcXHRdKlxcbi87XG4vKipcbiAqIExvYWRzIGEgc2hhZGVyLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlclNvdXJjZSBUaGUgc2hhZGVyIHNvdXJjZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaGFkZXJUeXBlIFRoZSB0eXBlIG9mIHNoYWRlci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gb3B0X2Vycm9yQ2FsbGJhY2sgY2FsbGJhY2sgZm9yIGVycm9ycy5cbiAqIEByZXR1cm4ge1dlYkdMU2hhZGVyfSBUaGUgY3JlYXRlZCBzaGFkZXIuXG4gKi9cblxuZnVuY3Rpb24gbG9hZFNoYWRlcihnbCwgc2hhZGVyU291cmNlLCBzaGFkZXJUeXBlLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICB2YXIgZXJyRm4gPSBvcHRfZXJyb3JDYWxsYmFjayB8fCBlcnJvcjsgLy8gQ3JlYXRlIHRoZSBzaGFkZXIgb2JqZWN0XG5cbiAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihzaGFkZXJUeXBlKTsgLy8gUmVtb3ZlIHRoZSBmaXJzdCBlbmQgb2YgbGluZSBiZWNhdXNlIFdlYkdMIDIuMCByZXF1aXJlc1xuICAvLyAjdmVyc2lvbiAzMDAgZXNcbiAgLy8gYXMgdGhlIGZpcnN0IGxpbmUuIE5vIHdoaXRlc3BhY2UgYWxsb3dlZCBiZWZvcmUgdGhhdCBsaW5lXG4gIC8vIHNvXG4gIC8vXG4gIC8vIDxzY3JpcHQ+XG4gIC8vICN2ZXJzaW9uIDMwMCBlc1xuICAvLyA8L3NjcmlwdD5cbiAgLy9cbiAgLy8gSGFzIG9uZSBsaW5lIGJlZm9yZSBpdCB3aGljaCBpcyBpbnZhbGlkIGFjY29yZGluZyB0byBHTFNMIEVTIDMuMDBcbiAgLy9cblxuICB2YXIgbGluZU9mZnNldCA9IDA7XG5cbiAgaWYgKHNwYWNlUkUudGVzdChzaGFkZXJTb3VyY2UpKSB7XG4gICAgbGluZU9mZnNldCA9IDE7XG4gICAgc2hhZGVyU291cmNlID0gc2hhZGVyU291cmNlLnJlcGxhY2Uoc3BhY2VSRSwgJycpO1xuICB9IC8vIExvYWQgdGhlIHNoYWRlciBzb3VyY2VcblxuXG4gIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7IC8vIENvbXBpbGUgdGhlIHNoYWRlclxuXG4gIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTsgLy8gQ2hlY2sgdGhlIGNvbXBpbGUgc3RhdHVzXG5cbiAgdmFyIGNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuXG4gIGlmICghY29tcGlsZWQpIHtcbiAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgY29tcGlsYXRpb247IGdldCB0aGUgZXJyb3JcbiAgICB2YXIgbGFzdEVycm9yID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgIGVyckZuKGFkZExpbmVOdW1iZXJzKHNoYWRlclNvdXJjZSwgbGluZU9mZnNldCkgKyBcIlxcbioqKiBFcnJvciBjb21waWxpbmcgc2hhZGVyOiBcIiArIGxhc3RFcnJvcik7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gc2hhZGVyO1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9ncmFtT3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihzdHJpbmcpfSBbZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9yc1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxudW1iZXI+fSBbYXR0cmliTG9jYXRpb25zXSBhIGF0dHJpYnV0ZSBuYW1lIHRvIGxvY2F0aW9uIG1hcFxuICogQHByb3BlcnR5IHsobW9kdWxlOnR3Z2wuQnVmZmVySW5mb3xPYmplY3QuPHN0cmluZyxtb2R1bGU6dHdnbC5BdHRyaWJJbmZvPnxzdHJpbmdbXSl9IFt0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzXSBJZiBwYXNzZWRcbiAqICAgYSBCdWZmZXJJbmZvIHdpbGwgdXNlIHRoZSBhdHRyaWJzIG5hbWVzIGluc2lkZS4gSWYgcGFzc2VkIGFuIG9iamVjdCBvZiBBdHRyaWJJbmZvcyB3aWxsIHVzZSB0aGUgbmFtZXMgZnJvbSB0aGF0IG9iamVjdC4gT3RoZXJ3aXNlXG4gKiAgIHlvdSBjYW4gcGFzcyBhbiBhcnJheSBvZiBuYW1lcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNmb3JtRmVlZGJhY2tNb2RlXSB0aGUgbW9kZSB0byBwYXNzIGBnbC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzYC4gRGVmYXVsdHMgdG8gYFNFUEFSQVRFX0FUVFJJQlNgLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9ncmFtIG9wdGlvbnMgYmFzZWQgb24gYWxsIHRoZXNlIG9wdGlvbmFsIGFyZ3VtZW50c1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtT3B0aW9uc3xzdHJpbmdbXX0gW29wdF9hdHRyaWJzXSBPcHRpb25zIGZvciB0aGUgcHJvZ3JhbSBvciBhbiBhcnJheSBvZiBhdHRyaWJzIG5hbWVzLiBMb2NhdGlvbnMgd2lsbCBiZSBhc3NpZ25lZCBieSBpbmRleCBpZiBub3QgcGFzc2VkIGluXG4gKiBAcGFyYW0ge251bWJlcltdfSBbb3B0X2xvY2F0aW9uc10gVGhlIGxvY2F0aW9ucyBmb3IgdGhlLiBBIHBhcmFsbGVsIGFycmF5IHRvIG9wdF9hdHRyaWJzIGxldHRpbmcgeW91IGFzc2lnbiBsb2NhdGlvbnMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9ycy4gQnkgZGVmYXVsdCBpdCBqdXN0IHByaW50cyBhbiBlcnJvciB0byB0aGUgY29uc29sZVxuICogICAgICAgIG9uIGVycm9yLiBJZiB5b3Ugd2FudCBzb21ldGhpbmcgZWxzZSBwYXNzIGFuIGNhbGxiYWNrLiBJdCdzIHBhc3NlZCBhbiBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuUHJvZ3JhbU9wdGlvbnN9IGFuIGluc3RhbmNlIG9mIFByb2dyYW1PcHRpb25zIGJhc2VkIG9uIHRoZSBhcmd1bWVudHMgcGFzZWQgb25cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFByb2dyYW1PcHRpb25zKG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICB2YXIgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncztcblxuICBpZiAodHlwZW9mIG9wdF9sb2NhdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRfZXJyb3JDYWxsYmFjayA9IG9wdF9sb2NhdGlvbnM7XG4gICAgb3B0X2xvY2F0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0X2F0dHJpYnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRfZXJyb3JDYWxsYmFjayA9IG9wdF9hdHRyaWJzO1xuICAgIG9wdF9hdHRyaWJzID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKG9wdF9hdHRyaWJzICYmICFBcnJheS5pc0FycmF5KG9wdF9hdHRyaWJzKSkge1xuICAgIC8vIElmIHdlIGhhdmUgYW4gZXJyb3JDYWxsYmFjayB3ZSBjYW4ganVzdCByZXR1cm4gdGhpcyBvYmplY3RcbiAgICAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBjb25zdHJ1Y3Qgb25lIHdpdGggZGVmYXVsdCBlcnJvckNhbGxiYWNrXG4gICAgaWYgKG9wdF9hdHRyaWJzLmVycm9yQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBvcHRfYXR0cmlicztcbiAgICB9XG5cbiAgICB2YXIgb3B0ID0gb3B0X2F0dHJpYnM7XG4gICAgb3B0X2Vycm9yQ2FsbGJhY2sgPSBvcHQuZXJyb3JDYWxsYmFjaztcbiAgICBvcHRfYXR0cmlicyA9IG9wdC5hdHRyaWJMb2NhdGlvbnM7XG4gICAgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyA9IG9wdC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzO1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgZXJyb3JDYWxsYmFjazogb3B0X2Vycm9yQ2FsbGJhY2sgfHwgZXJyb3IsXG4gICAgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nczogdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nc1xuICB9O1xuXG4gIGlmIChvcHRfYXR0cmlicykge1xuICAgIHZhciBhdHRyaWJMb2NhdGlvbnMgPSB7fTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdF9hdHRyaWJzKSkge1xuICAgICAgb3B0X2F0dHJpYnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmliLCBuZHgpIHtcbiAgICAgICAgYXR0cmliTG9jYXRpb25zW2F0dHJpYl0gPSBvcHRfbG9jYXRpb25zID8gb3B0X2xvY2F0aW9uc1tuZHhdIDogbmR4O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYkxvY2F0aW9ucyA9IG9wdF9hdHRyaWJzO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYXR0cmliTG9jYXRpb25zID0gYXR0cmliTG9jYXRpb25zO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbnZhciBkZWZhdWx0U2hhZGVyVHlwZSA9IFtcIlZFUlRFWF9TSEFERVJcIiwgXCJGUkFHTUVOVF9TSEFERVJcIl07XG5cbmZ1bmN0aW9uIGdldFNoYWRlclR5cGVGcm9tU2NyaXB0VHlwZShzY3JpcHRUeXBlKSB7XG4gIGlmIChzY3JpcHRUeXBlLmluZGV4T2YoXCJmcmFnXCIpID49IDApIHtcbiAgICByZXR1cm4gZ2wuRlJBR01FTlRfU0hBREVSO1xuICB9IGVsc2UgaWYgKHNjcmlwdFR5cGUuaW5kZXhPZihcInZlcnRcIikgPj0gMCkge1xuICAgIHJldHVybiBnbC5WRVJURVhfU0hBREVSO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVsZXRlU2hhZGVycyhnbCwgc2hhZGVycykge1xuICBzaGFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHNoYWRlcikge1xuICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHByb2dyYW0sIGF0dGFjaGVzIChhbmQvb3IgY29tcGlsZXMpIHNoYWRlcnMsIGJpbmRzIGF0dHJpYiBsb2NhdGlvbnMsIGxpbmtzIHRoZVxuICogcHJvZ3JhbSBhbmQgY2FsbHMgdXNlUHJvZ3JhbS5cbiAqXG4gKiBOT1RFOiBUaGVyZSBhcmUgNCBzaWduYXR1cmVzIGZvciB0aGlzIGZ1bmN0aW9uXG4gKlxuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbShnbCwgW3ZzLCBmc10sIG9wdGlvbnMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbShnbCwgW3ZzLCBmc10sIG9wdF9lcnJGdW5jKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW0oZ2wsIFt2cywgZnNdLCBvcHRfYXR0cmlicywgb3B0X2VyckZ1bmMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbShnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyRnVuYyk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFNoYWRlcltdfHN0cmluZ1tdfSBzaGFkZXJzIFRoZSBzaGFkZXJzIHRvIGF0dGFjaCwgb3IgZWxlbWVudCBpZHMgZm9yIHRoZWlyIHNvdXJjZSwgb3Igc3RyaW5ncyB0aGF0IGNvbnRhaW4gdGhlaXIgc291cmNlXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1PcHRpb25zfHN0cmluZ1tdfSBbb3B0X2F0dHJpYnNdIE9wdGlvbnMgZm9yIHRoZSBwcm9ncmFtIG9yIGFuIGFycmF5IG9mIGF0dHJpYnMgbmFtZXMuIExvY2F0aW9ucyB3aWxsIGJlIGFzc2lnbmVkIGJ5IGluZGV4IGlmIG5vdCBwYXNzZWQgaW5cbiAqIEBwYXJhbSB7bnVtYmVyW119IFtvcHRfbG9jYXRpb25zXSBUaGUgbG9jYXRpb25zIGZvciB0aGUuIEEgcGFyYWxsZWwgYXJyYXkgdG8gb3B0X2F0dHJpYnMgbGV0dGluZyB5b3UgYXNzaWduIGxvY2F0aW9ucy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9lcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzLiBCeSBkZWZhdWx0IGl0IGp1c3QgcHJpbnRzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlXG4gKiAgICAgICAgb24gZXJyb3IuIElmIHlvdSB3YW50IHNvbWV0aGluZyBlbHNlIHBhc3MgYW4gY2FsbGJhY2suIEl0J3MgcGFzc2VkIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHtXZWJHTFByb2dyYW0/fSB0aGUgY3JlYXRlZCBwcm9ncmFtIG9yIG51bGwgaWYgZXJyb3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wsIHNoYWRlcnMsIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICB2YXIgcHJvZ09wdGlvbnMgPSBnZXRQcm9ncmFtT3B0aW9ucyhvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spO1xuICB2YXIgcmVhbFNoYWRlcnMgPSBbXTtcbiAgdmFyIG5ld1NoYWRlcnMgPSBbXTtcblxuICBmb3IgKHZhciBuZHggPSAwOyBuZHggPCBzaGFkZXJzLmxlbmd0aDsgKytuZHgpIHtcbiAgICB2YXIgc2hhZGVyID0gc2hhZGVyc1tuZHhdO1xuXG4gICAgaWYgKHR5cGVvZiBzaGFkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgZWxlbSA9IGdldEVsZW1lbnRCeUlkKHNoYWRlcik7XG4gICAgICB2YXIgc3JjID0gZWxlbSA/IGVsZW0udGV4dCA6IHNoYWRlcjtcbiAgICAgIHZhciB0eXBlID0gZ2xbZGVmYXVsdFNoYWRlclR5cGVbbmR4XV07XG5cbiAgICAgIGlmIChlbGVtICYmIGVsZW0udHlwZSkge1xuICAgICAgICB0eXBlID0gZ2V0U2hhZGVyVHlwZUZyb21TY3JpcHRUeXBlKGVsZW0udHlwZSkgfHwgdHlwZTtcbiAgICAgIH1cblxuICAgICAgc2hhZGVyID0gbG9hZFNoYWRlcihnbCwgc3JjLCB0eXBlLCBwcm9nT3B0aW9ucy5lcnJvckNhbGxiYWNrKTtcbiAgICAgIG5ld1NoYWRlcnMucHVzaChzaGFkZXIpO1xuICAgIH1cblxuICAgIGlmIChoZWxwZXIuaXNTaGFkZXIoZ2wsIHNoYWRlcikpIHtcbiAgICAgIHJlYWxTaGFkZXJzLnB1c2goc2hhZGVyKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVhbFNoYWRlcnMubGVuZ3RoICE9PSBzaGFkZXJzLmxlbmd0aCkge1xuICAgIHByb2dPcHRpb25zLmVycm9yQ2FsbGJhY2soXCJub3QgZW5vdWdoIHNoYWRlcnMgZm9yIHByb2dyYW1cIik7XG4gICAgZGVsZXRlU2hhZGVycyhnbCwgbmV3U2hhZGVycyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgcmVhbFNoYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2hhZGVyKSB7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcik7XG4gIH0pO1xuXG4gIGlmIChwcm9nT3B0aW9ucy5hdHRyaWJMb2NhdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhwcm9nT3B0aW9ucy5hdHRyaWJMb2NhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYikge1xuICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIHByb2dPcHRpb25zLmF0dHJpYkxvY2F0aW9uc1thdHRyaWJdLCBhdHRyaWIpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHZhcnlpbmdzID0gcHJvZ09wdGlvbnMudHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncztcblxuICBpZiAodmFyeWluZ3MpIHtcbiAgICBpZiAodmFyeWluZ3MuYXR0cmlicykge1xuICAgICAgdmFyeWluZ3MgPSB2YXJ5aW5ncy5hdHRyaWJzO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YXJ5aW5ncykpIHtcbiAgICAgIHZhcnlpbmdzID0gT2JqZWN0LmtleXModmFyeWluZ3MpO1xuICAgIH1cblxuICAgIGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MocHJvZ3JhbSwgdmFyeWluZ3MsIHByb2dPcHRpb25zLnRyYW5zZm9ybUZlZWRiYWNrTW9kZSB8fCBnbC5TRVBBUkFURV9BVFRSSUJTKTtcbiAgfVxuXG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pOyAvLyBDaGVjayB0aGUgbGluayBzdGF0dXNcblxuICB2YXIgbGlua2VkID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyk7XG5cbiAgaWYgKCFsaW5rZWQpIHtcbiAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoIHRoZSBsaW5rXG4gICAgdmFyIGxhc3RFcnJvciA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xuICAgIHByb2dPcHRpb25zLmVycm9yQ2FsbGJhY2soXCJFcnJvciBpbiBwcm9ncmFtIGxpbmtpbmc6XCIgKyBsYXN0RXJyb3IpO1xuICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgZGVsZXRlU2hhZGVycyhnbCwgbmV3U2hhZGVycyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcHJvZ3JhbTtcbn1cbi8qKlxuICogTG9hZHMgYSBzaGFkZXIgZnJvbSBhIHNjcmlwdCB0YWcuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0SWQgVGhlIGlkIG9mIHRoZSBzY3JpcHQgdGFnLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc2hhZGVyVHlwZV0gVGhlIHR5cGUgb2Ygc2hhZGVyLiBJZiBub3QgcGFzc2VkIGluIGl0IHdpbGxcbiAqICAgICBiZSBkZXJpdmVkIGZyb20gdGhlIHR5cGUgb2YgdGhlIHNjcmlwdCB0YWcuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9ycy5cbiAqIEByZXR1cm4ge1dlYkdMU2hhZGVyP30gVGhlIGNyZWF0ZWQgc2hhZGVyIG9yIG51bGwgaWYgZXJyb3IuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVTaGFkZXJGcm9tU2NyaXB0KGdsLCBzY3JpcHRJZCwgb3B0X3NoYWRlclR5cGUsIG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gIHZhciBzaGFkZXJTb3VyY2UgPSBcIlwiO1xuICB2YXIgc2hhZGVyU2NyaXB0ID0gZ2V0RWxlbWVudEJ5SWQoc2NyaXB0SWQpO1xuXG4gIGlmICghc2hhZGVyU2NyaXB0KSB7XG4gICAgdGhyb3cgXCIqKiogRXJyb3I6IHVua25vd24gc2NyaXB0IGVsZW1lbnRcIiArIHNjcmlwdElkO1xuICB9XG5cbiAgc2hhZGVyU291cmNlID0gc2hhZGVyU2NyaXB0LnRleHQ7XG4gIHZhciBzaGFkZXJUeXBlID0gb3B0X3NoYWRlclR5cGUgfHwgZ2V0U2hhZGVyVHlwZUZyb21TY3JpcHRUeXBlKHNoYWRlclNjcmlwdC50eXBlKTtcblxuICBpZiAoIXNoYWRlclR5cGUpIHtcbiAgICB0aHJvdyBcIioqKiBFcnJvcjogdW5rbm93biBzaGFkZXIgdHlwZVwiO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRTaGFkZXIoZ2wsIHNoYWRlclNvdXJjZSwgc2hhZGVyVHlwZSwgb3B0X2Vycm9yQ2FsbGJhY2spO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcHJvZ3JhbSBmcm9tIDIgc2NyaXB0IHRhZ3MuXG4gKlxuICogTk9URTogVGhlcmUgYXJlIDQgc2lnbmF0dXJlcyBmb3IgdGhpcyBmdW5jdGlvblxuICpcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyhnbCwgW3ZzLCBmc10sIG9wdF9vcHRpb25zKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyhnbCwgW3ZzLCBmc10sIG9wdF9lcnJGdW5jKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyhnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtRnJvbVNjcmlwdHMoZ2wsIFt2cywgZnNdLCBvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2VyckZ1bmMpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiAgICAgICAgdG8gdXNlLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gc2hhZGVyU2NyaXB0SWRzIEFycmF5IG9mIGlkcyBvZiB0aGUgc2NyaXB0XG4gKiAgICAgICAgdGFncyBmb3IgdGhlIHNoYWRlcnMuIFRoZSBmaXJzdCBpcyBhc3N1bWVkIHRvIGJlIHRoZVxuICogICAgICAgIHZlcnRleCBzaGFkZXIsIHRoZSBzZWNvbmQgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRfYXR0cmlic10gQW4gYXJyYXkgb2YgYXR0cmlicyBuYW1lcy4gTG9jYXRpb25zIHdpbGwgYmUgYXNzaWduZWQgYnkgaW5kZXggaWYgbm90IHBhc3NlZCBpblxuICogQHBhcmFtIHtudW1iZXJbXX0gW29wdF9sb2NhdGlvbnNdIFRoZSBsb2NhdGlvbnMgZm9yIHRoZS4gQSBwYXJhbGxlbCBhcnJheSB0byBvcHRfYXR0cmlicyBsZXR0aW5nIHlvdSBhc3NpZ24gbG9jYXRpb25zLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrfSBvcHRfZXJyb3JDYWxsYmFjayBjYWxsYmFjayBmb3IgZXJyb3JzLiBCeSBkZWZhdWx0IGl0IGp1c3QgcHJpbnRzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlXG4gKiAgICAgICAgb24gZXJyb3IuIElmIHlvdSB3YW50IHNvbWV0aGluZyBlbHNlIHBhc3MgYW4gY2FsbGJhY2suIEl0J3MgcGFzc2VkIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19IFRoZSBjcmVhdGVkIHByb2dyYW0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyhnbCwgc2hhZGVyU2NyaXB0SWRzLCBvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgdmFyIHByb2dPcHRpb25zID0gZ2V0UHJvZ3JhbU9wdGlvbnMob3B0X2F0dHJpYnMsIG9wdF9sb2NhdGlvbnMsIG9wdF9lcnJvckNhbGxiYWNrKTtcbiAgdmFyIHNoYWRlcnMgPSBbXTtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc2hhZGVyU2NyaXB0SWRzLmxlbmd0aDsgKytpaSkge1xuICAgIHZhciBzaGFkZXIgPSBjcmVhdGVTaGFkZXJGcm9tU2NyaXB0KGdsLCBzaGFkZXJTY3JpcHRJZHNbaWldLCBnbFtkZWZhdWx0U2hhZGVyVHlwZVtpaV1dLCBwcm9nT3B0aW9ucy5lcnJvckNhbGxiYWNrKTtcblxuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzaGFkZXJzLnB1c2goc2hhZGVyKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVQcm9ncmFtKGdsLCBzaGFkZXJzLCBwcm9nT3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBwcm9ncmFtIGZyb20gMiBzb3VyY2VzLlxuICpcbiAqIE5PVEU6IFRoZXJlIGFyZSA0IHNpZ25hdHVyZXMgZm9yIHRoaXMgZnVuY3Rpb25cbiAqXG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtRnJvbVNvdXJjZShnbCwgW3ZzLCBmc10sIG9wdF9vcHRpb25zKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU291cmNlKGdsLCBbdnMsIGZzXSwgb3B0X2VyckZ1bmMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2UoZ2wsIFt2cywgZnNdLCBvcHRfYXR0cmlicywgb3B0X2VyckZ1bmMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2UoZ2wsIFt2cywgZnNdLCBvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2VyckZ1bmMpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiAgICAgICAgdG8gdXNlLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gc2hhZGVyU291cmNlcyBBcnJheSBvZiBzb3VyY2VzIGZvciB0aGVcbiAqICAgICAgICBzaGFkZXJzLiBUaGUgZmlyc3QgaXMgYXNzdW1lZCB0byBiZSB0aGUgdmVydGV4IHNoYWRlcixcbiAqICAgICAgICB0aGUgc2Vjb25kIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0X2F0dHJpYnNdIEFuIGFycmF5IG9mIGF0dHJpYnMgbmFtZXMuIExvY2F0aW9ucyB3aWxsIGJlIGFzc2lnbmVkIGJ5IGluZGV4IGlmIG5vdCBwYXNzZWQgaW5cbiAqIEBwYXJhbSB7bnVtYmVyW119IFtvcHRfbG9jYXRpb25zXSBUaGUgbG9jYXRpb25zIGZvciB0aGUuIEEgcGFyYWxsZWwgYXJyYXkgdG8gb3B0X2F0dHJpYnMgbGV0dGluZyB5b3UgYXNzaWduIGxvY2F0aW9ucy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gb3B0X2Vycm9yQ2FsbGJhY2sgY2FsbGJhY2sgZm9yIGVycm9ycy4gQnkgZGVmYXVsdCBpdCBqdXN0IHByaW50cyBhbiBlcnJvciB0byB0aGUgY29uc29sZVxuICogICAgICAgIG9uIGVycm9yLiBJZiB5b3Ugd2FudCBzb21ldGhpbmcgZWxzZSBwYXNzIGFuIGNhbGxiYWNrLiBJdCdzIHBhc3NlZCBhbiBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybiB7V2ViR0xQcm9ncmFtfSBUaGUgY3JlYXRlZCBwcm9ncmFtLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtRnJvbVNvdXJjZXMoZ2wsIHNoYWRlclNvdXJjZXMsIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICB2YXIgcHJvZ09wdGlvbnMgPSBnZXRQcm9ncmFtT3B0aW9ucyhvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spO1xuICB2YXIgc2hhZGVycyA9IFtdO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBzaGFkZXJTb3VyY2VzLmxlbmd0aDsgKytpaSkge1xuICAgIHZhciBzaGFkZXIgPSBsb2FkU2hhZGVyKGdsLCBzaGFkZXJTb3VyY2VzW2lpXSwgZ2xbZGVmYXVsdFNoYWRlclR5cGVbaWldXSwgcHJvZ09wdGlvbnMuZXJyb3JDYWxsYmFjayk7XG5cbiAgICBpZiAoIXNoYWRlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc2hhZGVycy5wdXNoKHNoYWRlcik7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUHJvZ3JhbShnbCwgc2hhZGVycywgcHJvZ09wdGlvbnMpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYXR0cmlidXRlL3VuaWZvcm0gaXMgYSByZXNlcnZlZC9idWlsdCBpblxuICpcbiAqIEl0IG1ha2VzIG5vIHNlbnNlIHRvIG1lIHdoeSBHTCByZXR1cm5zIHRoZXNlIGJlY2F1c2UgaXQnc1xuICogaWxsZWdhbCB0byBjYWxsIGBnbC5nZXRVbmlmb3JtTG9jYXRpb25gIGFuZCBgZ2wuZ2V0QXR0cmliTG9jYXRpb25gXG4gKiB3aXRoIG5hbWVzIHRoYXQgc3RhcnQgd2l0aCBgZ2xfYCAoYW5kIGB3ZWJnbF9gIGluIFdlYkdMKVxuICpcbiAqIEkgY2FuIG9ubHkgYXNzdW1lIHRoZXkgYXJlIHRoZXJlIGJlY2F1c2UgdGhleSBtaWdodCBjb3VudFxuICogd2hlbiBjb21wdXRpbmcgdGhlIG51bWJlciBvZiB1bmlmb3Jtcy9hdHRyaWJ1dGVzIHVzZWQgd2hlbiB5b3Ugd2FudCB0b1xuICoga25vdyBpZiB5b3UgYXJlIG5lYXIgdGhlIGxpbWl0LiBUaGF0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2VcbiAqIHRvIG1lIGJ1dCB0aGUgZmFjdCB0aGF0IHRoZXNlIGdldCByZXR1cm5lZCBhcmUgaW4gdGhlIHNwZWMuXG4gKlxuICogQHBhcmFtIHtXZWJHTEFjdGl2ZUluZm99IGluZm8gQXMgcmV0dXJuZWQgZnJvbSBgZ2wuZ2V0QWN0aXZlVW5pZm9ybWAgb3JcbiAqICAgIGBnbC5nZXRBY3RpdmVBdHRyaWJgLlxuICogQHJldHVybiB7Ym9vbH0gdHJ1ZSBpZiBpdCdzIHJlc2VydmVkXG4gKi9cblxuXG5mdW5jdGlvbiBpc0J1aWx0SW4oaW5mbykge1xuICB2YXIgbmFtZSA9IGluZm8ubmFtZTtcbiAgcmV0dXJuIG5hbWUuc3RhcnRzV2l0aChcImdsX1wiKSB8fCBuYW1lLnN0YXJ0c1dpdGgoXCJ3ZWJnbF9cIik7XG59XG4vKipcbiAqIENyZWF0ZXMgc2V0dGVyIGZ1bmN0aW9ucyBmb3IgYWxsIHVuaWZvcm1zIG9mIGEgc2hhZGVyXG4gKiBwcm9ncmFtLlxuICpcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLnNldFVuaWZvcm1zfVxuICpcbiAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtIHRoZSBwcm9ncmFtIHRvIGNyZWF0ZSBzZXR0ZXJzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBhbiBvYmplY3Qgd2l0aCBhIHNldHRlciBieSBuYW1lIGZvciBlYWNoIHVuaWZvcm1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlVW5pZm9ybVNldHRlcnMoZ2wsIHByb2dyYW0pIHtcbiAgdmFyIHRleHR1cmVVbml0ID0gMDtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzZXR0ZXIgZm9yIGEgdW5pZm9ybSBvZiB0aGUgZ2l2ZW4gcHJvZ3JhbSB3aXRoIGl0J3NcbiAgICogbG9jYXRpb24gZW1iZWRkZWQgaW4gdGhlIHNldHRlci5cbiAgICogQHBhcmFtIHtXZWJHTFByb2dyYW19IHByb2dyYW1cbiAgICogQHBhcmFtIHtXZWJHTFVuaWZvcm1JbmZvfSB1bmlmb3JtSW5mb1xuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRoZSBjcmVhdGVkIHNldHRlci5cbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pZm9ybVNldHRlcihwcm9ncmFtLCB1bmlmb3JtSW5mbykge1xuICAgIHZhciBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtSW5mby5uYW1lKTtcbiAgICB2YXIgaXNBcnJheSA9IHVuaWZvcm1JbmZvLnNpemUgPiAxICYmIHVuaWZvcm1JbmZvLm5hbWUuc3Vic3RyKC0zKSA9PT0gXCJbMF1cIjtcbiAgICB2YXIgdHlwZSA9IHVuaWZvcm1JbmZvLnR5cGU7XG4gICAgdmFyIHR5cGVJbmZvID0gdHlwZU1hcFt0eXBlXTtcblxuICAgIGlmICghdHlwZUluZm8pIHtcbiAgICAgIHRocm93IFwidW5rbm93biB0eXBlOiAweFwiICsgdHlwZS50b1N0cmluZygxNik7IC8vIHdlIHNob3VsZCBuZXZlciBnZXQgaGVyZS5cbiAgICB9XG5cbiAgICB2YXIgc2V0dGVyO1xuXG4gICAgaWYgKHR5cGVJbmZvLmJpbmRQb2ludCkge1xuICAgICAgLy8gaXQncyBhIHNhbXBsZXJcbiAgICAgIHZhciB1bml0ID0gdGV4dHVyZVVuaXQ7XG4gICAgICB0ZXh0dXJlVW5pdCArPSB1bmlmb3JtSW5mby5zaXplO1xuXG4gICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICBzZXR0ZXIgPSB0eXBlSW5mby5hcnJheVNldHRlcihnbCwgdHlwZSwgdW5pdCwgbG9jYXRpb24sIHVuaWZvcm1JbmZvLnNpemUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0dGVyID0gdHlwZUluZm8uc2V0dGVyKGdsLCB0eXBlLCB1bml0LCBsb2NhdGlvbiwgdW5pZm9ybUluZm8uc2l6ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlSW5mby5hcnJheVNldHRlciAmJiBpc0FycmF5KSB7XG4gICAgICAgIHNldHRlciA9IHR5cGVJbmZvLmFycmF5U2V0dGVyKGdsLCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXR0ZXIgPSB0eXBlSW5mby5zZXR0ZXIoZ2wsIGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR0ZXIubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICByZXR1cm4gc2V0dGVyO1xuICB9XG5cbiAgdmFyIHVuaWZvcm1TZXR0ZXJzID0ge307XG4gIHZhciBudW1Vbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TKTtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbnVtVW5pZm9ybXM7ICsraWkpIHtcbiAgICB2YXIgdW5pZm9ybUluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGlpKTtcblxuICAgIGlmIChpc0J1aWx0SW4odW5pZm9ybUluZm8pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IHVuaWZvcm1JbmZvLm5hbWU7IC8vIHJlbW92ZSB0aGUgYXJyYXkgc3VmZml4LlxuXG4gICAgaWYgKG5hbWUuc3Vic3RyKC0zKSA9PT0gXCJbMF1cIikge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDAsIG5hbWUubGVuZ3RoIC0gMyk7XG4gICAgfVxuXG4gICAgdmFyIHNldHRlciA9IGNyZWF0ZVVuaWZvcm1TZXR0ZXIocHJvZ3JhbSwgdW5pZm9ybUluZm8pO1xuICAgIHVuaWZvcm1TZXR0ZXJzW25hbWVdID0gc2V0dGVyO1xuICB9XG5cbiAgcmV0dXJuIHVuaWZvcm1TZXR0ZXJzO1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUcmFuc2Zvcm1GZWVkYmFja0luZm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleCBpbmRleCBvZiB0cmFuc2Zvcm0gZmVlZGJhY2tcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0eXBlIEdMIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplIDEgLSA0XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBUcmFuc2Zvcm1GZWVkYmFja0luZm8gZm9yIHBhc3NpbmcgdG8gYmluZC91bmJpbmRUcmFuc2Zvcm1GZWVkYmFja0luZm8uXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSBhbiBleGlzdGluZyBXZWJHTFByb2dyYW0uXG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5UcmFuc2Zvcm1GZWVkYmFja0luZm8+fVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1GZWVkYmFja0luZm8oZ2wsIHByb2dyYW0pIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgdmFyIG51bVZhcnlpbmdzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5UUkFOU0ZPUk1fRkVFREJBQ0tfVkFSWUlOR1MpO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1WYXJ5aW5nczsgKytpaSkge1xuICAgIHZhciB2YXJ5aW5nID0gZ2wuZ2V0VHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nKHByb2dyYW0sIGlpKTtcbiAgICBpbmZvW3ZhcnlpbmcubmFtZV0gPSB7XG4gICAgICBpbmRleDogaWksXG4gICAgICB0eXBlOiB2YXJ5aW5nLnR5cGUsXG4gICAgICBzaXplOiB2YXJ5aW5nLnNpemVcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIEJpbmRzIGJ1ZmZlcnMgZm9yIHRyYW5zZm9ybSBmZWVkYmFjay5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5UcmFuc2Zvcm1GZWVkYmFja0luZm8+KX0gdHJhbnNmb3JtRmVlZGJhY2tJbmZvIEEgUHJvZ3JhbUluZm8gb3IgVHJhbnNmb3JtRmVlZGJhY2tJbmZvLlxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuQnVmZmVySW5mb3xPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5BdHRyaWJJbmZvPil9IFtidWZmZXJJbmZvXSBBIEJ1ZmZlckluZm8gb3Igc2V0IG9mIEF0dHJpYkluZm9zLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiBiaW5kVHJhbnNmb3JtRmVlZGJhY2tJbmZvKGdsLCB0cmFuc2Zvcm1GZWVkYmFja0luZm8sIGJ1ZmZlckluZm8pIHtcbiAgaWYgKHRyYW5zZm9ybUZlZWRiYWNrSW5mby50cmFuc2Zvcm1GZWVkYmFja0luZm8pIHtcbiAgICB0cmFuc2Zvcm1GZWVkYmFja0luZm8gPSB0cmFuc2Zvcm1GZWVkYmFja0luZm8udHJhbnNmb3JtRmVlZGJhY2tJbmZvO1xuICB9XG5cbiAgaWYgKGJ1ZmZlckluZm8uYXR0cmlicykge1xuICAgIGJ1ZmZlckluZm8gPSBidWZmZXJJbmZvLmF0dHJpYnM7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIGJ1ZmZlckluZm8pIHtcbiAgICB2YXIgdmFyeWluZyA9IHRyYW5zZm9ybUZlZWRiYWNrSW5mb1tuYW1lXTtcblxuICAgIGlmICh2YXJ5aW5nKSB7XG4gICAgICB2YXIgYnVmID0gYnVmZmVySW5mb1tuYW1lXTtcblxuICAgICAgaWYgKGJ1Zi5vZmZzZXQpIHtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlclJhbmdlKGdsLlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIsIHZhcnlpbmcuaW5kZXgsIGJ1Zi5idWZmZXIsIGJ1Zi5vZmZzZXQsIGJ1Zi5zaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmJpbmRCdWZmZXJCYXNlKGdsLlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIsIHZhcnlpbmcuaW5kZXgsIGJ1Zi5idWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBVbmJpbmRzIGJ1ZmZlcnMgYWZldHIgdHJhbnNmb3JtIGZlZWRiYWNrLlxuICpcbiAqIEJ1ZmZlcnMgY2FuIG5vdCBiZSBib3VuZCB0byAyIGJpbmQgcG9pbnRzIHNvIGlmIHlvdSB0cnkgdG8gYmluZCBhIGJ1ZmZlciB1c2VkXG4gKiBpbiBhIHRyYW5zZm9ybSBmZWVkYmFjayBhcyBhbiBBUlJBWV9CVUZGRVIgZm9yIGFuIGF0dHJpYnV0ZSBpdCB3aWxsIGZhaWwuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB1bmJpbmRzIGFsbCBidWZmZXJzIHRoYXQgd2VyZSBib3VuZCB3aXRoIHtAbGluayBtb2R1bGU6dHdnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2tJbmZvfS5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5UcmFuc2Zvcm1GZWVkYmFja0luZm8+KX0gdHJhbnNmb3JtRmVlZGJhY2tJbmZvIEEgUHJvZ3JhbUluZm8gb3IgVHJhbnNmb3JtRmVlZGJhY2tJbmZvLlxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuQnVmZmVySW5mb3xPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5BdHRyaWJJbmZvPil9IFtidWZmZXJJbmZvXSBBIEJ1ZmZlckluZm8gb3Igc2V0IG9mIEF0dHJpYkluZm9zLlxuICovXG5cblxuZnVuY3Rpb24gdW5iaW5kVHJhbnNmb3JtRmVlZGJhY2tJbmZvKGdsLCB0cmFuc2Zvcm1GZWVkYmFja0luZm8sIGJ1ZmZlckluZm8pIHtcbiAgaWYgKHRyYW5zZm9ybUZlZWRiYWNrSW5mby50cmFuc2Zvcm1GZWVkYmFja0luZm8pIHtcbiAgICB0cmFuc2Zvcm1GZWVkYmFja0luZm8gPSB0cmFuc2Zvcm1GZWVkYmFja0luZm8udHJhbnNmb3JtRmVlZGJhY2tJbmZvO1xuICB9XG5cbiAgaWYgKGJ1ZmZlckluZm8uYXR0cmlicykge1xuICAgIGJ1ZmZlckluZm8gPSBidWZmZXJJbmZvLmF0dHJpYnM7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIGJ1ZmZlckluZm8pIHtcbiAgICB2YXIgdmFyeWluZyA9IHRyYW5zZm9ybUZlZWRiYWNrSW5mb1tuYW1lXTtcblxuICAgIGlmICh2YXJ5aW5nKSB7XG4gICAgICBnbC5iaW5kQnVmZmVyQmFzZShnbC5UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCB2YXJ5aW5nLmluZGV4LCBudWxsKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIHRyYW5zZm9ybSBmZWVkYmFjayBhbmQgc2V0cyB0aGUgYnVmZmVyc1xuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb30gcHJvZ3JhbUluZm8gQSBQcm9ncmFtSW5mbyBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb31cbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLkJ1ZmZlckluZm98T2JqZWN0PHN0cmluZywgbW9kdWxlOnR3Z2wuQXR0cmliSW5mbz4pfSBbYnVmZmVySW5mb10gQSBCdWZmZXJJbmZvIG9yIHNldCBvZiBBdHRyaWJJbmZvcy5cbiAqIEByZXR1cm4ge1dlYkdMVHJhbnNmb3JtRmVlZGJhY2t9IHRoZSBjcmVhdGVkIHRyYW5zZm9ybSBmZWVkYmFja1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1GZWVkYmFjayhnbCwgcHJvZ3JhbUluZm8sIGJ1ZmZlckluZm8pIHtcbiAgdmFyIHRmID0gZ2wuY3JlYXRlVHJhbnNmb3JtRmVlZGJhY2soKTtcbiAgZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKGdsLlRSQU5TRk9STV9GRUVEQkFDSywgdGYpO1xuICBnbC51c2VQcm9ncmFtKHByb2dyYW1JbmZvLnByb2dyYW0pO1xuICBiaW5kVHJhbnNmb3JtRmVlZGJhY2tJbmZvKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbyk7XG4gIGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIG51bGwpOyAvLyBUaGlzIGlzIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYSBidWcgaW4gQ2hyb21lIDU2LiBXaWxsIHJlbW92ZVxuICAvLyB3aGVuIGNocm9tZSBmaXhlcyBpdC5cblxuICB1bmJpbmRUcmFuc2Zvcm1GZWVkYmFja0luZm8oZ2wsIHByb2dyYW1JbmZvLCBidWZmZXJJbmZvKTtcbiAgcmV0dXJuIHRmO1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVbmlmb3JtRGF0YVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHR5cGUgVGhlIFdlYkdMIHR5cGUgZW51bSBmb3IgdGhpcyB1bmlmb3JtXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2l6ZSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGZvciB0aGlzIHVuaWZvcm1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja05keCBUaGUgYmxvY2sgaW5kZXggdGhpcyB1bmlmb3JtIGFwcGVhcnMgaW5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXQgVGhlIGJ5dGUgb2Zmc2V0IGluIHRoZSBibG9jayBmb3IgdGhpcyB1bmlmb3JtJ3MgdmFsdWVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogVGhlIHNwZWNpZmljYXRpb24gZm9yIG9uZSBVbmlmb3JtQmxvY2tPYmplY3RcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCbG9ja1NwZWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGJsb2NrLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpemUgVGhlIHNpemUgaW4gYnl0ZXMgbmVlZGVkIGZvciB0aGUgYmxvY2tcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHVuaWZvcm1JbmRpY2VzIFRoZSBpbmRpY2VzIG9mIHRoZSB1bmlmb3JtcyB1c2VkIGJ5IHRoZSBibG9jay4gVGhlc2UgaW5kaWNlc1xuICogICAgY29ycmVzcG9uZCB0byBlbnRyaWVzIGluIGEgVW5pZm9ybURhdGEgYXJyYXkgaW4gdGhlIHtAbGluayBtb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tTcGVjfS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbH0gdXNlZEJ5VmVydGV4U2hhZGVyIFNlbGYgZXhwbGFuaXRvcnlcbiAqIEBwcm9wZXJ0eSB7Ym9vbH0gdXNlZEJ5RnJhZ21lbnRTaGFkZXIgU2VsZiBleHBsYW5pdG9yeVxuICogQHByb3BlcnR5IHtib29sfSB1c2VkIFNlbGYgZXhwbGFuaXRvcnlcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQSBgVW5pZm9ybUJsb2NrU3BlY2AgcmVwcmVzZW50cyB0aGUgZGF0YSBuZWVkZWQgdG8gY3JlYXRlIGFuZCBiaW5kXG4gKiBVbmlmb3JtQmxvY2tPYmplY3RzIGZvciBhIGdpdmVuIHByb2dyYW1cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVbmlmb3JtQmxvY2tTcGVjXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBtb2R1bGU6dHdnbC5CbG9ja1NwZWM+IGJsb2NrU3BlY3MgVGhlIEJsb2NrU3BlYyBmb3IgZWFjaCBibG9jayBieSBibG9jayBuYW1lXG4gKiBAcHJvcGVydHkge1VuaWZvcm1EYXRhW119IHVuaWZvcm1EYXRhIEFuIGFycmF5IG9mIGRhdGEgZm9yIGVhY2ggdW5pZm9ybSBieSB1bmlmb3JtIGluZGV4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgVW5pZm9ybUJsb2NrU3BlYyBmb3IgdGhlIGdpdmVuIHByb2dyYW0uXG4gKlxuICogQSBVbmlmb3JtQmxvY2tTcGVjIHJlcHJlc2VudHMgdGhlIGRhdGEgbmVlZGVkIHRvIGNyZWF0ZSBhbmQgYmluZFxuICogVW5pZm9ybUJsb2NrT2JqZWN0c1xuICpcbiAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTDIgUmVuZGVyaW5nIENvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtIEEgV2ViR0xQcm9ncmFtIGZvciBhIHN1Y2Nlc3NmdWxseSBsaW5rZWQgcHJvZ3JhbVxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrU3BlY30gVGhlIGNyZWF0ZWQgVW5pZm9ybUJsb2NrU3BlY1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVVbmlmb3JtQmxvY2tTcGVjRnJvbVByb2dyYW0oZ2wsIHByb2dyYW0pIHtcbiAgdmFyIG51bVVuaWZvcm1zID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuICB2YXIgdW5pZm9ybURhdGEgPSBbXTtcbiAgdmFyIHVuaWZvcm1JbmRpY2VzID0gW107XG5cbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG51bVVuaWZvcm1zOyArK2lpKSB7XG4gICAgdW5pZm9ybUluZGljZXMucHVzaChpaSk7XG4gICAgdW5pZm9ybURhdGEucHVzaCh7fSk7XG4gICAgdmFyIHVuaWZvcm1JbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpaSk7XG5cbiAgICBpZiAoaXNCdWlsdEluKHVuaWZvcm1JbmZvKSkge1xuICAgICAgYnJlYWs7XG4gICAgfSAvLyBSRU1PVkUgWzBdP1xuXG5cbiAgICB1bmlmb3JtRGF0YVtpaV0ubmFtZSA9IHVuaWZvcm1JbmZvLm5hbWU7XG4gIH1cblxuICBbW1wiVU5JRk9STV9UWVBFXCIsIFwidHlwZVwiXSwgW1wiVU5JRk9STV9TSVpFXCIsIFwic2l6ZVwiXSwgLy8gbnVtIGVsZW1lbnRzXG4gIFtcIlVOSUZPUk1fQkxPQ0tfSU5ERVhcIiwgXCJibG9ja05keFwiXSwgW1wiVU5JRk9STV9PRkZTRVRcIiwgXCJvZmZzZXRcIl1dLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICB2YXIgcG5hbWUgPSBwYWlyWzBdO1xuICAgIHZhciBrZXkgPSBwYWlyWzFdO1xuICAgIGdsLmdldEFjdGl2ZVVuaWZvcm1zKHByb2dyYW0sIHVuaWZvcm1JbmRpY2VzLCBnbFtwbmFtZV0pLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBuZHgpIHtcbiAgICAgIHVuaWZvcm1EYXRhW25keF1ba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICB9KTtcbiAgdmFyIGJsb2NrU3BlY3MgPSB7fTtcbiAgdmFyIG51bVVuaWZvcm1CbG9ja3MgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNX0JMT0NLUyk7XG5cbiAgZm9yICh2YXIgX2lpID0gMDsgX2lpIDwgbnVtVW5pZm9ybUJsb2NrczsgKytfaWkpIHtcbiAgICB2YXIgbmFtZSA9IGdsLmdldEFjdGl2ZVVuaWZvcm1CbG9ja05hbWUocHJvZ3JhbSwgX2lpKTtcbiAgICB2YXIgYmxvY2tTcGVjID0ge1xuICAgICAgaW5kZXg6IF9paSxcbiAgICAgIHVzZWRCeVZlcnRleFNoYWRlcjogZ2wuZ2V0QWN0aXZlVW5pZm9ybUJsb2NrUGFyYW1ldGVyKHByb2dyYW0sIF9paSwgZ2wuVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX1ZFUlRFWF9TSEFERVIpLFxuICAgICAgdXNlZEJ5RnJhZ21lbnRTaGFkZXI6IGdsLmdldEFjdGl2ZVVuaWZvcm1CbG9ja1BhcmFtZXRlcihwcm9ncmFtLCBfaWksIGdsLlVOSUZPUk1fQkxPQ0tfUkVGRVJFTkNFRF9CWV9GUkFHTUVOVF9TSEFERVIpLFxuICAgICAgc2l6ZTogZ2wuZ2V0QWN0aXZlVW5pZm9ybUJsb2NrUGFyYW1ldGVyKHByb2dyYW0sIF9paSwgZ2wuVU5JRk9STV9CTE9DS19EQVRBX1NJWkUpLFxuICAgICAgdW5pZm9ybUluZGljZXM6IGdsLmdldEFjdGl2ZVVuaWZvcm1CbG9ja1BhcmFtZXRlcihwcm9ncmFtLCBfaWksIGdsLlVOSUZPUk1fQkxPQ0tfQUNUSVZFX1VOSUZPUk1fSU5ESUNFUylcbiAgICB9O1xuICAgIGJsb2NrU3BlYy51c2VkID0gYmxvY2tTcGVjLnVzZWRCeVZlcnRleFNhaGRlciB8fCBibG9ja1NwZWMudXNlZEJ5RnJhZ21lbnRTaGFkZXI7XG4gICAgYmxvY2tTcGVjc1tuYW1lXSA9IGJsb2NrU3BlYztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmxvY2tTcGVjczogYmxvY2tTcGVjcyxcbiAgICB1bmlmb3JtRGF0YTogdW5pZm9ybURhdGFcbiAgfTtcbn1cblxudmFyIGFycmF5U3VmZml4UkUgPSAvXFxbXFxkK1xcXVxcLiQvOyAvLyBiZXR0ZXIgd2F5IHRvIGNoZWNrP1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBVbmlmb3JtQmxvY2tPYmplY3QgaW5jbHVkaW5nIGFuIEFycmF5QnVmZmVyIHdpdGggYWxsIHRoZSB1bmlmb3JtIHZhbHVlc1xuICogYW5kIGEgY29ycmVzcG9uZGluZyBXZWJHTEJ1ZmZlciB0byBob2xkIHRob3NlIHZhbHVlcyBvbiB0aGUgR1BVXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVW5pZm9ybUJsb2NrSW5mb1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGJsb2NrXG4gKiBAcHJvcGVydHkge0FycmF5QnVmZmVyfSBhcnJheSBUaGUgYXJyYXkgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHVuaWZvcm0gdmFsdWVzXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gYXNGbG9hdCBBIGZsb2F0IHZpZXcgb24gdGhlIGFycmF5IGJ1ZmZlci4gVGhpcyBpcyB1c2VmdWxcbiAqICAgIGluc3BlY3RpbmcgdGhlIGNvbnRlbnRzIG9mIHRoZSBidWZmZXIgaW4gdGhlIGRlYnVnZ2VyLlxuICogQHByb3BlcnR5IHtXZWJHTEJ1ZmZlcn0gYnVmZmVyIEEgV2ViR0wgYnVmZmVyIHRoYXQgd2lsbCBob2xkIGEgY29weSBvZiB0aGUgdW5pZm9ybSB2YWx1ZXMgZm9yIHJlbmRlcmluZy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb2Zmc2V0XSBvZmZzZXQgaW50byBidWZmZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIEFycmF5QnVmZmVyVmlldz59IHVuaWZvcm1zIEEgdW5pZm9ybSBuYW1lIHRvIEFycmF5QnVmZmVyVmlldyBtYXAuXG4gKiAgIGVhY2ggVW5pZm9ybSBoYXMgYSBjb3JyZWN0bHkgdHlwZWQgYEFycmF5QnVmZmVyVmlld2AgaW50byBhcnJheSBhdCB0aGUgY29ycmVjdCBvZmZzZXRcbiAqICAgYW5kIGxlbmd0aCBvZiB0aGF0IHVuaWZvcm0uIFNvIGZvciBleGFtcGxlIGEgZmxvYXQgdW5pZm9ybSB3b3VsZCBoYXZlIGEgMSBmbG9hdCBgRmxvYXQzMkFycmF5YFxuICogICB2aWV3LiBBIHNpbmdsZSBtYXQ0IHdvdWxkIGhhdmUgYSAxNiBlbGVtZW50IGBGbG9hdDMyQXJyYXlgIHZpZXcuIEFuIGl2ZWMyIHdvdWxkIGhhdmUgYW5cbiAqICAgYEludDMyQXJyYXlgIHZpZXcsIGV0Yy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGBVbmlmb3JtQmxvY2tJbmZvYCBmb3IgdGhlIHNwZWNpZmllZCBibG9ja1xuICpcbiAqIE5vdGU6ICoqSWYgdGhlIGJsb2NrTmFtZSBtYXRjaGVzIG5vIGV4aXN0aW5nIGJsb2NrcyBhIHdhcm5pbmcgaXMgcHJpbnRlZCB0byB0aGUgY29uc29sZSBhbmQgYSBkdW1teVxuICogYFVuaWZvcm1CbG9ja0luZm9gIGlzIHJldHVybmVkKiouIFRoaXMgaXMgYmVjYXVzZSB3aGVuIGRlYnVnZ2luZyBHTFNMXG4gKiBpdCBpcyBjb21tb24gdG8gY29tbWVudCBvdXQgbGFyZ2UgcG9ydGlvbnMgb2YgYSBzaGFkZXIgb3IgZm9yIGV4YW1wbGUgc2V0XG4gKiB0aGUgZmluYWwgb3V0cHV0IHRvIGEgY29uc3RhbnQuIFdoZW4gdGhhdCBoYXBwZW5zIGJsb2NrcyBnZXQgb3B0aW1pemVkIG91dC5cbiAqIElmIHRoaXMgZnVuY3Rpb24gZGlkIG5vdCBjcmVhdGUgZHVtbXkgYmxvY2tzIHlvdXIgY29kZSB3b3VsZCBjcmFzaCB3aGVuIGRlYnVnZ2luZy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFByb2dyYW19IHByb2dyYW0gQSBXZWJHTFByb2dyYW1cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrU3BlY30gdWluZm9ybUJsb2NrU3BlYy4gQSBVbmlmb3JtQmxvY2tTcGVjIGFzIHJldHVybmVkXG4gKiAgICAgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja05hbWUgVGhlIG5hbWUgb2YgdGhlIGJsb2NrLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrSW5mb30gVGhlIGNyZWF0ZWQgVW5pZm9ybUJsb2NrSW5mb1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlVW5pZm9ybUJsb2NrSW5mb0Zyb21Qcm9ncmFtKGdsLCBwcm9ncmFtLCB1bmlmb3JtQmxvY2tTcGVjLCBibG9ja05hbWUpIHtcbiAgdmFyIGJsb2NrU3BlY3MgPSB1bmlmb3JtQmxvY2tTcGVjLmJsb2NrU3BlY3M7XG4gIHZhciB1bmlmb3JtRGF0YSA9IHVuaWZvcm1CbG9ja1NwZWMudW5pZm9ybURhdGE7XG4gIHZhciBibG9ja1NwZWMgPSBibG9ja1NwZWNzW2Jsb2NrTmFtZV07XG5cbiAgaWYgKCFibG9ja1NwZWMpIHtcbiAgICB3YXJuKFwibm8gdW5pZm9ybSBibG9jayBvYmplY3QgbmFtZWQ6XCIsIGJsb2NrTmFtZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGJsb2NrTmFtZSxcbiAgICAgIHVuaWZvcm1zOiB7fVxuICAgIH07XG4gIH1cblxuICB2YXIgYXJyYXkgPSBuZXcgQXJyYXlCdWZmZXIoYmxvY2tTcGVjLnNpemUpO1xuICB2YXIgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gIHZhciB1bmlmb3JtQnVmZmVySW5kZXggPSBibG9ja1NwZWMuaW5kZXg7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuVU5JRk9STV9CVUZGRVIsIGJ1ZmZlcik7XG4gIGdsLnVuaWZvcm1CbG9ja0JpbmRpbmcocHJvZ3JhbSwgYmxvY2tTcGVjLmluZGV4LCB1bmlmb3JtQnVmZmVySW5kZXgpO1xuICB2YXIgcHJlZml4ID0gYmxvY2tOYW1lICsgXCIuXCI7XG5cbiAgaWYgKGFycmF5U3VmZml4UkUudGVzdChwcmVmaXgpKSB7XG4gICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoYXJyYXlTdWZmaXhSRSwgXCIuXCIpO1xuICB9XG5cbiAgdmFyIHVuaWZvcm1zID0ge307XG4gIGJsb2NrU3BlYy51bmlmb3JtSW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uICh1bmlmb3JtTmR4KSB7XG4gICAgdmFyIGRhdGEgPSB1bmlmb3JtRGF0YVt1bmlmb3JtTmR4XTtcbiAgICB2YXIgdHlwZUluZm8gPSB0eXBlTWFwW2RhdGEudHlwZV07XG4gICAgdmFyIFR5cGUgPSB0eXBlSW5mby5UeXBlO1xuICAgIHZhciBsZW5ndGggPSBkYXRhLnNpemUgKiB0eXBlSW5mby5zaXplO1xuICAgIHZhciBuYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgaWYgKG5hbWUuc3Vic3RyKDAsIHByZWZpeC5sZW5ndGgpID09PSBwcmVmaXgpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cihwcmVmaXgubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB1bmlmb3Jtc1tuYW1lXSA9IG5ldyBUeXBlKGFycmF5LCBkYXRhLm9mZnNldCwgbGVuZ3RoIC8gVHlwZS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IGJsb2NrTmFtZSxcbiAgICBhcnJheTogYXJyYXksXG4gICAgYXNGbG9hdDogbmV3IEZsb2F0MzJBcnJheShhcnJheSksXG4gICAgLy8gZm9yIGRlYnVnZ2luZ1xuICAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgIHVuaWZvcm1zOiB1bmlmb3Jtc1xuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFVuaWZvcm1CbG9ja0luZm9gIGZvciB0aGUgc3BlY2lmaWVkIGJsb2NrXG4gKlxuICogTm90ZTogKipJZiB0aGUgYmxvY2tOYW1lIG1hdGNoZXMgbm8gZXhpc3RpbmcgYmxvY2tzIGEgd2FybmluZyBpcyBwcmludGVkIHRvIHRoZSBjb25zb2xlIGFuZCBhIGR1bW15XG4gKiBgVW5pZm9ybUJsb2NrSW5mb2AgaXMgcmV0dXJuZWQqKi4gVGhpcyBpcyBiZWNhdXNlIHdoZW4gZGVidWdnaW5nIEdMU0xcbiAqIGl0IGlzIGNvbW1vbiB0byBjb21tZW50IG91dCBsYXJnZSBwb3J0aW9ucyBvZiBhIHNoYWRlciBvciBmb3IgZXhhbXBsZSBzZXRcbiAqIHRoZSBmaW5hbCBvdXRwdXQgdG8gYSBjb25zdGFudC4gV2hlbiB0aGF0IGhhcHBlbnMgYmxvY2tzIGdldCBvcHRpbWl6ZWQgb3V0LlxuICogSWYgdGhpcyBmdW5jdGlvbiBkaWQgbm90IGNyZWF0ZSBkdW1teSBibG9ja3MgeW91ciBjb2RlIHdvdWxkIGNyYXNoIHdoZW4gZGVidWdnaW5nLlxuICpcbiAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBwcm9ncmFtSW5mbyBhIGBQcm9ncmFtSW5mb2BcbiAqICAgICBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb31cbiAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja05hbWUgVGhlIG5hbWUgb2YgdGhlIGJsb2NrLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrSW5mb30gVGhlIGNyZWF0ZWQgVW5pZm9ybUJsb2NrSW5mb1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvKGdsLCBwcm9ncmFtSW5mbywgYmxvY2tOYW1lKSB7XG4gIHJldHVybiBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvRnJvbVByb2dyYW0oZ2wsIHByb2dyYW1JbmZvLnByb2dyYW0sIHByb2dyYW1JbmZvLnVuaWZvcm1CbG9ja1NwZWMsIGJsb2NrTmFtZSk7XG59XG4vKipcbiAqIEJpbmRzIGEgdW5mb3JtIGJsb2NrIHRvIHRoZSBtYXRjaGluZyB1bmlmb3JtIGJsb2NrIHBvaW50LlxuICogTWF0Y2hlcyBieSBibG9ja3MgYnkgbmFtZSBzbyBibG9ja3MgbXVzdCBoYXZlIHRoZSBzYW1lIG5hbWUgbm90IGp1c3QgdGhlIHNhbWVcbiAqIHN0cnVjdHVyZS5cbiAqXG4gKiBJZiB5b3UgaGF2ZSBjaGFuZ2VkIGFueSB2YWx1ZXMgYW5kIHlvdSB1cGxvYWQgdGhlIHZhbHVzIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgV2ViR0xCdWZmZXJcbiAqIGNhbGwge0BsaW5rIG1vZHVsZTp0d2dsLnNldFVuaWZvcm1CbG9ja30gaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0wgMiByZW5kZXJpbmcgY29udGV4dC5cbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvfG1vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja1NwZWMpfSBwcm9ncmFtSW5mbyBhIGBQcm9ncmFtSW5mb2BcbiAqICAgICBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb30gb3Igb3IgYFVuaWZvcm1CbG9ja1NwZWNgIGFzXG4gKiAgICAgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtfS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrSW5mb30gdW5pZm9ybUJsb2NrSW5mbyBhIGBVbmlmb3JtQmxvY2tJbmZvYCBhcyByZXR1cm5lZCBmcm9tXG4gKiAgICAge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVVuaWZvcm1CbG9ja0luZm99LlxuICogQHJldHVybiB7Ym9vbH0gdHJ1ZSBpZiBidWZmZXIgd2FzIGJvdW5kLiBJZiB0aGUgcHJvZ3JhbUluZm8gaGFzIG5vIGJsb2NrIHdpdGggdGhlIHNhbWUgYmxvY2sgbmFtZVxuICogICAgIG5vIGJ1ZmZlciBpcyBib3VuZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gYmluZFVuaWZvcm1CbG9jayhnbCwgcHJvZ3JhbUluZm8sIHVuaWZvcm1CbG9ja0luZm8pIHtcbiAgdmFyIHVuaWZvcm1CbG9ja1NwZWMgPSBwcm9ncmFtSW5mby51bmlmb3JtQmxvY2tTcGVjIHx8IHByb2dyYW1JbmZvO1xuICB2YXIgYmxvY2tTcGVjID0gdW5pZm9ybUJsb2NrU3BlYy5ibG9ja1NwZWNzW3VuaWZvcm1CbG9ja0luZm8ubmFtZV07XG5cbiAgaWYgKGJsb2NrU3BlYykge1xuICAgIHZhciBidWZmZXJCaW5kSW5kZXggPSBibG9ja1NwZWMuaW5kZXg7XG4gICAgZ2wuYmluZEJ1ZmZlclJhbmdlKGdsLlVOSUZPUk1fQlVGRkVSLCBidWZmZXJCaW5kSW5kZXgsIHVuaWZvcm1CbG9ja0luZm8uYnVmZmVyLCB1bmlmb3JtQmxvY2tJbmZvLm9mZnNldCB8fCAwLCB1bmlmb3JtQmxvY2tJbmZvLmFycmF5LmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBVcGxvYWRzIHRoZSBjdXJyZW50IHVuaWZvcm0gdmFsdWVzIHRvIHRoZSBjb3JyZXNwb25kaW5nIFdlYkdMQnVmZmVyXG4gKiBhbmQgYmluZHMgdGhhdCBidWZmZXIgdG8gdGhlIHByb2dyYW0ncyBjb3JyZXNwb25kaW5nIGJpbmQgcG9pbnQgZm9yIHRoZSB1bmlmb3JtIGJsb2NrIG9iamVjdC5cbiAqXG4gKiBJZiB5b3UgaGF2ZW4ndCBjaGFuZ2VkIGFueSB2YWx1ZXMgYW5kIHlvdSBvbmx5IG5lZWQgdG8gYmluZCB0aGUgdW5pZm9ybSBibG9jayBvYmplY3RcbiAqIGNhbGwge0BsaW5rIG1vZHVsZTp0d2dsLmJpbmRVbmlmb3JtQmxvY2t9IGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHtXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMIDIgcmVuZGVyaW5nIGNvbnRleHQuXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xtb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tTcGVjKX0gcHJvZ3JhbUluZm8gYSBgUHJvZ3JhbUluZm9gXG4gKiAgICAgYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlUHJvZ3JhbUluZm99IG9yIG9yIGBVbmlmb3JtQmxvY2tTcGVjYCBhc1xuICogICAgIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVVuaWZvcm1CbG9ja1NwZWNGcm9tUHJvZ3JhbX0uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja0luZm99IHVuaWZvcm1CbG9ja0luZm8gYSBgVW5pZm9ybUJsb2NrSW5mb2AgYXMgcmV0dXJuZWQgZnJvbVxuICogICAgIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVVbmlmb3JtQmxvY2tJbmZvfS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gc2V0VW5pZm9ybUJsb2NrKGdsLCBwcm9ncmFtSW5mbywgdW5pZm9ybUJsb2NrSW5mbykge1xuICBpZiAoYmluZFVuaWZvcm1CbG9jayhnbCwgcHJvZ3JhbUluZm8sIHVuaWZvcm1CbG9ja0luZm8pKSB7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5VTklGT1JNX0JVRkZFUiwgdW5pZm9ybUJsb2NrSW5mby5hcnJheSwgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgfVxufVxuLyoqXG4gKiBTZXRzIHZhbHVlcyBvZiBhIHVuaWZvcm0gYmxvY2sgb2JqZWN0XG4gKlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tJbmZvfSB1bmlmb3JtQmxvY2tJbmZvIEEgVW5pZm9ybUJsb2NrSW5mbyBhcyByZXR1cm5lZCBieSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVW5pZm9ybUJsb2NrSW5mb30uXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCA/Pn0gdmFsdWVzIEEgdW5pZm9ybSBuYW1lIHRvIHZhbHVlIG1hcCB3aGVyZSB0aGUgdmFsdWUgaXMgY29ycmVjdCBmb3IgdGhlIGdpdmVuXG4gKiAgICB0eXBlIG9mIHVuaWZvcm0uIFNvIGZvciBleGFtcGxlIGdpdmVuIGEgYmxvY2sgbGlrZVxuICpcbiAqICAgICAgIHVuaWZvcm0gU29tZUJsb2NrIHtcbiAqICAgICAgICAgZmxvYXQgc29tZUZsb2F0O1xuICogICAgICAgICB2ZWMyIHNvbWVWZWMyO1xuICogICAgICAgICB2ZWMzIHNvbWVWZWMzQXJyYXlbMl07XG4gKiAgICAgICAgIGludCBzb21lSW50O1xuICogICAgICAgfVxuICpcbiAqICBZb3UgY2FuIHNldCB0aGUgdmFsdWVzIG9mIHRoZSB1bmlmb3JtIGJsb2NrIHdpdGhcbiAqXG4gKiAgICAgICB0d2dsLnNldEJsb2NrVW5pZm9ybXMoc29tZUJsb2NrSW5mbywge1xuICogICAgICAgICAgc29tZUZsb2F0OiAxMi4zLFxuICogICAgICAgICAgc29tZVZlYzI6IFsxLCAyXSxcbiAqICAgICAgICAgIHNvbWVWZWMzQXJyYXk6IFsxLCAyLCAzLCA0LCA1LCA2XSxcbiAqICAgICAgICAgIHNvbWVJbnQ6IDUsXG4gKiAgICAgICB9XG4gKlxuICogIEFycmF5cyBjYW4gYmUgSmF2YVNjcmlwdCBhcnJheXMgb3IgdHlwZWQgYXJyYXlzXG4gKlxuICogIEFueSBuYW1lIHRoYXQgZG9lc24ndCBtYXRjaCB3aWxsIGJlIGlnbm9yZWRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gc2V0QmxvY2tVbmlmb3Jtcyh1bmlmb3JtQmxvY2tJbmZvLCB2YWx1ZXMpIHtcbiAgdmFyIHVuaWZvcm1zID0gdW5pZm9ybUJsb2NrSW5mby51bmlmb3JtcztcblxuICBmb3IgKHZhciBuYW1lIGluIHZhbHVlcykge1xuICAgIHZhciBhcnJheSA9IHVuaWZvcm1zW25hbWVdO1xuXG4gICAgaWYgKGFycmF5KSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgYXJyYXkuc2V0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5WzBdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFNldCB1bmlmb3JtcyBhbmQgYmluZHMgcmVsYXRlZCB0ZXh0dXJlcy5cbiAqXG4gKiBleGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBwcm9ncmFtSW5mbyA9IGNyZWF0ZVByb2dyYW1JbmZvKFxuICogICAgICAgICBnbCwgW1wic29tZS12c1wiLCBcInNvbWUtZnNcIl0pO1xuICpcbiAqICAgICBjb25zdCB0ZXgxID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICogICAgIGNvbnN0IHRleDIgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gKlxuICogICAgIC4uLiBhc3N1bWUgd2Ugc2V0dXAgdGhlIHRleHR1cmVzIHdpdGggZGF0YSAuLi5cbiAqXG4gKiAgICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gKiAgICAgICB1X3NvbWVTYW1wbGVyOiB0ZXgxLFxuICogICAgICAgdV9zb21lT3RoZXJTYW1wbGVyOiB0ZXgyLFxuICogICAgICAgdV9zb21lQ29sb3I6IFsxLDAsMCwxXSxcbiAqICAgICAgIHVfc29tZVBvc2l0aW9uOiBbMCwxLDFdLFxuICogICAgICAgdV9zb21lTWF0cml4OiBbXG4gKiAgICAgICAgIDEsMCwwLDAsXG4gKiAgICAgICAgIDAsMSwwLDAsXG4gKiAgICAgICAgIDAsMCwxLDAsXG4gKiAgICAgICAgIDAsMCwwLDAsXG4gKiAgICAgICBdLFxuICogICAgIH07XG4gKlxuICogICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gKlxuICogVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgYmluZCB0aGUgdGV4dHVyZXMgQU5EIHNldCB0aGVcbiAqIHVuaWZvcm1zLlxuICpcbiAqICAgICB0d2dsLnNldFVuaWZvcm1zKHByb2dyYW1JbmZvLCB1bmlmb3Jtcyk7XG4gKlxuICogRm9yIHRoZSBleGFtcGxlIGFib3ZlIGl0IGlzIGVxdWl2YWxlbnQgdG9cbiAqXG4gKiAgICAgdmFyIHRleFVuaXQgPSAwO1xuICogICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXhVbml0KTtcbiAqICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXgxKTtcbiAqICAgICBnbC51bmlmb3JtMWkodV9zb21lU2FtcGxlckxvY2F0aW9uLCB0ZXhVbml0KyspO1xuICogICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXhVbml0KTtcbiAqICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXgyKTtcbiAqICAgICBnbC51bmlmb3JtMWkodV9zb21lU2FtcGxlckxvY2F0aW9uLCB0ZXhVbml0KyspO1xuICogICAgIGdsLnVuaWZvcm00ZnYodV9zb21lQ29sb3JMb2NhdGlvbiwgWzEsIDAsIDAsIDFdKTtcbiAqICAgICBnbC51bmlmb3JtM2Z2KHVfc29tZVBvc2l0aW9uTG9jYXRpb24sIFswLCAxLCAxXSk7XG4gKiAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih1X3NvbWVNYXRyaXgsIGZhbHNlLCBbXG4gKiAgICAgICAgIDEsMCwwLDAsXG4gKiAgICAgICAgIDAsMSwwLDAsXG4gKiAgICAgICAgIDAsMCwxLDAsXG4gKiAgICAgICAgIDAsMCwwLDAsXG4gKiAgICAgICBdKTtcbiAqXG4gKiBOb3RlIGl0IGlzIHBlcmZlY3RseSByZWFzb25hYmxlIHRvIGNhbGwgYHNldFVuaWZvcm1zYCBtdWx0aXBsZSB0aW1lcy4gRm9yIGV4YW1wbGVcbiAqXG4gKiAgICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gKiAgICAgICB1X3NvbWVTYW1wbGVyOiB0ZXgxLFxuICogICAgICAgdV9zb21lT3RoZXJTYW1wbGVyOiB0ZXgyLFxuICogICAgIH07XG4gKlxuICogICAgIGNvbnN0IG1vcmVVbmlmb3JtcyB7XG4gKiAgICAgICB1X3NvbWVDb2xvcjogWzEsMCwwLDFdLFxuICogICAgICAgdV9zb21lUG9zaXRpb246IFswLDEsMV0sXG4gKiAgICAgICB1X3NvbWVNYXRyaXg6IFtcbiAqICAgICAgICAgMSwwLDAsMCxcbiAqICAgICAgICAgMCwxLDAsMCxcbiAqICAgICAgICAgMCwwLDEsMCxcbiAqICAgICAgICAgMCwwLDAsMCxcbiAqICAgICAgIF0sXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgdW5pZm9ybXMpO1xuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIG1vcmVVbmlmb3Jtcyk7XG4gKlxuICogWW91IGNhbiBhbHNvIGFkZCBXZWJHTFNhbXBsZXJzIHRvIHVuaWZvcm0gc2FtcGxlcnMgYXMgaW5cbiAqXG4gKiAgICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gKiAgICAgICB1X3NvbWVTYW1wbGVyOiB7XG4gKiAgICAgICAgIHRleHR1cmU6IHNvbWVXZWJHTFRleHR1cmUsXG4gKiAgICAgICAgIHNhbXBsZXI6IHNvbWVXZWJHTFNhbXBsZXIsXG4gKiAgICAgICB9LFxuICogICAgIH07XG4gKlxuICogSW4gd2hpY2ggY2FzZSBib3RoIHRoZSBzYW1wbGVyIGFuZCB0ZXh0dXJlIHdpbGwgYmUgYm91bmQgdG8gdGhlXG4gKiBzYW1lIHVuaXQuXG4gKlxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuUHJvZ3JhbUluZm98T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPil9IHNldHRlcnMgYSBgUHJvZ3JhbUluZm9gIGFzIHJldHVybmVkIGZyb20gYGNyZWF0ZVByb2dyYW1JbmZvYCBvciB0aGUgc2V0dGVycyByZXR1cm5lZCBmcm9tXG4gKiAgICAgICAgYGNyZWF0ZVVuaWZvcm1TZXR0ZXJzYC5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsID8+fSB2YWx1ZXMgYW4gb2JqZWN0IHdpdGggdmFsdWVzIGZvciB0aGVcbiAqICAgICAgICB1bmlmb3Jtcy5cbiAqICAgWW91IGNhbiBwYXNzIG11bHRpcGxlIG9iamVjdHMgYnkgcHV0dGluZyB0aGVtIGluIGFuIGFycmF5IG9yIGJ5IGNhbGxpbmcgd2l0aCBtb3JlIGFyZ3VtZW50cy5Gb3IgZXhhbXBsZVxuICpcbiAqICAgICBjb25zdCBzaGFyZWRVbmlmb3JtcyA9IHtcbiAqICAgICAgIHVfZm9nTmVhcjogMTAsXG4gKiAgICAgICB1X3Byb2plY3Rpb246IC4uLlxuICogICAgICAgLi4uXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgY29uc3QgbG9jYWxVbmlmb3JtcyA9IHtcbiAqICAgICAgIHVfd29ybGQ6IC4uLlxuICogICAgICAgdV9kaWZmdXNlQ29sb3I6IC4uLlxuICogICAgIH07XG4gKlxuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIHNoYXJlZFVuaWZvcm1zLCBsb2NhbFVuaWZvcm1zKTtcbiAqXG4gKiAgICAgLy8gaXMgdGhlIHNhbWUgYXNcbiAqXG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgW3NoYXJlZFVuaWZvcm1zLCBsb2NhbFVuaWZvcm1zXSk7XG4gKlxuICogICAgIC8vIGlzIHRoZSBzYW1lIGFzXG4gKlxuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIHNoYXJlZFVuaWZvcm1zKTtcbiAqICAgICB0d2dsLnNldFVuaWZvcm1zKHByb2dyYW1JbmZvLCBsb2NhbFVuaWZvcm1zfTtcbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFVuaWZvcm1zKHNldHRlcnMsIHZhbHVlcykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHZhciBhY3R1YWxTZXR0ZXJzID0gc2V0dGVycy51bmlmb3JtU2V0dGVycyB8fCBzZXR0ZXJzO1xuICB2YXIgbnVtQXJncyA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgYW5keCA9IDE7IGFuZHggPCBudW1BcmdzOyArK2FuZHgpIHtcbiAgICB2YXIgdmFscyA9IGFyZ3VtZW50c1thbmR4XTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHMpKSB7XG4gICAgICB2YXIgbnVtVmFsdWVzID0gdmFscy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1WYWx1ZXM7ICsraWkpIHtcbiAgICAgICAgc2V0VW5pZm9ybXMoYWN0dWFsU2V0dGVycywgdmFsc1tpaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHZhbHMpIHtcbiAgICAgICAgdmFyIHNldHRlciA9IGFjdHVhbFNldHRlcnNbbmFtZV07XG5cbiAgICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICAgIHNldHRlcih2YWxzW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIHNldHRlciBmdW5jdGlvbnMgZm9yIGFsbCBhdHRyaWJ1dGVzIG9mIGEgc2hhZGVyXG4gKiBwcm9ncmFtLiBZb3UgY2FuIHBhc3MgdGhpcyB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9IHRvIHNldCBhbGwgeW91ciBidWZmZXJzIGFuZCBhdHRyaWJ1dGVzLlxuICpcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLnNldEF0dHJpYnV0ZXN9IGZvciBleGFtcGxlXG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSB0aGUgcHJvZ3JhbSB0byBjcmVhdGUgc2V0dGVycyBmb3IuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBhbiBvYmplY3Qgd2l0aCBhIHNldHRlciBmb3IgZWFjaCBhdHRyaWJ1dGUgYnkgbmFtZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlU2V0dGVycyhnbCwgcHJvZ3JhbSkge1xuICB2YXIgYXR0cmliU2V0dGVycyA9IHt9O1xuICB2YXIgbnVtQXR0cmlicyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1BdHRyaWJzOyArK2lpKSB7XG4gICAgdmFyIGF0dHJpYkluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaWkpO1xuXG4gICAgaWYgKGlzQnVpbHRJbihhdHRyaWJJbmZvKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmliSW5mby5uYW1lKTtcbiAgICB2YXIgdHlwZUluZm8gPSBhdHRyVHlwZU1hcFthdHRyaWJJbmZvLnR5cGVdO1xuICAgIHZhciBzZXR0ZXIgPSB0eXBlSW5mby5zZXR0ZXIoZ2wsIGluZGV4LCB0eXBlSW5mbyk7XG4gICAgc2V0dGVyLmxvY2F0aW9uID0gaW5kZXg7XG4gICAgYXR0cmliU2V0dGVyc1thdHRyaWJJbmZvLm5hbWVdID0gc2V0dGVyO1xuICB9XG5cbiAgcmV0dXJuIGF0dHJpYlNldHRlcnM7XG59XG4vKipcbiAqIFNldHMgYXR0cmlidXRlcyBhbmQgYmluZHMgYnVmZmVycyAoZGVwcmVjYXRlZC4uLiB1c2Uge0BsaW5rIG1vZHVsZTp0d2dsLnNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzfSlcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzKFxuICogICAgICAgICBnbCwgW1wic29tZS12c1wiLCBcInNvbWUtZnNcIik7XG4gKlxuICogICAgIGNvbnN0IGF0dHJpYlNldHRlcnMgPSBjcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzKHByb2dyYW0pO1xuICpcbiAqICAgICBjb25zdCBwb3NpdGlvbkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICogICAgIGNvbnN0IHRleGNvb3JkQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gKlxuICogICAgIGNvbnN0IGF0dHJpYnMgPSB7XG4gKiAgICAgICBhX3Bvc2l0aW9uOiB7YnVmZmVyOiBwb3NpdGlvbkJ1ZmZlciwgbnVtQ29tcG9uZW50czogM30sXG4gKiAgICAgICBhX3RleGNvb3JkOiB7YnVmZmVyOiB0ZXhjb29yZEJ1ZmZlciwgbnVtQ29tcG9uZW50czogMn0sXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAqXG4gKiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBiaW5kIHRoZSBidWZmZXJzIEFORCBzZXQgdGhlXG4gKiBhdHRyaWJ1dGVzLlxuICpcbiAqICAgICBzZXRBdHRyaWJ1dGVzKGF0dHJpYlNldHRlcnMsIGF0dHJpYnMpO1xuICpcbiAqIFByb3BlcnRpZXMgb2YgYXR0cmlicy4gRm9yIGVhY2ggYXR0cmliIHlvdSBjYW4gYWRkXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICogICB0eXBlOiB0aGUgdHlwZSBvZiBkYXRhIGluIHRoZSBidWZmZXIuIERlZmF1bHQgPSBnbC5GTE9BVFxuICogKiAgIG5vcm1hbGl6ZTogd2hldGhlciBvciBub3QgdG8gbm9ybWFsaXplIHRoZSBkYXRhLiBEZWZhdWx0ID0gZmFsc2VcbiAqICogICBzdHJpZGU6IHRoZSBzdHJpZGUuIERlZmF1bHQgPSAwXG4gKiAqICAgb2Zmc2V0OiBvZmZzZXQgaW50byB0aGUgYnVmZmVyLiBEZWZhdWx0ID0gMFxuICogKiAgIGRpdmlzb3I6IHRoZSBkaXZpc29yIGZvciBpbnN0YW5jZXMuIERlZmF1bHQgPSB1bmRlZmluZWRcbiAqXG4gKiBGb3IgZXhhbXBsZSBpZiB5b3UgaGFkIDMgdmFsdWUgZmxvYXQgcG9zaXRpb25zLCAyIHZhbHVlXG4gKiBmbG9hdCB0ZXhjb29yZCBhbmQgNCB2YWx1ZSB1aW50OCBjb2xvcnMgeW91J2Qgc2V0dXAgeW91clxuICogYXR0cmlicyBsaWtlIHRoaXNcbiAqXG4gKiAgICAgY29uc3QgYXR0cmlicyA9IHtcbiAqICAgICAgIGFfcG9zaXRpb246IHtidWZmZXI6IHBvc2l0aW9uQnVmZmVyLCBudW1Db21wb25lbnRzOiAzfSxcbiAqICAgICAgIGFfdGV4Y29vcmQ6IHtidWZmZXI6IHRleGNvb3JkQnVmZmVyLCBudW1Db21wb25lbnRzOiAyfSxcbiAqICAgICAgIGFfY29sb3I6IHtcbiAqICAgICAgICAgYnVmZmVyOiBjb2xvckJ1ZmZlcixcbiAqICAgICAgICAgbnVtQ29tcG9uZW50czogNCxcbiAqICAgICAgICAgdHlwZTogZ2wuVU5TSUdORURfQllURSxcbiAqICAgICAgICAgbm9ybWFsaXplOiB0cnVlLFxuICogICAgICAgfSxcbiAqICAgICB9O1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn0gc2V0dGVycyBBdHRyaWJ1dGUgc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUF0dHJpYnV0ZVNldHRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+fSBidWZmZXJzIEF0dHJpYkluZm9zIG1hcHBlZCBieSBhdHRyaWJ1dGUgbmFtZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayBtb2R1bGU6dHdnbC5zZXRCdWZmZXJzQW5kQXR0cmlidXRlc31cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoc2V0dGVycywgYnVmZmVycykge1xuICBmb3IgKHZhciBuYW1lIGluIGJ1ZmZlcnMpIHtcbiAgICB2YXIgc2V0dGVyID0gc2V0dGVyc1tuYW1lXTtcblxuICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgIHNldHRlcihidWZmZXJzW25hbWVdKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogU2V0cyBhdHRyaWJ1dGVzIGFuZCBidWZmZXJzIGluY2x1ZGluZyB0aGUgYEVMRU1FTlRfQVJSQVlfQlVGRkVSYCBpZiBhcHByb3ByaWF0ZVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb2dyYW1JbmZvID0gY3JlYXRlUHJvZ3JhbUluZm8oXG4gKiAgICAgICAgIGdsLCBbXCJzb21lLXZzXCIsIFwic29tZS1mc1wiKTtcbiAqXG4gKiAgICAgY29uc3QgYXJyYXlzID0ge1xuICogICAgICAgcG9zaXRpb246IHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDAsIDAsIDEwLCAwLCAwLCAwLCAxMCwgMCwgMTAsIDEwLCAwXSwgfSxcbiAqICAgICAgIHRleGNvb3JkOiB7IG51bUNvbXBvbmVudHM6IDIsIGRhdGE6IFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSwgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgY29uc3QgYnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCBhcnJheXMpO1xuICpcbiAqICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW1JbmZvLnByb2dyYW0pO1xuICpcbiAqIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IGJpbmQgdGhlIGJ1ZmZlcnMgQU5EIHNldCB0aGVcbiAqIGF0dHJpYnV0ZXMuXG4gKlxuICogICAgIHNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbyk7XG4gKlxuICogRm9yIHRoZSBleGFtcGxlIGFib3ZlIGl0IGlzIGVxdWl2aWxlbnQgdG9cbiAqXG4gKiAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uQnVmZmVyKTtcbiAqICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX3Bvc2l0aW9uTG9jYXRpb24pO1xuICogICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9wb3NpdGlvbkxvY2F0aW9uLCAzLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICogICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0ZXhjb29yZEJ1ZmZlcik7XG4gKiAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV90ZXhjb29yZExvY2F0aW9uKTtcbiAqICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfdGV4Y29vcmRMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+KX0gc2V0dGVycyBBIGBQcm9ncmFtSW5mb2AgYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlUHJvZ3JtYUluZm99IG9yIEF0dHJpYnV0ZSBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUF0dHJpYnV0ZVNldHRlcnN9XG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5CdWZmZXJJbmZvfG1vZHVsZTp0d2dsLnZlcnRleEFycmF5SW5mbyl9IGJ1ZmZlcnMgYSBgQnVmZmVySW5mb2AgYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXN9LlxuICogICBvciBhIGBWZXJ0ZXhBcnJheUluZm9gIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVZlcnRleEFycmF5SW5mb31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXMoZ2wsIHByb2dyYW1JbmZvLCBidWZmZXJzKSB7XG4gIGlmIChidWZmZXJzLnZlcnRleEFycmF5T2JqZWN0KSB7XG4gICAgZ2wuYmluZFZlcnRleEFycmF5KGJ1ZmZlcnMudmVydGV4QXJyYXlPYmplY3QpO1xuICB9IGVsc2Uge1xuICAgIHNldEF0dHJpYnV0ZXMocHJvZ3JhbUluZm8uYXR0cmliU2V0dGVycyB8fCBwcm9ncmFtSW5mbywgYnVmZmVycy5hdHRyaWJzKTtcblxuICAgIGlmIChidWZmZXJzLmluZGljZXMpIHtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMuaW5kaWNlcyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb2dyYW1JbmZvXG4gKiBAcHJvcGVydHkge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSBBIHNoYWRlciBwcm9ncmFtXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIGZ1bmN0aW9uPn0gdW5pZm9ybVNldHRlcnMgb2JqZWN0IG9mIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVVbmlmb3JtU2V0dGVycyxcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgZnVuY3Rpb24+fSBhdHRyaWJTZXR0ZXJzIG9iamVjdCBvZiBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlQXR0cmliU2V0dGVycyxcbiAqIEBwcm9wZXR0eSB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrU3BlY30gW3VuaWZvcm1CbG9ja1NwYWNlXSBhIHVuaWZvcm0gYmxvY2sgc3BlYyBmb3IgbWFraW5nIFVuaWZvcm1CbG9ja0luZm9zIHdpdGggY3JlYXRlVW5pZm9ybUJsb2NrSW5mbyBldGMuLlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5UcmFuc2Zvcm1GZWVkYmFja0luZm8+fSBbdHJhbnNmb3JtRmVlZGJhY2tJbmZvXSBpbmZvIGZvciB0cmFuc2Zvcm0gZmVlZGJhY2tzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBQcm9ncmFtSW5mbyBmcm9tIGFuIGV4aXN0aW5nIHByb2dyYW0uXG4gKlxuICogQSBQcm9ncmFtSW5mbyBjb250YWluc1xuICpcbiAqICAgICBwcm9ncmFtSW5mbyA9IHtcbiAqICAgICAgICBwcm9ncmFtOiBXZWJHTFByb2dyYW0sXG4gKiAgICAgICAgdW5pZm9ybVNldHRlcnM6IG9iamVjdCBvZiBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlVW5pZm9ybVNldHRlcnMsXG4gKiAgICAgICAgYXR0cmliU2V0dGVyczogb2JqZWN0IG9mIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVBdHRyaWJTZXR0ZXJzLFxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogICAgICAgIHRvIHVzZS5cbiAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtIGFuIGV4aXN0aW5nIFdlYkdMUHJvZ3JhbS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBUaGUgY3JlYXRlZCBQcm9ncmFtSW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICB2YXIgdW5pZm9ybVNldHRlcnMgPSBjcmVhdGVVbmlmb3JtU2V0dGVycyhnbCwgcHJvZ3JhbSk7XG4gIHZhciBhdHRyaWJTZXR0ZXJzID0gY3JlYXRlQXR0cmlidXRlU2V0dGVycyhnbCwgcHJvZ3JhbSk7XG4gIHZhciBwcm9ncmFtSW5mbyA9IHtcbiAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgIHVuaWZvcm1TZXR0ZXJzOiB1bmlmb3JtU2V0dGVycyxcbiAgICBhdHRyaWJTZXR0ZXJzOiBhdHRyaWJTZXR0ZXJzXG4gIH07XG5cbiAgaWYgKHV0aWxzLmlzV2ViR0wyKGdsKSkge1xuICAgIHByb2dyYW1JbmZvLnVuaWZvcm1CbG9ja1NwZWMgPSBjcmVhdGVVbmlmb3JtQmxvY2tTcGVjRnJvbVByb2dyYW0oZ2wsIHByb2dyYW0pO1xuICAgIHByb2dyYW1JbmZvLnRyYW5zZm9ybUZlZWRiYWNrSW5mbyA9IGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrSW5mbyhnbCwgcHJvZ3JhbSk7XG4gIH1cblxuICByZXR1cm4gcHJvZ3JhbUluZm87XG59XG4vKipcbiAqIENyZWF0ZXMgYSBQcm9ncmFtSW5mbyBmcm9tIDIgc291cmNlcy5cbiAqXG4gKiBBIFByb2dyYW1JbmZvIGNvbnRhaW5zXG4gKlxuICogICAgIHByb2dyYW1JbmZvID0ge1xuICogICAgICAgIHByb2dyYW06IFdlYkdMUHJvZ3JhbSxcbiAqICAgICAgICB1bmlmb3JtU2V0dGVyczogb2JqZWN0IG9mIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVVbmlmb3JtU2V0dGVycyxcbiAqICAgICAgICBhdHRyaWJTZXR0ZXJzOiBvYmplY3Qgb2Ygc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUF0dHJpYlNldHRlcnMsXG4gKiAgICAgfVxuICpcbiAqIE5PVEU6IFRoZXJlIGFyZSA0IHNpZ25hdHVyZXMgZm9yIHRoaXMgZnVuY3Rpb25cbiAqXG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZzLCBmc10sIG9wdGlvbnMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUluZm8oZ2wsIFt2cywgZnNdLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyRnVuYyk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqICAgICAgICB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzaGFkZXJTb3VyY2VzIEFycmF5IG9mIHNvdXJjZXMgZm9yIHRoZVxuICogICAgICAgIHNoYWRlcnMgb3IgaWRzLiBUaGUgZmlyc3QgaXMgYXNzdW1lZCB0byBiZSB0aGUgdmVydGV4IHNoYWRlcixcbiAqICAgICAgICB0aGUgc2Vjb25kIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1PcHRpb25zfHN0cmluZ1tdfSBbb3B0X2F0dHJpYnNdIE9wdGlvbnMgZm9yIHRoZSBwcm9ncmFtIG9yIGFuIGFycmF5IG9mIGF0dHJpYnMgbmFtZXMuIExvY2F0aW9ucyB3aWxsIGJlIGFzc2lnbmVkIGJ5IGluZGV4IGlmIG5vdCBwYXNzZWQgaW5cbiAqIEBwYXJhbSB7bnVtYmVyW119IFtvcHRfbG9jYXRpb25zXSBUaGUgbG9jYXRpb25zIGZvciB0aGUgYXR0cmlidXRlcy4gQSBwYXJhbGxlbCBhcnJheSB0byBvcHRfYXR0cmlicyBsZXR0aW5nIHlvdSBhc3NpZ24gbG9jYXRpb25zLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrfSBvcHRfZXJyb3JDYWxsYmFjayBjYWxsYmFjayBmb3IgZXJyb3JzLiBCeSBkZWZhdWx0IGl0IGp1c3QgcHJpbnRzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlXG4gKiAgICAgICAgb24gZXJyb3IuIElmIHlvdSB3YW50IHNvbWV0aGluZyBlbHNlIHBhc3MgYW4gY2FsbGJhY2suIEl0J3MgcGFzc2VkIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5Qcm9ncmFtSW5mbz99IFRoZSBjcmVhdGVkIFByb2dyYW1JbmZvIG9yIG51bGwgaWYgaXQgZmFpbGVkIHRvIGxpbmsgb3IgY29tcGlsZVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtSW5mbyhnbCwgc2hhZGVyU291cmNlcywgb3B0X2F0dHJpYnMsIG9wdF9sb2NhdGlvbnMsIG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gIHZhciBwcm9nT3B0aW9ucyA9IGdldFByb2dyYW1PcHRpb25zKG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjayk7XG4gIHZhciBnb29kID0gdHJ1ZTtcbiAgc2hhZGVyU291cmNlcyA9IHNoYWRlclNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAvLyBMZXRzIGFzc3VtZSBpZiB0aGVyZSBpcyBubyBcXG4gaXQncyBhbiBpZFxuICAgIGlmIChzb3VyY2UuaW5kZXhPZihcIlxcblwiKSA8IDApIHtcbiAgICAgIHZhciBzY3JpcHQgPSBnZXRFbGVtZW50QnlJZChzb3VyY2UpO1xuXG4gICAgICBpZiAoIXNjcmlwdCkge1xuICAgICAgICBwcm9nT3B0aW9ucy5lcnJvckNhbGxiYWNrKFwibm8gZWxlbWVudCB3aXRoIGlkOiBcIiArIHNvdXJjZSk7XG4gICAgICAgIGdvb2QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZSA9IHNjcmlwdC50ZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2U7XG4gIH0pO1xuXG4gIGlmICghZ29vZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtRnJvbVNvdXJjZXMoZ2wsIHNoYWRlclNvdXJjZXMsIHByb2dPcHRpb25zKTtcblxuICBpZiAoIXByb2dyYW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVQcm9ncmFtSW5mb0Zyb21Qcm9ncmFtKGdsLCBwcm9ncmFtKTtcbn1cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmF4aXNSb3RhdGUgPSBheGlzUm90YXRlO1xuZXhwb3J0cy5heGlzUm90YXRpb24gPSBheGlzUm90YXRpb247XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5mcnVzdHVtID0gZnJ1c3R1bTtcbmV4cG9ydHMuZ2V0QXhpcyA9IGdldEF4aXM7XG5leHBvcnRzLmdldFRyYW5zbGF0aW9uID0gZ2V0VHJhbnNsYXRpb247XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLmludmVyc2UgPSBpbnZlcnNlO1xuZXhwb3J0cy5sb29rQXQgPSBsb29rQXQ7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbmV4cG9ydHMub3J0aG8gPSBvcnRobztcbmV4cG9ydHMucGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZTtcbmV4cG9ydHMucm90YXRlWCA9IHJvdGF0ZVg7XG5leHBvcnRzLnJvdGF0ZVkgPSByb3RhdGVZO1xuZXhwb3J0cy5yb3RhdGVaID0gcm90YXRlWjtcbmV4cG9ydHMucm90YXRpb25YID0gcm90YXRpb25YO1xuZXhwb3J0cy5yb3RhdGlvblkgPSByb3RhdGlvblk7XG5leHBvcnRzLnJvdGF0aW9uWiA9IHJvdGF0aW9uWjtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuc2NhbGluZyA9IHNjYWxpbmc7XG5leHBvcnRzLnNldEF4aXMgPSBzZXRBeGlzO1xuZXhwb3J0cy5zZXREZWZhdWx0VHlwZSA9IHNldERlZmF1bHRUeXBlO1xuZXhwb3J0cy5zZXRUcmFuc2xhdGlvbiA9IHNldFRyYW5zbGF0aW9uO1xuZXhwb3J0cy50cmFuc2Zvcm1EaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb247XG5leHBvcnRzLnRyYW5zZm9ybU5vcm1hbCA9IHRyYW5zZm9ybU5vcm1hbDtcbmV4cG9ydHMudHJhbnNmb3JtUG9pbnQgPSB0cmFuc2Zvcm1Qb2ludDtcbmV4cG9ydHMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuZXhwb3J0cy50cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uO1xuZXhwb3J0cy50cmFuc3Bvc2UgPSB0cmFuc3Bvc2U7XG5cbnZhciB2MyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNSwgR3JlZ2cgVGF2YXJlcy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbiAqIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiAqIGRpc3RyaWJ1dGlvbi5cbiAqICAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR3JlZ2cgVGF2YXJlcy4gbm9yIHRoZSBuYW1lcyBvZiBoaXNcbiAqIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4vKipcbiAqIDR4NCBNYXRyaXggbWF0aCBtYXRoIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbG1vc3QgYWxsIGZ1bmN0aW9ucyB0YWtlIGFuIG9wdGlvbmFsIGBkc3RgIGFyZ3VtZW50LiBJZiBpdCBpcyBub3QgcGFzc2VkIGluIHRoZVxuICogZnVuY3Rpb25zIHdpbGwgY3JlYXRlIGEgbmV3IG1hdHJpeC4gSW4gb3RoZXIgd29yZHMgeW91IGNhbiBkbyB0aGlzXG4gKlxuICogICAgIGNvbnN0IG1hdCA9IG00LnRyYW5zbGF0aW9uKFsxLCAyLCAzXSk7ICAvLyBDcmVhdGVzIGEgbmV3IHRyYW5zbGF0aW9uIG1hdHJpeFxuICpcbiAqIG9yXG4gKlxuICogICAgIGNvbnN0IG1hdCA9IG00LmNyZWF0ZSgpO1xuICogICAgIG00LnRyYW5zbGF0aW9uKFsxLCAyLCAzXSwgbWF0KTsgIC8vIFB1dHMgdHJhbnNsYXRpb24gbWF0cml4IGluIG1hdC5cbiAqXG4gKiBUaGUgZmlyc3Qgc3R5bGUgaXMgb2Z0ZW4gZWFzaWVyIGJ1dCBkZXBlbmRpbmcgb24gd2hlcmUgaXQncyB1c2VkIGl0IGdlbmVyYXRlcyBnYXJiYWdlIHdoZXJlXG4gKiBhcyB0aGVyZSBpcyBhbG1vc3QgbmV2ZXIgYWxsb2NhdGlvbiB3aXRoIHRoZSBzZWNvbmQgc3R5bGUuXG4gKlxuICogSXQgaXMgYWx3YXlzIHNhdmUgdG8gcGFzcyBhbnkgbWF0cml4IGFzIHRoZSBkZXN0aW5hdGlvbi4gU28gZm9yIGV4YW1wbGVcbiAqXG4gKiAgICAgY29uc3QgbWF0ID0gbTQuaWRlbnRpdHkoKTtcbiAqICAgICBjb25zdCB0cmFucyA9IG00LnRyYW5zbGF0aW9uKFsxLCAyLCAzXSk7XG4gKiAgICAgbTQubXVsdGlwbHkobWF0LCB0cmFucywgbWF0KTsgIC8vIE11bHRpcGxpZXMgbWF0ICogdHJhbnMgYW5kIHB1dHMgcmVzdWx0IGluIG1hdC5cbiAqXG4gKiBAbW9kdWxlIHR3Z2wvbTRcbiAqL1xudmFyIE1hdFR5cGUgPSBGbG9hdDMyQXJyYXk7XG52YXIgdGVtcFYzYSA9IHYzLmNyZWF0ZSgpO1xudmFyIHRlbXBWM2IgPSB2My5jcmVhdGUoKTtcbnZhciB0ZW1wVjNjID0gdjMuY3JlYXRlKCk7XG4vKipcbiAqIEEgSmF2YVNjcmlwdCBhcnJheSB3aXRoIDE2IHZhbHVlcyBvciBhIEZsb2F0MzJBcnJheSB3aXRoIDE2IHZhbHVlcy5cbiAqIFdoZW4gY3JlYXRlZCBieSB0aGUgbGlicmFyeSB3aWxsIGNyZWF0ZSB0aGUgZGVmYXVsdCB0eXBlIHdoaWNoIGlzIGBGbG9hdDMyQXJyYXlgXG4gKiBidXQgY2FuIGJlIHNldCBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6dHdnbC9tNC5zZXREZWZhdWx0VHlwZX0uXG4gKiBAdHlwZWRlZiB7KG51bWJlcltdfEZsb2F0MzJBcnJheSl9IE1hdDRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cbi8qKlxuICogU2V0cyB0aGUgdHlwZSB0aGlzIGxpYnJhcnkgY3JlYXRlcyBmb3IgYSBNYXQ0XG4gKiBAcGFyYW0ge2NvbnN0cnVjdG9yfSBjdG9yIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHR5cGUuIEVpdGhlciBgRmxvYXQzMkFycmF5YCBvciBgQXJyYXlgXG4gKiBAcmV0dXJuIHtjb25zdHJ1Y3Rvcn0gcHJldmlvdXMgY29uc3RydWN0b3IgZm9yIE1hdDRcbiAqL1xuXG5mdW5jdGlvbiBzZXREZWZhdWx0VHlwZShjdG9yKSB7XG4gIHZhciBvbGRUeXBlID0gTWF0VHlwZTtcbiAgTWF0VHlwZSA9IGN0b3I7XG4gIHJldHVybiBvbGRUeXBlO1xufVxuLyoqXG4gKiBOZWdhdGVzIGEgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm9uZSBuZXcgb25lIGlzIGNyZWF0ZWQuLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gLW0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIG5lZ2F0ZShtLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgZHN0WzBdID0gLW1bMF07XG4gIGRzdFsxXSA9IC1tWzFdO1xuICBkc3RbMl0gPSAtbVsyXTtcbiAgZHN0WzNdID0gLW1bM107XG4gIGRzdFs0XSA9IC1tWzRdO1xuICBkc3RbNV0gPSAtbVs1XTtcbiAgZHN0WzZdID0gLW1bNl07XG4gIGRzdFs3XSA9IC1tWzddO1xuICBkc3RbOF0gPSAtbVs4XTtcbiAgZHN0WzldID0gLW1bOV07XG4gIGRzdFsxMF0gPSAtbVsxMF07XG4gIGRzdFsxMV0gPSAtbVsxMV07XG4gIGRzdFsxMl0gPSAtbVsxMl07XG4gIGRzdFsxM10gPSAtbVsxM107XG4gIGRzdFsxNF0gPSAtbVsxNF07XG4gIGRzdFsxNV0gPSAtbVsxNV07XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENvcGllcyBhIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBUaGUgbWF0cml4LlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gQSBjb3B5IG9mIG0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkobSwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIGRzdFswXSA9IG1bMF07XG4gIGRzdFsxXSA9IG1bMV07XG4gIGRzdFsyXSA9IG1bMl07XG4gIGRzdFszXSA9IG1bM107XG4gIGRzdFs0XSA9IG1bNF07XG4gIGRzdFs1XSA9IG1bNV07XG4gIGRzdFs2XSA9IG1bNl07XG4gIGRzdFs3XSA9IG1bN107XG4gIGRzdFs4XSA9IG1bOF07XG4gIGRzdFs5XSA9IG1bOV07XG4gIGRzdFsxMF0gPSBtWzEwXTtcbiAgZHN0WzExXSA9IG1bMTFdO1xuICBkc3RbMTJdID0gbVsxMl07XG4gIGRzdFsxM10gPSBtWzEzXTtcbiAgZHN0WzE0XSA9IG1bMTRdO1xuICBkc3RbMTVdID0gbVsxNV07XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gbi1ieS1uIGlkZW50aXR5IG1hdHJpeC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm9uZSBuZXcgb25lIGlzIGNyZWF0ZWQuLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gQW4gbi1ieS1uIGlkZW50aXR5IG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkoZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIGRzdFswXSA9IDE7XG4gIGRzdFsxXSA9IDA7XG4gIGRzdFsyXSA9IDA7XG4gIGRzdFszXSA9IDA7XG4gIGRzdFs0XSA9IDA7XG4gIGRzdFs1XSA9IDE7XG4gIGRzdFs2XSA9IDA7XG4gIGRzdFs3XSA9IDA7XG4gIGRzdFs4XSA9IDA7XG4gIGRzdFs5XSA9IDA7XG4gIGRzdFsxMF0gPSAxO1xuICBkc3RbMTFdID0gMDtcbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gMDtcbiAgZHN0WzE1XSA9IDE7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFRha2VzIHRoZSB0cmFuc3Bvc2Ugb2YgYSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub25lIG5ldyBvbmUgaXMgY3JlYXRlZC4uXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgdHJhbnNwb3NlIG9mIG0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zcG9zZShtLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBpZiAoZHN0ID09PSBtKSB7XG4gICAgdmFyIHQ7XG4gICAgdCA9IG1bMV07XG4gICAgbVsxXSA9IG1bNF07XG4gICAgbVs0XSA9IHQ7XG4gICAgdCA9IG1bMl07XG4gICAgbVsyXSA9IG1bOF07XG4gICAgbVs4XSA9IHQ7XG4gICAgdCA9IG1bM107XG4gICAgbVszXSA9IG1bMTJdO1xuICAgIG1bMTJdID0gdDtcbiAgICB0ID0gbVs2XTtcbiAgICBtWzZdID0gbVs5XTtcbiAgICBtWzldID0gdDtcbiAgICB0ID0gbVs3XTtcbiAgICBtWzddID0gbVsxM107XG4gICAgbVsxM10gPSB0O1xuICAgIHQgPSBtWzExXTtcbiAgICBtWzExXSA9IG1bMTRdO1xuICAgIG1bMTRdID0gdDtcbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgdmFyIG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgdmFyIG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgdmFyIG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgdmFyIG0wMyA9IG1bMCAqIDQgKyAzXTtcbiAgdmFyIG0xMCA9IG1bMSAqIDQgKyAwXTtcbiAgdmFyIG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgdmFyIG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgdmFyIG0xMyA9IG1bMSAqIDQgKyAzXTtcbiAgdmFyIG0yMCA9IG1bMiAqIDQgKyAwXTtcbiAgdmFyIG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgdmFyIG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgdmFyIG0yMyA9IG1bMiAqIDQgKyAzXTtcbiAgdmFyIG0zMCA9IG1bMyAqIDQgKyAwXTtcbiAgdmFyIG0zMSA9IG1bMyAqIDQgKyAxXTtcbiAgdmFyIG0zMiA9IG1bMyAqIDQgKyAyXTtcbiAgdmFyIG0zMyA9IG1bMyAqIDQgKyAzXTtcbiAgZHN0WzBdID0gbTAwO1xuICBkc3RbMV0gPSBtMTA7XG4gIGRzdFsyXSA9IG0yMDtcbiAgZHN0WzNdID0gbTMwO1xuICBkc3RbNF0gPSBtMDE7XG4gIGRzdFs1XSA9IG0xMTtcbiAgZHN0WzZdID0gbTIxO1xuICBkc3RbN10gPSBtMzE7XG4gIGRzdFs4XSA9IG0wMjtcbiAgZHN0WzldID0gbTEyO1xuICBkc3RbMTBdID0gbTIyO1xuICBkc3RbMTFdID0gbTMyO1xuICBkc3RbMTJdID0gbTAzO1xuICBkc3RbMTNdID0gbTEzO1xuICBkc3RbMTRdID0gbTIzO1xuICBkc3RbMTVdID0gbTMzO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgaW52ZXJzZSBvZiBhIDQtYnktNCBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub25lIG5ldyBvbmUgaXMgY3JlYXRlZC4uXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgaW52ZXJzZSBvZiBtLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnNlKG0sIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICB2YXIgbTAwID0gbVswICogNCArIDBdO1xuICB2YXIgbTAxID0gbVswICogNCArIDFdO1xuICB2YXIgbTAyID0gbVswICogNCArIDJdO1xuICB2YXIgbTAzID0gbVswICogNCArIDNdO1xuICB2YXIgbTEwID0gbVsxICogNCArIDBdO1xuICB2YXIgbTExID0gbVsxICogNCArIDFdO1xuICB2YXIgbTEyID0gbVsxICogNCArIDJdO1xuICB2YXIgbTEzID0gbVsxICogNCArIDNdO1xuICB2YXIgbTIwID0gbVsyICogNCArIDBdO1xuICB2YXIgbTIxID0gbVsyICogNCArIDFdO1xuICB2YXIgbTIyID0gbVsyICogNCArIDJdO1xuICB2YXIgbTIzID0gbVsyICogNCArIDNdO1xuICB2YXIgbTMwID0gbVszICogNCArIDBdO1xuICB2YXIgbTMxID0gbVszICogNCArIDFdO1xuICB2YXIgbTMyID0gbVszICogNCArIDJdO1xuICB2YXIgbTMzID0gbVszICogNCArIDNdO1xuICB2YXIgdG1wXzAgPSBtMjIgKiBtMzM7XG4gIHZhciB0bXBfMSA9IG0zMiAqIG0yMztcbiAgdmFyIHRtcF8yID0gbTEyICogbTMzO1xuICB2YXIgdG1wXzMgPSBtMzIgKiBtMTM7XG4gIHZhciB0bXBfNCA9IG0xMiAqIG0yMztcbiAgdmFyIHRtcF81ID0gbTIyICogbTEzO1xuICB2YXIgdG1wXzYgPSBtMDIgKiBtMzM7XG4gIHZhciB0bXBfNyA9IG0zMiAqIG0wMztcbiAgdmFyIHRtcF84ID0gbTAyICogbTIzO1xuICB2YXIgdG1wXzkgPSBtMjIgKiBtMDM7XG4gIHZhciB0bXBfMTAgPSBtMDIgKiBtMTM7XG4gIHZhciB0bXBfMTEgPSBtMTIgKiBtMDM7XG4gIHZhciB0bXBfMTIgPSBtMjAgKiBtMzE7XG4gIHZhciB0bXBfMTMgPSBtMzAgKiBtMjE7XG4gIHZhciB0bXBfMTQgPSBtMTAgKiBtMzE7XG4gIHZhciB0bXBfMTUgPSBtMzAgKiBtMTE7XG4gIHZhciB0bXBfMTYgPSBtMTAgKiBtMjE7XG4gIHZhciB0bXBfMTcgPSBtMjAgKiBtMTE7XG4gIHZhciB0bXBfMTggPSBtMDAgKiBtMzE7XG4gIHZhciB0bXBfMTkgPSBtMzAgKiBtMDE7XG4gIHZhciB0bXBfMjAgPSBtMDAgKiBtMjE7XG4gIHZhciB0bXBfMjEgPSBtMjAgKiBtMDE7XG4gIHZhciB0bXBfMjIgPSBtMDAgKiBtMTE7XG4gIHZhciB0bXBfMjMgPSBtMTAgKiBtMDE7XG4gIHZhciB0MCA9IHRtcF8wICogbTExICsgdG1wXzMgKiBtMjEgKyB0bXBfNCAqIG0zMSAtICh0bXBfMSAqIG0xMSArIHRtcF8yICogbTIxICsgdG1wXzUgKiBtMzEpO1xuICB2YXIgdDEgPSB0bXBfMSAqIG0wMSArIHRtcF82ICogbTIxICsgdG1wXzkgKiBtMzEgLSAodG1wXzAgKiBtMDEgKyB0bXBfNyAqIG0yMSArIHRtcF84ICogbTMxKTtcbiAgdmFyIHQyID0gdG1wXzIgKiBtMDEgKyB0bXBfNyAqIG0xMSArIHRtcF8xMCAqIG0zMSAtICh0bXBfMyAqIG0wMSArIHRtcF82ICogbTExICsgdG1wXzExICogbTMxKTtcbiAgdmFyIHQzID0gdG1wXzUgKiBtMDEgKyB0bXBfOCAqIG0xMSArIHRtcF8xMSAqIG0yMSAtICh0bXBfNCAqIG0wMSArIHRtcF85ICogbTExICsgdG1wXzEwICogbTIxKTtcbiAgdmFyIGQgPSAxLjAgLyAobTAwICogdDAgKyBtMTAgKiB0MSArIG0yMCAqIHQyICsgbTMwICogdDMpO1xuICBkc3RbMF0gPSBkICogdDA7XG4gIGRzdFsxXSA9IGQgKiB0MTtcbiAgZHN0WzJdID0gZCAqIHQyO1xuICBkc3RbM10gPSBkICogdDM7XG4gIGRzdFs0XSA9IGQgKiAodG1wXzEgKiBtMTAgKyB0bXBfMiAqIG0yMCArIHRtcF81ICogbTMwIC0gKHRtcF8wICogbTEwICsgdG1wXzMgKiBtMjAgKyB0bXBfNCAqIG0zMCkpO1xuICBkc3RbNV0gPSBkICogKHRtcF8wICogbTAwICsgdG1wXzcgKiBtMjAgKyB0bXBfOCAqIG0zMCAtICh0bXBfMSAqIG0wMCArIHRtcF82ICogbTIwICsgdG1wXzkgKiBtMzApKTtcbiAgZHN0WzZdID0gZCAqICh0bXBfMyAqIG0wMCArIHRtcF82ICogbTEwICsgdG1wXzExICogbTMwIC0gKHRtcF8yICogbTAwICsgdG1wXzcgKiBtMTAgKyB0bXBfMTAgKiBtMzApKTtcbiAgZHN0WzddID0gZCAqICh0bXBfNCAqIG0wMCArIHRtcF85ICogbTEwICsgdG1wXzEwICogbTIwIC0gKHRtcF81ICogbTAwICsgdG1wXzggKiBtMTAgKyB0bXBfMTEgKiBtMjApKTtcbiAgZHN0WzhdID0gZCAqICh0bXBfMTIgKiBtMTMgKyB0bXBfMTUgKiBtMjMgKyB0bXBfMTYgKiBtMzMgLSAodG1wXzEzICogbTEzICsgdG1wXzE0ICogbTIzICsgdG1wXzE3ICogbTMzKSk7XG4gIGRzdFs5XSA9IGQgKiAodG1wXzEzICogbTAzICsgdG1wXzE4ICogbTIzICsgdG1wXzIxICogbTMzIC0gKHRtcF8xMiAqIG0wMyArIHRtcF8xOSAqIG0yMyArIHRtcF8yMCAqIG0zMykpO1xuICBkc3RbMTBdID0gZCAqICh0bXBfMTQgKiBtMDMgKyB0bXBfMTkgKiBtMTMgKyB0bXBfMjIgKiBtMzMgLSAodG1wXzE1ICogbTAzICsgdG1wXzE4ICogbTEzICsgdG1wXzIzICogbTMzKSk7XG4gIGRzdFsxMV0gPSBkICogKHRtcF8xNyAqIG0wMyArIHRtcF8yMCAqIG0xMyArIHRtcF8yMyAqIG0yMyAtICh0bXBfMTYgKiBtMDMgKyB0bXBfMjEgKiBtMTMgKyB0bXBfMjIgKiBtMjMpKTtcbiAgZHN0WzEyXSA9IGQgKiAodG1wXzE0ICogbTIyICsgdG1wXzE3ICogbTMyICsgdG1wXzEzICogbTEyIC0gKHRtcF8xNiAqIG0zMiArIHRtcF8xMiAqIG0xMiArIHRtcF8xNSAqIG0yMikpO1xuICBkc3RbMTNdID0gZCAqICh0bXBfMjAgKiBtMzIgKyB0bXBfMTIgKiBtMDIgKyB0bXBfMTkgKiBtMjIgLSAodG1wXzE4ICogbTIyICsgdG1wXzIxICogbTMyICsgdG1wXzEzICogbTAyKSk7XG4gIGRzdFsxNF0gPSBkICogKHRtcF8xOCAqIG0xMiArIHRtcF8yMyAqIG0zMiArIHRtcF8xNSAqIG0wMiAtICh0bXBfMjIgKiBtMzIgKyB0bXBfMTQgKiBtMDIgKyB0bXBfMTkgKiBtMTIpKTtcbiAgZHN0WzE1XSA9IGQgKiAodG1wXzIyICogbTIyICsgdG1wXzE2ICogbTAyICsgdG1wXzIxICogbTEyIC0gKHRtcF8yMCAqIG0xMiArIHRtcF8yMyAqIG0yMiArIHRtcF8xNyAqIG0wMikpO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byA0LWJ5LTQgbWF0cmljZXMgd2l0aCBhIG9uIHRoZSBsZWZ0IGFuZCBiIG9uIHRoZSByaWdodFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBhIFRoZSBtYXRyaXggb24gdGhlIGxlZnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IGIgVGhlIG1hdHJpeCBvbiB0aGUgcmlnaHQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm9uZSBuZXcgb25lIGlzIGNyZWF0ZWQuLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIG1hdHJpeCBwcm9kdWN0IG9mIGEgYW5kIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICB2YXIgYTAwID0gYVswXTtcbiAgdmFyIGEwMSA9IGFbMV07XG4gIHZhciBhMDIgPSBhWzJdO1xuICB2YXIgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNCArIDBdO1xuICB2YXIgYTExID0gYVs0ICsgMV07XG4gIHZhciBhMTIgPSBhWzQgKyAyXTtcbiAgdmFyIGExMyA9IGFbNCArIDNdO1xuICB2YXIgYTIwID0gYVs4ICsgMF07XG4gIHZhciBhMjEgPSBhWzggKyAxXTtcbiAgdmFyIGEyMiA9IGFbOCArIDJdO1xuICB2YXIgYTIzID0gYVs4ICsgM107XG4gIHZhciBhMzAgPSBhWzEyICsgMF07XG4gIHZhciBhMzEgPSBhWzEyICsgMV07XG4gIHZhciBhMzIgPSBhWzEyICsgMl07XG4gIHZhciBhMzMgPSBhWzEyICsgM107XG4gIHZhciBiMDAgPSBiWzBdO1xuICB2YXIgYjAxID0gYlsxXTtcbiAgdmFyIGIwMiA9IGJbMl07XG4gIHZhciBiMDMgPSBiWzNdO1xuICB2YXIgYjEwID0gYls0ICsgMF07XG4gIHZhciBiMTEgPSBiWzQgKyAxXTtcbiAgdmFyIGIxMiA9IGJbNCArIDJdO1xuICB2YXIgYjEzID0gYls0ICsgM107XG4gIHZhciBiMjAgPSBiWzggKyAwXTtcbiAgdmFyIGIyMSA9IGJbOCArIDFdO1xuICB2YXIgYjIyID0gYls4ICsgMl07XG4gIHZhciBiMjMgPSBiWzggKyAzXTtcbiAgdmFyIGIzMCA9IGJbMTIgKyAwXTtcbiAgdmFyIGIzMSA9IGJbMTIgKyAxXTtcbiAgdmFyIGIzMiA9IGJbMTIgKyAyXTtcbiAgdmFyIGIzMyA9IGJbMTIgKyAzXTtcbiAgZHN0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyICsgYTMwICogYjAzO1xuICBkc3RbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDIgKyBhMzEgKiBiMDM7XG4gIGRzdFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMiArIGEzMiAqIGIwMztcbiAgZHN0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyICsgYTMzICogYjAzO1xuICBkc3RbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTIgKyBhMzAgKiBiMTM7XG4gIGRzdFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMiArIGEzMSAqIGIxMztcbiAgZHN0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyICsgYTMyICogYjEzO1xuICBkc3RbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTIgKyBhMzMgKiBiMTM7XG4gIGRzdFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMiArIGEzMCAqIGIyMztcbiAgZHN0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyICsgYTMxICogYjIzO1xuICBkc3RbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyICsgYTMyICogYjIzO1xuICBkc3RbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyICsgYTMzICogYjIzO1xuICBkc3RbMTJdID0gYTAwICogYjMwICsgYTEwICogYjMxICsgYTIwICogYjMyICsgYTMwICogYjMzO1xuICBkc3RbMTNdID0gYTAxICogYjMwICsgYTExICogYjMxICsgYTIxICogYjMyICsgYTMxICogYjMzO1xuICBkc3RbMTRdID0gYTAyICogYjMwICsgYTEyICogYjMxICsgYTIyICogYjMyICsgYTMyICogYjMzO1xuICBkc3RbMTVdID0gYTAzICogYjMwICsgYTEzICogYjMxICsgYTIzICogYjMyICsgYTMzICogYjMzO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBTZXRzIHRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnQgb2YgYSA0LWJ5LTQgbWF0cml4IHRvIHRoZSBnaXZlblxuICogdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBhIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub25lIG5ldyBvbmUgaXMgY3JlYXRlZC4uXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBhIG9uY2UgbW9kaWZpZWQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRyYW5zbGF0aW9uKGEsIHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgaWRlbnRpdHkoKTtcblxuICBpZiAoYSAhPT0gZHN0KSB7XG4gICAgZHN0WzBdID0gYVswXTtcbiAgICBkc3RbMV0gPSBhWzFdO1xuICAgIGRzdFsyXSA9IGFbMl07XG4gICAgZHN0WzNdID0gYVszXTtcbiAgICBkc3RbNF0gPSBhWzRdO1xuICAgIGRzdFs1XSA9IGFbNV07XG4gICAgZHN0WzZdID0gYVs2XTtcbiAgICBkc3RbN10gPSBhWzddO1xuICAgIGRzdFs4XSA9IGFbOF07XG4gICAgZHN0WzldID0gYVs5XTtcbiAgICBkc3RbMTBdID0gYVsxMF07XG4gICAgZHN0WzExXSA9IGFbMTFdO1xuICB9XG5cbiAgZHN0WzEyXSA9IHZbMF07XG4gIGRzdFsxM10gPSB2WzFdO1xuICBkc3RbMTRdID0gdlsyXTtcbiAgZHN0WzE1XSA9IDE7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBhIDQtYnktNCBtYXRyaXggYXMgYSB2ZWN0b3Igd2l0aCAzXG4gKiBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge1ZlYzN9IFtkc3RdIHZlY3Rvci4uXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIG0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG0sIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgdjMuY3JlYXRlKCk7XG4gIGRzdFswXSA9IG1bMTJdO1xuICBkc3RbMV0gPSBtWzEzXTtcbiAgZHN0WzJdID0gbVsxNF07XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFJldHVybnMgYW4gYXhpcyBvZiBhIDR4NCBtYXRyaXggYXMgYSB2ZWN0b3Igd2l0aCAzIGVudHJpZXNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHtudW1iZXJ9IGF4aXMgVGhlIGF4aXMgMCA9IHgsIDEgPSB5LCAyID0gejtcbiAqIEByZXR1cm4ge1ZlYzN9IFtkc3RdIHZlY3Rvci5cbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBheGlzIGNvbXBvbmVudCBvZiBtLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRBeGlzKG0sIGF4aXMsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgdjMuY3JlYXRlKCk7XG4gIHZhciBvZmYgPSBheGlzICogNDtcbiAgZHN0WzBdID0gbVtvZmYgKyAwXTtcbiAgZHN0WzFdID0gbVtvZmYgKyAxXTtcbiAgZHN0WzJdID0gbVtvZmYgKyAyXTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogU2V0cyBhbiBheGlzIG9mIGEgNHg0IG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDMgZW50cmllc1xuICogQHBhcmFtIHtWZWMzfSB2IHRoZSBheGlzIHZlY3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGF4aXMgVGhlIGF4aXMgIDAgPSB4LCAxID0geSwgMiA9IHo7XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIFRoZSBtYXRyaXggdG8gc2V0LiBJZiBub25lIGEgbmV3IG9uZSBpcyBjcmVhdGVkXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBkc3RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gc2V0QXhpcyhhLCB2LCBheGlzLCBkc3QpIHtcbiAgaWYgKGRzdCAhPT0gYSkge1xuICAgIGRzdCA9IGNvcHkoYSwgZHN0KTtcbiAgfVxuXG4gIHZhciBvZmYgPSBheGlzICogNDtcbiAgZHN0W29mZiArIDBdID0gdlswXTtcbiAgZHN0W29mZiArIDFdID0gdlsxXTtcbiAgZHN0W29mZiArIDJdID0gdlsyXTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSA0LWJ5LTQgcGVyc3BlY3RpdmUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGdpdmVuIHRoZSBhbmd1bGFyIGhlaWdodFxuICogb2YgdGhlIGZydXN0dW0sIHRoZSBhc3BlY3QgcmF0aW8sIGFuZCB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gIFRoZVxuICogYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW0gZXh0ZW5kaW5nIGluIHRoZSBuZWdhdGl2ZSB6IGRpcmVjdGlvbi4gIFRoZSBnaXZlblxuICogYW5nbGUgaXMgdGhlIHZlcnRpY2FsIGFuZ2xlIG9mIHRoZSBmcnVzdHVtLCBhbmQgdGhlIGhvcml6b250YWwgYW5nbGUgaXNcbiAqIGRldGVybWluZWQgdG8gcHJvZHVjZSB0aGUgZ2l2ZW4gYXNwZWN0IHJhdGlvLiAgVGhlIGFyZ3VtZW50cyBuZWFyIGFuZCBmYXIgYXJlXG4gKiB0aGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiAgTm90ZSB0aGF0IG5lYXIgYW5kIGZhclxuICogYXJlIG5vdCB6IGNvb3JkaW5hdGVzLCBidXQgcmF0aGVyIHRoZXkgYXJlIGRpc3RhbmNlcyBhbG9uZyB0aGUgbmVnYXRpdmVcbiAqIHotYXhpcy4gIFRoZSBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LlxuICogV2UgYXNzdW1lIGEgdW5pdCBib3ggZXh0ZW5kaW5nIGZyb20gLTEgdG8gMSBpbiB0aGUgeCBhbmQgeSBkaW1lbnNpb25zIGFuZFxuICogZnJvbSAwIHRvIDEgaW4gdGhlIHogZGltZW5zaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkT2ZWaWV3WUluUmFkaWFucyBUaGUgY2FtZXJhIGFuZ2xlIGZyb20gdG9wIHRvIGJvdHRvbSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IFRoZSBhc3BlY3QgcmF0aW8gd2lkdGggLyBoZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0gek5lYXIgVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gKiAgICAgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gekZhciBUaGUgZGVwdGggKG5lZ2F0aXZlIHogY29vcmRpbmF0ZSlcbiAqICAgICBvZiB0aGUgZmFyIGNsaXBwaW5nIHBsYW5lLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vbmUgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBwZXJzcGVjdGl2ZSBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHBlcnNwZWN0aXZlKGZpZWxkT2ZWaWV3WUluUmFkaWFucywgYXNwZWN0LCB6TmVhciwgekZhciwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciBmID0gTWF0aC50YW4oTWF0aC5QSSAqIDAuNSAtIDAuNSAqIGZpZWxkT2ZWaWV3WUluUmFkaWFucyk7XG4gIHZhciByYW5nZUludiA9IDEuMCAvICh6TmVhciAtIHpGYXIpO1xuICBkc3RbMF0gPSBmIC8gYXNwZWN0O1xuICBkc3RbMV0gPSAwO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSBmO1xuICBkc3RbNl0gPSAwO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSAwO1xuICBkc3RbOV0gPSAwO1xuICBkc3RbMTBdID0gKHpOZWFyICsgekZhcikgKiByYW5nZUludjtcbiAgZHN0WzExXSA9IC0xO1xuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSB6TmVhciAqIHpGYXIgKiByYW5nZUludiAqIDI7XG4gIGRzdFsxNV0gPSAwO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDb21wdXRlcyBhIDQtYnktNCBvdGhvZ29uYWwgdHJhbnNmb3JtYXRpb24gbWF0cml4IGdpdmVuIHRoZSBsZWZ0LCByaWdodCxcbiAqIGJvdHRvbSwgYW5kIHRvcCBkaW1lbnNpb25zIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIGFzIHdlbGwgYXMgdGhlXG4gKiBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmUgZGlzdGFuY2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBzaWRlIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIHZpZXdwb3J0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IHNpZGUgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdmlld3BvcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIHZpZXdwb3J0LlxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gKiAgICAgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIFRoZSBkZXB0aCAobmVnYXRpdmUgeiBjb29yZGluYXRlKVxuICogICAgIG9mIHRoZSBmYXIgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIE91dHB1dCBtYXRyaXguXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgcGVyc3BlY3RpdmUgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBvcnRobyhsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIGRzdFswXSA9IDIgLyAocmlnaHQgLSBsZWZ0KTtcbiAgZHN0WzFdID0gMDtcbiAgZHN0WzJdID0gMDtcbiAgZHN0WzNdID0gMDtcbiAgZHN0WzRdID0gMDtcbiAgZHN0WzVdID0gMiAvICh0b3AgLSBib3R0b20pO1xuICBkc3RbNl0gPSAwO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSAwO1xuICBkc3RbOV0gPSAwO1xuICBkc3RbMTBdID0gMiAvIChuZWFyIC0gZmFyKTtcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSAocmlnaHQgKyBsZWZ0KSAvIChsZWZ0IC0gcmlnaHQpO1xuICBkc3RbMTNdID0gKHRvcCArIGJvdHRvbSkgLyAoYm90dG9tIC0gdG9wKTtcbiAgZHN0WzE0XSA9IChmYXIgKyBuZWFyKSAvIChuZWFyIC0gZmFyKTtcbiAgZHN0WzE1XSA9IDE7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENvbXB1dGVzIGEgNC1ieS00IHBlcnNwZWN0aXZlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBnaXZlbiB0aGUgbGVmdCwgcmlnaHQsXG4gKiB0b3AsIGJvdHRvbSwgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gVGhlIGFyZ3VtZW50cyBkZWZpbmUgYSBmcnVzdHVtXG4gKiBleHRlbmRpbmcgaW4gdGhlIG5lZ2F0aXZlIHogZGlyZWN0aW9uLiBUaGUgYXJndW1lbnRzIG5lYXIgYW5kIGZhciBhcmUgdGhlXG4gKiBkaXN0YW5jZXMgdG8gdGhlIG5lYXIgYW5kIGZhciBjbGlwcGluZyBwbGFuZXMuIE5vdGUgdGhhdCBuZWFyIGFuZCBmYXIgYXJlIG5vdFxuICogeiBjb29yZGluYXRlcywgYnV0IHJhdGhlciB0aGV5IGFyZSBkaXN0YW5jZXMgYWxvbmcgdGhlIG5lZ2F0aXZlIHotYXhpcy4gVGhlXG4gKiBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LiBXZSBhc3N1bWUgYSB1bml0XG4gKiBib3ggZXh0ZW5kaW5nIGZyb20gLTEgdG8gMSBpbiB0aGUgeCBhbmQgeSBkaW1lbnNpb25zIGFuZCBmcm9tIDAgdG8gMSBpbiB0aGUgelxuICogZGltZW5zaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBwbGFuZSBvZiB0aGUgYm94LlxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbSBwbGFuZSBvZiB0aGUgYm94LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBwbGFuZSBvZiB0aGUgYm94LlxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgVGhlIG5lZ2F0aXZlIHogY29vcmRpbmF0ZSBvZiB0aGUgbmVhciBwbGFuZSBvZiB0aGUgYm94LlxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBUaGUgbmVnYXRpdmUgeiBjb29yZGluYXRlIG9mIHRoZSBmYXIgcGxhbmUgb2YgdGhlIGJveC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gT3V0cHV0IG1hdHJpeC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gZnJ1c3R1bShsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciBkeCA9IHJpZ2h0IC0gbGVmdDtcbiAgdmFyIGR5ID0gdG9wIC0gYm90dG9tO1xuICB2YXIgZHogPSBuZWFyIC0gZmFyO1xuICBkc3RbMF0gPSAyICogbmVhciAvIGR4O1xuICBkc3RbMV0gPSAwO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSAyICogbmVhciAvIGR5O1xuICBkc3RbNl0gPSAwO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSAobGVmdCArIHJpZ2h0KSAvIGR4O1xuICBkc3RbOV0gPSAodG9wICsgYm90dG9tKSAvIGR5O1xuICBkc3RbMTBdID0gZmFyIC8gZHo7XG4gIGRzdFsxMV0gPSAtMTtcbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gbmVhciAqIGZhciAvIGR6O1xuICBkc3RbMTVdID0gMDtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSA0LWJ5LTQgbG9vay1hdCB0cmFuc2Zvcm1hdGlvbi5cbiAqXG4gKiBUaGlzIGlzIGEgbWF0cml4IHdoaWNoIHBvc2l0aW9ucyB0aGUgY2FtZXJhIGl0c2VsZi4gSWYgeW91IHdhbnRcbiAqIGEgdmlldyBtYXRyaXggKGEgbWF0cml4IHdoaWNoIG1vdmVzIHRoaW5ncyBpbiBmcm9udCBvZiB0aGUgY2FtZXJhKVxuICogdGFrZSB0aGUgaW52ZXJzZSBvZiB0aGlzLlxuICpcbiAqIEBwYXJhbSB7VmVjM30gZXllIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXllLlxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgVGhlIHBvc2l0aW9uIG1lYW50IHRvIGJlIHZpZXdlZC5cbiAqIEBwYXJhbSB7VmVjM30gdXAgQSB2ZWN0b3IgcG9pbnRpbmcgdXAuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm9uZSBuZXcgb25lIGlzIGNyZWF0ZWQuLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIGxvb2stYXQgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBsb29rQXQoZXllLCB0YXJnZXQsIHVwLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIHhBeGlzID0gdGVtcFYzYTtcbiAgdmFyIHlBeGlzID0gdGVtcFYzYjtcbiAgdmFyIHpBeGlzID0gdGVtcFYzYztcbiAgdjMubm9ybWFsaXplKHYzLnN1YnRyYWN0KGV5ZSwgdGFyZ2V0LCB6QXhpcyksIHpBeGlzKTtcbiAgdjMubm9ybWFsaXplKHYzLmNyb3NzKHVwLCB6QXhpcywgeEF4aXMpLCB4QXhpcyk7XG4gIHYzLm5vcm1hbGl6ZSh2My5jcm9zcyh6QXhpcywgeEF4aXMsIHlBeGlzKSwgeUF4aXMpO1xuICBkc3RbMF0gPSB4QXhpc1swXTtcbiAgZHN0WzFdID0geEF4aXNbMV07XG4gIGRzdFsyXSA9IHhBeGlzWzJdO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSB5QXhpc1swXTtcbiAgZHN0WzVdID0geUF4aXNbMV07XG4gIGRzdFs2XSA9IHlBeGlzWzJdO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSB6QXhpc1swXTtcbiAgZHN0WzldID0gekF4aXNbMV07XG4gIGRzdFsxMF0gPSB6QXhpc1syXTtcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSBleWVbMF07XG4gIGRzdFsxM10gPSBleWVbMV07XG4gIGRzdFsxNF0gPSBleWVbMl07XG4gIGRzdFsxNV0gPSAxO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCB0cmFuc2xhdGVzIGJ5IHRoZSBnaXZlbiB2ZWN0b3Igdi5cbiAqIEBwYXJhbSB7VmVjM30gdiBUaGUgdmVjdG9yIGJ5XG4gKiAgICAgd2hpY2ggdG8gdHJhbnNsYXRlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vbmUgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSB0cmFuc2xhdGlvbiBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zbGF0aW9uKHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICBkc3RbMF0gPSAxO1xuICBkc3RbMV0gPSAwO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSAxO1xuICBkc3RbNl0gPSAwO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSAwO1xuICBkc3RbOV0gPSAwO1xuICBkc3RbMTBdID0gMTtcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSB2WzBdO1xuICBkc3RbMTNdID0gdlsxXTtcbiAgZHN0WzE0XSA9IHZbMl07XG4gIGRzdFsxNV0gPSAxO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBNb2RpZmllcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBieSB0cmFuc2xhdGlvbiBieSB0aGUgZ2l2ZW4gdmVjdG9yIHYuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7VmVjM30gdiBUaGUgdmVjdG9yIGJ5XG4gKiAgICAgd2hpY2ggdG8gdHJhbnNsYXRlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vbmUgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gb25jZSBtb2RpZmllZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNsYXRlKG0sIHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICB2YXIgdjAgPSB2WzBdO1xuICB2YXIgdjEgPSB2WzFdO1xuICB2YXIgdjIgPSB2WzJdO1xuICB2YXIgbTAwID0gbVswXTtcbiAgdmFyIG0wMSA9IG1bMV07XG4gIHZhciBtMDIgPSBtWzJdO1xuICB2YXIgbTAzID0gbVszXTtcbiAgdmFyIG0xMCA9IG1bMSAqIDQgKyAwXTtcbiAgdmFyIG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgdmFyIG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgdmFyIG0xMyA9IG1bMSAqIDQgKyAzXTtcbiAgdmFyIG0yMCA9IG1bMiAqIDQgKyAwXTtcbiAgdmFyIG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgdmFyIG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgdmFyIG0yMyA9IG1bMiAqIDQgKyAzXTtcbiAgdmFyIG0zMCA9IG1bMyAqIDQgKyAwXTtcbiAgdmFyIG0zMSA9IG1bMyAqIDQgKyAxXTtcbiAgdmFyIG0zMiA9IG1bMyAqIDQgKyAyXTtcbiAgdmFyIG0zMyA9IG1bMyAqIDQgKyAzXTtcblxuICBpZiAobSAhPT0gZHN0KSB7XG4gICAgZHN0WzBdID0gbTAwO1xuICAgIGRzdFsxXSA9IG0wMTtcbiAgICBkc3RbMl0gPSBtMDI7XG4gICAgZHN0WzNdID0gbTAzO1xuICAgIGRzdFs0XSA9IG0xMDtcbiAgICBkc3RbNV0gPSBtMTE7XG4gICAgZHN0WzZdID0gbTEyO1xuICAgIGRzdFs3XSA9IG0xMztcbiAgICBkc3RbOF0gPSBtMjA7XG4gICAgZHN0WzldID0gbTIxO1xuICAgIGRzdFsxMF0gPSBtMjI7XG4gICAgZHN0WzExXSA9IG0yMztcbiAgfVxuXG4gIGRzdFsxMl0gPSBtMDAgKiB2MCArIG0xMCAqIHYxICsgbTIwICogdjIgKyBtMzA7XG4gIGRzdFsxM10gPSBtMDEgKiB2MCArIG0xMSAqIHYxICsgbTIxICogdjIgKyBtMzE7XG4gIGRzdFsxNF0gPSBtMDIgKiB2MCArIG0xMiAqIHYxICsgbTIyICogdjIgKyBtMzI7XG4gIGRzdFsxNV0gPSBtMDMgKiB2MCArIG0xMyAqIHYxICsgbTIzICogdjIgKyBtMzM7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHRoZSB4LWF4aXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vbmUgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSByb3RhdGlvbiBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0aW9uWChhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgZHN0WzBdID0gMTtcbiAgZHN0WzFdID0gMDtcbiAgZHN0WzJdID0gMDtcbiAgZHN0WzNdID0gMDtcbiAgZHN0WzRdID0gMDtcbiAgZHN0WzVdID0gYztcbiAgZHN0WzZdID0gcztcbiAgZHN0WzddID0gMDtcbiAgZHN0WzhdID0gMDtcbiAgZHN0WzldID0gLXM7XG4gIGRzdFsxMF0gPSBjO1xuICBkc3RbMTFdID0gMDtcbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gMDtcbiAgZHN0WzE1XSA9IDE7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIE1vZGlmaWVzIHRoZSBnaXZlbiA0LWJ5LTQgbWF0cml4IGJ5IGEgcm90YXRpb24gYXJvdW5kIHRoZSB4LWF4aXMgYnkgdGhlIGdpdmVuXG4gKiBhbmdsZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vbmUgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gb25jZSBtb2RpZmllZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWChtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciBtMTAgPSBtWzRdO1xuICB2YXIgbTExID0gbVs1XTtcbiAgdmFyIG0xMiA9IG1bNl07XG4gIHZhciBtMTMgPSBtWzddO1xuICB2YXIgbTIwID0gbVs4XTtcbiAgdmFyIG0yMSA9IG1bOV07XG4gIHZhciBtMjIgPSBtWzEwXTtcbiAgdmFyIG0yMyA9IG1bMTFdO1xuICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gIGRzdFs0XSA9IGMgKiBtMTAgKyBzICogbTIwO1xuICBkc3RbNV0gPSBjICogbTExICsgcyAqIG0yMTtcbiAgZHN0WzZdID0gYyAqIG0xMiArIHMgKiBtMjI7XG4gIGRzdFs3XSA9IGMgKiBtMTMgKyBzICogbTIzO1xuICBkc3RbOF0gPSBjICogbTIwIC0gcyAqIG0xMDtcbiAgZHN0WzldID0gYyAqIG0yMSAtIHMgKiBtMTE7XG4gIGRzdFsxMF0gPSBjICogbTIyIC0gcyAqIG0xMjtcbiAgZHN0WzExXSA9IGMgKiBtMjMgLSBzICogbTEzO1xuXG4gIGlmIChtICE9PSBkc3QpIHtcbiAgICBkc3RbMF0gPSBtWzBdO1xuICAgIGRzdFsxXSA9IG1bMV07XG4gICAgZHN0WzJdID0gbVsyXTtcbiAgICBkc3RbM10gPSBtWzNdO1xuICAgIGRzdFsxMl0gPSBtWzEyXTtcbiAgICBkc3RbMTNdID0gbVsxM107XG4gICAgZHN0WzE0XSA9IG1bMTRdO1xuICAgIGRzdFsxNV0gPSBtWzE1XTtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHRoZSB5LWF4aXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vbmUgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSByb3RhdGlvbiBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0aW9uWShhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgZHN0WzBdID0gYztcbiAgZHN0WzFdID0gMDtcbiAgZHN0WzJdID0gLXM7XG4gIGRzdFszXSA9IDA7XG4gIGRzdFs0XSA9IDA7XG4gIGRzdFs1XSA9IDE7XG4gIGRzdFs2XSA9IDA7XG4gIGRzdFs3XSA9IDA7XG4gIGRzdFs4XSA9IHM7XG4gIGRzdFs5XSA9IDA7XG4gIGRzdFsxMF0gPSBjO1xuICBkc3RbMTFdID0gMDtcbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gMDtcbiAgZHN0WzE1XSA9IDE7XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIE1vZGlmaWVzIHRoZSBnaXZlbiA0LWJ5LTQgbWF0cml4IGJ5IGEgcm90YXRpb24gYXJvdW5kIHRoZSB5LWF4aXMgYnkgdGhlIGdpdmVuXG4gKiBhbmdsZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vbmUgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gb25jZSBtb2RpZmllZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWShtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciBtMDAgPSBtWzAgKiA0ICsgMF07XG4gIHZhciBtMDEgPSBtWzAgKiA0ICsgMV07XG4gIHZhciBtMDIgPSBtWzAgKiA0ICsgMl07XG4gIHZhciBtMDMgPSBtWzAgKiA0ICsgM107XG4gIHZhciBtMjAgPSBtWzIgKiA0ICsgMF07XG4gIHZhciBtMjEgPSBtWzIgKiA0ICsgMV07XG4gIHZhciBtMjIgPSBtWzIgKiA0ICsgMl07XG4gIHZhciBtMjMgPSBtWzIgKiA0ICsgM107XG4gIHZhciBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgZHN0WzBdID0gYyAqIG0wMCAtIHMgKiBtMjA7XG4gIGRzdFsxXSA9IGMgKiBtMDEgLSBzICogbTIxO1xuICBkc3RbMl0gPSBjICogbTAyIC0gcyAqIG0yMjtcbiAgZHN0WzNdID0gYyAqIG0wMyAtIHMgKiBtMjM7XG4gIGRzdFs4XSA9IGMgKiBtMjAgKyBzICogbTAwO1xuICBkc3RbOV0gPSBjICogbTIxICsgcyAqIG0wMTtcbiAgZHN0WzEwXSA9IGMgKiBtMjIgKyBzICogbTAyO1xuICBkc3RbMTFdID0gYyAqIG0yMyArIHMgKiBtMDM7XG5cbiAgaWYgKG0gIT09IGRzdCkge1xuICAgIGRzdFs0XSA9IG1bNF07XG4gICAgZHN0WzVdID0gbVs1XTtcbiAgICBkc3RbNl0gPSBtWzZdO1xuICAgIGRzdFs3XSA9IG1bN107XG4gICAgZHN0WzEyXSA9IG1bMTJdO1xuICAgIGRzdFsxM10gPSBtWzEzXTtcbiAgICBkc3RbMTRdID0gbVsxNF07XG4gICAgZHN0WzE1XSA9IG1bMTVdO1xuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIDQtYnktNCBtYXRyaXggd2hpY2ggcm90YXRlcyBhcm91bmQgdGhlIHotYXhpcyBieSB0aGUgZ2l2ZW4gYW5nbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm9uZSBuZXcgb25lIGlzIGNyZWF0ZWQuLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHJvdGF0aW9uIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRpb25aKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIHZhciBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICBkc3RbMF0gPSBjO1xuICBkc3RbMV0gPSBzO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAtcztcbiAgZHN0WzVdID0gYztcbiAgZHN0WzZdID0gMDtcbiAgZHN0WzddID0gMDtcbiAgZHN0WzhdID0gMDtcbiAgZHN0WzldID0gMDtcbiAgZHN0WzEwXSA9IDE7XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSAwO1xuICBkc3RbMTVdID0gMTtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogTW9kaWZpZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYnkgYSByb3RhdGlvbiBhcm91bmQgdGhlIHotYXhpcyBieSB0aGUgZ2l2ZW5cbiAqIGFuZ2xlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm9uZSBuZXcgb25lIGlzIGNyZWF0ZWQuLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBvbmNlIG1vZGlmaWVkLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVaKG0sIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgdmFyIG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgdmFyIG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgdmFyIG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgdmFyIG0wMyA9IG1bMCAqIDQgKyAzXTtcbiAgdmFyIG0xMCA9IG1bMSAqIDQgKyAwXTtcbiAgdmFyIG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgdmFyIG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgdmFyIG0xMyA9IG1bMSAqIDQgKyAzXTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIHZhciBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICBkc3RbMF0gPSBjICogbTAwICsgcyAqIG0xMDtcbiAgZHN0WzFdID0gYyAqIG0wMSArIHMgKiBtMTE7XG4gIGRzdFsyXSA9IGMgKiBtMDIgKyBzICogbTEyO1xuICBkc3RbM10gPSBjICogbTAzICsgcyAqIG0xMztcbiAgZHN0WzRdID0gYyAqIG0xMCAtIHMgKiBtMDA7XG4gIGRzdFs1XSA9IGMgKiBtMTEgLSBzICogbTAxO1xuICBkc3RbNl0gPSBjICogbTEyIC0gcyAqIG0wMjtcbiAgZHN0WzddID0gYyAqIG0xMyAtIHMgKiBtMDM7XG5cbiAgaWYgKG0gIT09IGRzdCkge1xuICAgIGRzdFs4XSA9IG1bOF07XG4gICAgZHN0WzldID0gbVs5XTtcbiAgICBkc3RbMTBdID0gbVsxMF07XG4gICAgZHN0WzExXSA9IG1bMTFdO1xuICAgIGRzdFsxMl0gPSBtWzEyXTtcbiAgICBkc3RbMTNdID0gbVsxM107XG4gICAgZHN0WzE0XSA9IG1bMTRdO1xuICAgIGRzdFsxNV0gPSBtWzE1XTtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHRoZSBnaXZlbiBheGlzIGJ5IHRoZSBnaXZlblxuICogYW5nbGUuXG4gKiBAcGFyYW0ge1ZlYzN9IGF4aXMgVGhlIGF4aXNcbiAqICAgICBhYm91dCB3aGljaCB0byByb3RhdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm9uZSBuZXcgb25lIGlzIGNyZWF0ZWQuLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gQSBtYXRyaXggd2hpY2ggcm90YXRlcyBhbmdsZSByYWRpYW5zXG4gKiAgICAgYXJvdW5kIHRoZSBheGlzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBheGlzUm90YXRpb24oYXhpcywgYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICB2YXIgeCA9IGF4aXNbMF07XG4gIHZhciB5ID0gYXhpc1sxXTtcbiAgdmFyIHogPSBheGlzWzJdO1xuICB2YXIgbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICB4IC89IG47XG4gIHkgLz0gbjtcbiAgeiAvPSBuO1xuICB2YXIgeHggPSB4ICogeDtcbiAgdmFyIHl5ID0geSAqIHk7XG4gIHZhciB6eiA9IHogKiB6O1xuICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gIHZhciBvbmVNaW51c0Nvc2luZSA9IDEgLSBjO1xuICBkc3RbMF0gPSB4eCArICgxIC0geHgpICogYztcbiAgZHN0WzFdID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSArIHogKiBzO1xuICBkc3RbMl0gPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geSAqIHM7XG4gIGRzdFszXSA9IDA7XG4gIGRzdFs0XSA9IHggKiB5ICogb25lTWludXNDb3NpbmUgLSB6ICogcztcbiAgZHN0WzVdID0geXkgKyAoMSAtIHl5KSAqIGM7XG4gIGRzdFs2XSA9IHkgKiB6ICogb25lTWludXNDb3NpbmUgKyB4ICogcztcbiAgZHN0WzddID0gMDtcbiAgZHN0WzhdID0geCAqIHogKiBvbmVNaW51c0Nvc2luZSArIHkgKiBzO1xuICBkc3RbOV0gPSB5ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geCAqIHM7XG4gIGRzdFsxMF0gPSB6eiArICgxIC0genopICogYztcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSAwO1xuICBkc3RbMTNdID0gMDtcbiAgZHN0WzE0XSA9IDA7XG4gIGRzdFsxNV0gPSAxO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBNb2RpZmllcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBieSByb3RhdGlvbiBhcm91bmQgdGhlIGdpdmVuIGF4aXMgYnkgdGhlXG4gKiBnaXZlbiBhbmdsZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHtWZWMzfSBheGlzIFRoZSBheGlzXG4gKiAgICAgYWJvdXQgd2hpY2ggdG8gcm90YXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vbmUgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gb25jZSBtb2RpZmllZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gYXhpc1JvdGF0ZShtLCBheGlzLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciB4ID0gYXhpc1swXTtcbiAgdmFyIHkgPSBheGlzWzFdO1xuICB2YXIgeiA9IGF4aXNbMl07XG4gIHZhciBuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIHggLz0gbjtcbiAgeSAvPSBuO1xuICB6IC89IG47XG4gIHZhciB4eCA9IHggKiB4O1xuICB2YXIgeXkgPSB5ICogeTtcbiAgdmFyIHp6ID0geiAqIHo7XG4gIHZhciBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgdmFyIG9uZU1pbnVzQ29zaW5lID0gMSAtIGM7XG4gIHZhciByMDAgPSB4eCArICgxIC0geHgpICogYztcbiAgdmFyIHIwMSA9IHggKiB5ICogb25lTWludXNDb3NpbmUgKyB6ICogcztcbiAgdmFyIHIwMiA9IHggKiB6ICogb25lTWludXNDb3NpbmUgLSB5ICogcztcbiAgdmFyIHIxMCA9IHggKiB5ICogb25lTWludXNDb3NpbmUgLSB6ICogcztcbiAgdmFyIHIxMSA9IHl5ICsgKDEgLSB5eSkgKiBjO1xuICB2YXIgcjEyID0geSAqIHogKiBvbmVNaW51c0Nvc2luZSArIHggKiBzO1xuICB2YXIgcjIwID0geCAqIHogKiBvbmVNaW51c0Nvc2luZSArIHkgKiBzO1xuICB2YXIgcjIxID0geSAqIHogKiBvbmVNaW51c0Nvc2luZSAtIHggKiBzO1xuICB2YXIgcjIyID0genogKyAoMSAtIHp6KSAqIGM7XG4gIHZhciBtMDAgPSBtWzBdO1xuICB2YXIgbTAxID0gbVsxXTtcbiAgdmFyIG0wMiA9IG1bMl07XG4gIHZhciBtMDMgPSBtWzNdO1xuICB2YXIgbTEwID0gbVs0XTtcbiAgdmFyIG0xMSA9IG1bNV07XG4gIHZhciBtMTIgPSBtWzZdO1xuICB2YXIgbTEzID0gbVs3XTtcbiAgdmFyIG0yMCA9IG1bOF07XG4gIHZhciBtMjEgPSBtWzldO1xuICB2YXIgbTIyID0gbVsxMF07XG4gIHZhciBtMjMgPSBtWzExXTtcbiAgZHN0WzBdID0gcjAwICogbTAwICsgcjAxICogbTEwICsgcjAyICogbTIwO1xuICBkc3RbMV0gPSByMDAgKiBtMDEgKyByMDEgKiBtMTEgKyByMDIgKiBtMjE7XG4gIGRzdFsyXSA9IHIwMCAqIG0wMiArIHIwMSAqIG0xMiArIHIwMiAqIG0yMjtcbiAgZHN0WzNdID0gcjAwICogbTAzICsgcjAxICogbTEzICsgcjAyICogbTIzO1xuICBkc3RbNF0gPSByMTAgKiBtMDAgKyByMTEgKiBtMTAgKyByMTIgKiBtMjA7XG4gIGRzdFs1XSA9IHIxMCAqIG0wMSArIHIxMSAqIG0xMSArIHIxMiAqIG0yMTtcbiAgZHN0WzZdID0gcjEwICogbTAyICsgcjExICogbTEyICsgcjEyICogbTIyO1xuICBkc3RbN10gPSByMTAgKiBtMDMgKyByMTEgKiBtMTMgKyByMTIgKiBtMjM7XG4gIGRzdFs4XSA9IHIyMCAqIG0wMCArIHIyMSAqIG0xMCArIHIyMiAqIG0yMDtcbiAgZHN0WzldID0gcjIwICogbTAxICsgcjIxICogbTExICsgcjIyICogbTIxO1xuICBkc3RbMTBdID0gcjIwICogbTAyICsgcjIxICogbTEyICsgcjIyICogbTIyO1xuICBkc3RbMTFdID0gcjIwICogbTAzICsgcjIxICogbTEzICsgcjIyICogbTIzO1xuXG4gIGlmIChtICE9PSBkc3QpIHtcbiAgICBkc3RbMTJdID0gbVsxMl07XG4gICAgZHN0WzEzXSA9IG1bMTNdO1xuICAgIGRzdFsxNF0gPSBtWzE0XTtcbiAgICBkc3RbMTVdID0gbVsxNV07XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCBzY2FsZXMgaW4gZWFjaCBkaW1lbnNpb24gYnkgYW4gYW1vdW50IGdpdmVuIGJ5XG4gKiB0aGUgY29ycmVzcG9uZGluZyBlbnRyeSBpbiB0aGUgZ2l2ZW4gdmVjdG9yOyBhc3N1bWVzIHRoZSB2ZWN0b3IgaGFzIHRocmVlXG4gKiBlbnRyaWVzLlxuICogQHBhcmFtIHtWZWMzfSB2IEEgdmVjdG9yIG9mXG4gKiAgICAgdGhyZWUgZW50cmllcyBzcGVjaWZ5aW5nIHRoZSBmYWN0b3IgYnkgd2hpY2ggdG8gc2NhbGUgaW4gZWFjaCBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm9uZSBuZXcgb25lIGlzIGNyZWF0ZWQuLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHNjYWxpbmcgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsaW5nKHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuICBkc3RbMF0gPSB2WzBdO1xuICBkc3RbMV0gPSAwO1xuICBkc3RbMl0gPSAwO1xuICBkc3RbM10gPSAwO1xuICBkc3RbNF0gPSAwO1xuICBkc3RbNV0gPSB2WzFdO1xuICBkc3RbNl0gPSAwO1xuICBkc3RbN10gPSAwO1xuICBkc3RbOF0gPSAwO1xuICBkc3RbOV0gPSAwO1xuICBkc3RbMTBdID0gdlsyXTtcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSAwO1xuICBkc3RbMTNdID0gMDtcbiAgZHN0WzE0XSA9IDA7XG4gIGRzdFsxNV0gPSAxO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBNb2RpZmllcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCwgc2NhbGluZyBpbiBlYWNoIGRpbWVuc2lvbiBieSBhbiBhbW91bnRcbiAqIGdpdmVuIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGVudHJ5IGluIHRoZSBnaXZlbiB2ZWN0b3I7IGFzc3VtZXMgdGhlIHZlY3RvciBoYXNcbiAqIHRocmVlIGVudHJpZXMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeCB0byBiZSBtb2RpZmllZC5cbiAqIEBwYXJhbSB7VmVjM30gdiBBIHZlY3RvciBvZiB0aHJlZSBlbnRyaWVzIHNwZWNpZnlpbmcgdGhlXG4gKiAgICAgZmFjdG9yIGJ5IHdoaWNoIHRvIHNjYWxlIGluIGVhY2ggZGltZW5zaW9uLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vbmUgbmV3IG9uZSBpcyBjcmVhdGVkLi5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gb25jZSBtb2RpZmllZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gc2NhbGUobSwgdiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIHZhciB2MCA9IHZbMF07XG4gIHZhciB2MSA9IHZbMV07XG4gIHZhciB2MiA9IHZbMl07XG4gIGRzdFswXSA9IHYwICogbVswICogNCArIDBdO1xuICBkc3RbMV0gPSB2MCAqIG1bMCAqIDQgKyAxXTtcbiAgZHN0WzJdID0gdjAgKiBtWzAgKiA0ICsgMl07XG4gIGRzdFszXSA9IHYwICogbVswICogNCArIDNdO1xuICBkc3RbNF0gPSB2MSAqIG1bMSAqIDQgKyAwXTtcbiAgZHN0WzVdID0gdjEgKiBtWzEgKiA0ICsgMV07XG4gIGRzdFs2XSA9IHYxICogbVsxICogNCArIDJdO1xuICBkc3RbN10gPSB2MSAqIG1bMSAqIDQgKyAzXTtcbiAgZHN0WzhdID0gdjIgKiBtWzIgKiA0ICsgMF07XG4gIGRzdFs5XSA9IHYyICogbVsyICogNCArIDFdO1xuICBkc3RbMTBdID0gdjIgKiBtWzIgKiA0ICsgMl07XG4gIGRzdFsxMV0gPSB2MiAqIG1bMiAqIDQgKyAzXTtcblxuICBpZiAobSAhPT0gZHN0KSB7XG4gICAgZHN0WzEyXSA9IG1bMTJdO1xuICAgIGRzdFsxM10gPSBtWzEzXTtcbiAgICBkc3RbMTRdID0gbVsxNF07XG4gICAgZHN0WzE1XSA9IG1bMTVdO1xuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogVGFrZXMgYSA0LWJ5LTQgbWF0cml4IGFuZCBhIHZlY3RvciB3aXRoIDMgZW50cmllcyxcbiAqIGludGVycHJldHMgdGhlIHZlY3RvciBhcyBhIHBvaW50LCB0cmFuc2Zvcm1zIHRoYXQgcG9pbnQgYnkgdGhlIG1hdHJpeCwgYW5kXG4gKiByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSB2ZWN0b3Igd2l0aCAzIGVudHJpZXMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7VmVjM30gdiBUaGUgcG9pbnQuXG4gKiBAcGFyYW0ge1ZlYzN9IGRzdCBvcHRpb25hbCB2ZWMzIHRvIHN0b3JlIHJlc3VsdFxuICogQHJldHVybiB7VmVjM30gZHN0IG9yIG5ldyB2ZWMzIGlmIG5vdCBwcm92aWRlZFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChtLCB2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IHYzLmNyZWF0ZSgpO1xuICB2YXIgdjAgPSB2WzBdO1xuICB2YXIgdjEgPSB2WzFdO1xuICB2YXIgdjIgPSB2WzJdO1xuICB2YXIgZCA9IHYwICogbVswICogNCArIDNdICsgdjEgKiBtWzEgKiA0ICsgM10gKyB2MiAqIG1bMiAqIDQgKyAzXSArIG1bMyAqIDQgKyAzXTtcbiAgZHN0WzBdID0gKHYwICogbVswICogNCArIDBdICsgdjEgKiBtWzEgKiA0ICsgMF0gKyB2MiAqIG1bMiAqIDQgKyAwXSArIG1bMyAqIDQgKyAwXSkgLyBkO1xuICBkc3RbMV0gPSAodjAgKiBtWzAgKiA0ICsgMV0gKyB2MSAqIG1bMSAqIDQgKyAxXSArIHYyICogbVsyICogNCArIDFdICsgbVszICogNCArIDFdKSAvIGQ7XG4gIGRzdFsyXSA9ICh2MCAqIG1bMCAqIDQgKyAyXSArIHYxICogbVsxICogNCArIDJdICsgdjIgKiBtWzIgKiA0ICsgMl0gKyBtWzMgKiA0ICsgMl0pIC8gZDtcbiAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogVGFrZXMgYSA0LWJ5LTQgbWF0cml4IGFuZCBhIHZlY3RvciB3aXRoIDMgZW50cmllcywgaW50ZXJwcmV0cyB0aGUgdmVjdG9yIGFzIGFcbiAqIGRpcmVjdGlvbiwgdHJhbnNmb3JtcyB0aGF0IGRpcmVjdGlvbiBieSB0aGUgbWF0cml4LCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0O1xuICogYXNzdW1lcyB0aGUgdHJhbnNmb3JtYXRpb24gb2YgMy1kaW1lbnNpb25hbCBzcGFjZSByZXByZXNlbnRlZCBieSB0aGUgbWF0cml4XG4gKiBpcyBwYXJhbGxlbC1wcmVzZXJ2aW5nLCBpLmUuIGFueSBjb21iaW5hdGlvbiBvZiByb3RhdGlvbiwgc2NhbGluZyBhbmRcbiAqIHRyYW5zbGF0aW9uLCBidXQgbm90IGEgcGVyc3BlY3RpdmUgZGlzdG9ydGlvbi4gUmV0dXJucyBhIHZlY3RvciB3aXRoIDNcbiAqIGVudHJpZXMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7VmVjM30gdiBUaGUgZGlyZWN0aW9uLlxuICogQHBhcmFtIHtWZWMzfSBkc3Qgb3B0aW9uYWwgVmVjMyB0byBzdG9yZSByZXN1bHRcbiAqIEByZXR1cm4ge1ZlYzN9IGRzdCBvciBuZXcgVmVjMyBpZiBub3QgcHJvdmlkZWRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtRGlyZWN0aW9uKG0sIHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgdjMuY3JlYXRlKCk7XG4gIHZhciB2MCA9IHZbMF07XG4gIHZhciB2MSA9IHZbMV07XG4gIHZhciB2MiA9IHZbMl07XG4gIGRzdFswXSA9IHYwICogbVswICogNCArIDBdICsgdjEgKiBtWzEgKiA0ICsgMF0gKyB2MiAqIG1bMiAqIDQgKyAwXTtcbiAgZHN0WzFdID0gdjAgKiBtWzAgKiA0ICsgMV0gKyB2MSAqIG1bMSAqIDQgKyAxXSArIHYyICogbVsyICogNCArIDFdO1xuICBkc3RbMl0gPSB2MCAqIG1bMCAqIDQgKyAyXSArIHYxICogbVsxICogNCArIDJdICsgdjIgKiBtWzIgKiA0ICsgMl07XG4gIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIFRha2VzIGEgNC1ieS00IG1hdHJpeCBtIGFuZCBhIHZlY3RvciB2IHdpdGggMyBlbnRyaWVzLCBpbnRlcnByZXRzIHRoZSB2ZWN0b3JcbiAqIGFzIGEgbm9ybWFsIHRvIGEgc3VyZmFjZSwgYW5kIGNvbXB1dGVzIGEgdmVjdG9yIHdoaWNoIGlzIG5vcm1hbCB1cG9uXG4gKiB0cmFuc2Zvcm1pbmcgdGhhdCBzdXJmYWNlIGJ5IHRoZSBtYXRyaXguIFRoZSBlZmZlY3Qgb2YgdGhpcyBmdW5jdGlvbiBpcyB0aGVcbiAqIHNhbWUgYXMgdHJhbnNmb3JtaW5nIHYgKGFzIGEgZGlyZWN0aW9uKSBieSB0aGUgaW52ZXJzZS10cmFuc3Bvc2Ugb2YgbS4gIFRoaXNcbiAqIGZ1bmN0aW9uIGFzc3VtZXMgdGhlIHRyYW5zZm9ybWF0aW9uIG9mIDMtZGltZW5zaW9uYWwgc3BhY2UgcmVwcmVzZW50ZWQgYnkgdGhlXG4gKiBtYXRyaXggaXMgcGFyYWxsZWwtcHJlc2VydmluZywgaS5lLiBhbnkgY29tYmluYXRpb24gb2Ygcm90YXRpb24sIHNjYWxpbmcgYW5kXG4gKiB0cmFuc2xhdGlvbiwgYnV0IG5vdCBhIHBlcnNwZWN0aXZlIGRpc3RvcnRpb24uICBSZXR1cm5zIGEgdmVjdG9yIHdpdGggM1xuICogZW50cmllcy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSBub3JtYWwuXG4gKiBAcGFyYW0ge1ZlYzN9IFtkc3RdIFRoZSBkaXJlY3Rpb24uXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgdHJhbnNmb3JtZWQgZGlyZWN0aW9uLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob3JtYWwobSwgdiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCB2My5jcmVhdGUoKTtcbiAgdmFyIG1pID0gaW52ZXJzZShtKTtcbiAgdmFyIHYwID0gdlswXTtcbiAgdmFyIHYxID0gdlsxXTtcbiAgdmFyIHYyID0gdlsyXTtcbiAgZHN0WzBdID0gdjAgKiBtaVswICogNCArIDBdICsgdjEgKiBtaVswICogNCArIDFdICsgdjIgKiBtaVswICogNCArIDJdO1xuICBkc3RbMV0gPSB2MCAqIG1pWzEgKiA0ICsgMF0gKyB2MSAqIG1pWzEgKiA0ICsgMV0gKyB2MiAqIG1pWzEgKiA0ICsgMl07XG4gIGRzdFsyXSA9IHYwICogbWlbMiAqIDQgKyAwXSArIHYxICogbWlbMiAqIDQgKyAxXSArIHYyICogbWlbMiAqIDQgKyAyXTtcbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNyZWF0ZUF0dHJpYnNGcm9tQXJyYXlzID0gY3JlYXRlQXR0cmlic0Zyb21BcnJheXM7XG5leHBvcnRzLmNyZWF0ZUJ1ZmZlcnNGcm9tQXJyYXlzID0gY3JlYXRlQnVmZmVyc0Zyb21BcnJheXM7XG5leHBvcnRzLmNyZWF0ZUJ1ZmZlckZyb21BcnJheSA9IGNyZWF0ZUJ1ZmZlckZyb21BcnJheTtcbmV4cG9ydHMuY3JlYXRlQnVmZmVyRnJvbVR5cGVkQXJyYXkgPSBjcmVhdGVCdWZmZXJGcm9tVHlwZWRBcnJheTtcbmV4cG9ydHMuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMgPSBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cztcbmV4cG9ydHMuc2V0QXR0cmliSW5mb0J1ZmZlckZyb21BcnJheSA9IHNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXk7XG5leHBvcnRzLnNldEF0dHJpYnV0ZVByZWZpeCA9IHNldEF0dHJpYnV0ZVByZWZpeDtcbmV4cG9ydHMuc2V0QXR0cmlidXRlRGVmYXVsdHNfID0gc2V0RGVmYXVsdHM7XG5leHBvcnRzLmdldE51bUNvbXBvbmVudHNfID0gZ2V0TnVtQ29tcG9uZW50cztcbmV4cG9ydHMuZ2V0QXJyYXlfID0gZ2V0QXJyYXk7XG5cbnZhciB0eXBlZEFycmF5cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xuXG52YXIgaGVscGVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygwKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLypcbiAqIENvcHlyaWdodCAyMDE1LCBHcmVnZyBUYXZhcmVzLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuICogaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuICogZGlzdHJpYnV0aW9uLlxuICogICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiBHcmVnZyBUYXZhcmVzLiBub3IgdGhlIG5hbWVzIG9mIGhpc1xuICogY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qKlxuICogTG93IGxldmVsIGF0dHJpYnV0ZSBhbmQgYnVmZmVyIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKlxuICogWW91IHNob3VsZCBnZW5lcmFsbHkgbm90IG5lZWQgdG8gdXNlIHRoZXNlIGZ1bmN0aW9ucy4gVGhleSBhcmUgcHJvdmlkZWRcbiAqIGZvciB0aG9zZSBjYXNlcyB3aGVyZSB5b3UncmUgZG9pbmcgc29tZXRoaW5nIG91dCBvZiB0aGUgb3JkaW5hcnlcbiAqIGFuZCB5b3UgbmVlZCBsb3dlciBsZXZlbCBhY2Nlc3MuXG4gKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWx5IHRoZXkgYXJlIGF2YWlsYWJsZSBhdCBib3RoIGB0d2dsLmF0dHJpYnV0ZXNgIGFuZCBgdHdnbGBcbiAqIGl0c2VsZlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2x9IGZvciBjb3JlIGZ1bmN0aW9uc1xuICpcbiAqIEBtb2R1bGUgdHdnbC9hdHRyaWJ1dGVzXG4gKi9cbi8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBzZWUgYSBnbG9iYWwgZ2xcbnZhciBnbCA9IHVuZGVmaW5lZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGF0dHJpYlByZWZpeDogXCJcIlxufTtcbi8qKlxuICogU2V0cyB0aGUgZGVmYXVsdCBhdHRyaWIgcHJlZml4XG4gKlxuICogV2hlbiB3cml0aW5nIHNoYWRlcnMgSSBwcmVmZXIgdG8gbmFtZSBhdHRyaWJ1dGVzIHdpdGggYGFfYCwgdW5pZm9ybXMgd2l0aCBgdV9gIGFuZCB2YXJ5aW5ncyB3aXRoIGB2X2BcbiAqIGFzIGl0IG1ha2VzIGl0IGNsZWFyIHdoZXJlIHRoZXkgY2FtZSBmcm9tLiBCdXQsIHdoZW4gYnVpbGRpbmcgZ2VvbWV0cnkgSSBwcmVmZXIgdXNpbmcgdW5wcmVmaXhlZCBuYW1lcy5cbiAqXG4gKiBJbiBvdGhlcndvcmRzIEknbGwgY3JlYXRlIGFycmF5cyBvZiBnZW9tZXRyeSBsaWtlIHRoaXNcbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgIHBvc2l0aW9uOiAuLi5cbiAqICAgICAgIG5vcm1hbDogLi4uXG4gKiAgICAgICB0ZXhjb29yZDogLi4uXG4gKiAgICAgfTtcbiAqXG4gKiBCdXQgbmVlZCB0aG9zZSBtYXBwZWQgdG8gYXR0cmlidXRlcyBhbmQgbXkgYXR0cmlidXRlcyBzdGFydCB3aXRoIGBhX2AuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2VlIHtAbGluayBtb2R1bGU6dHdnbC5zZXREZWZhdWx0c31cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggcHJlZml4IGZvciBhdHRyaWJzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvYXR0cmlidXRlc1xuICovXG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZVByZWZpeChwcmVmaXgpIHtcbiAgZGVmYXVsdHMuYXR0cmliUHJlZml4ID0gcHJlZml4O1xufVxuXG5mdW5jdGlvbiBzZXREZWZhdWx0cyhuZXdEZWZhdWx0cykge1xuICBoZWxwZXIuY29weUV4aXN0aW5nUHJvcGVydGllcyhuZXdEZWZhdWx0cywgZGVmYXVsdHMpO1xufVxuXG5mdW5jdGlvbiBzZXRCdWZmZXJGcm9tVHlwZWRBcnJheShnbCwgdHlwZSwgYnVmZmVyLCBhcnJheSwgZHJhd1R5cGUpIHtcbiAgZ2wuYmluZEJ1ZmZlcih0eXBlLCBidWZmZXIpO1xuICBnbC5idWZmZXJEYXRhKHR5cGUsIGFycmF5LCBkcmF3VHlwZSB8fCBnbC5TVEFUSUNfRFJBVyk7XG59XG4vKipcbiAqIEdpdmVuIHR5cGVkIGFycmF5IGNyZWF0ZXMgYSBXZWJHTEJ1ZmZlciBhbmQgY29waWVzIHRoZSB0eXBlZCBhcnJheVxuICogaW50byBpdC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8U2hhcmVkQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fFdlYkdMQnVmZmVyfSB0eXBlZEFycmF5IHRoZSB0eXBlZCBhcnJheS4gTm90ZTogSWYgYSBXZWJHTEJ1ZmZlciBpcyBwYXNzZWQgaW4gaXQgd2lsbCBqdXN0IGJlIHJldHVybmVkLiBObyBhY3Rpb24gd2lsbCBiZSB0YWtlblxuICogQHBhcmFtIHtudW1iZXJ9IFt0eXBlXSB0aGUgR0wgYmluZCB0eXBlIGZvciB0aGUgYnVmZmVyLiBEZWZhdWx0ID0gYGdsLkFSUkFZX0JVRkZFUmAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2RyYXdUeXBlXSB0aGUgR0wgZHJhdyB0eXBlIGZvciB0aGUgYnVmZmVyLiBEZWZhdWx0ID0gJ2dsLlNUQVRJQ19EUkFXYC5cbiAqIEByZXR1cm4ge1dlYkdMQnVmZmVyfSB0aGUgY3JlYXRlZCBXZWJHTEJ1ZmZlclxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlckZyb21UeXBlZEFycmF5KGdsLCB0eXBlZEFycmF5LCB0eXBlLCBkcmF3VHlwZSkge1xuICBpZiAoaGVscGVyLmlzQnVmZmVyKGdsLCB0eXBlZEFycmF5KSkge1xuICAgIHJldHVybiB0eXBlZEFycmF5O1xuICB9XG5cbiAgdHlwZSA9IHR5cGUgfHwgZ2wuQVJSQVlfQlVGRkVSO1xuICB2YXIgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gIHNldEJ1ZmZlckZyb21UeXBlZEFycmF5KGdsLCB0eXBlLCBidWZmZXIsIHR5cGVkQXJyYXksIGRyYXdUeXBlKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gaXNJbmRpY2VzKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgPT09IFwiaW5kaWNlc1wiO1xufSAvLyBUaGlzIGlzIHJlYWxseSBqdXN0IGEgZ3Vlc3MuIFRob3VnaCBJIGNhbid0IHJlYWxseSBpbWFnaW5lIHVzaW5nXG4vLyBhbnl0aGluZyBlbHNlPyBNYXliZSBmb3Igc29tZSBjb21wcmVzc2lvbj9cblxuXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uRm9yVHlwZWRBcnJheSh0eXBlZEFycmF5KSB7XG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBUaGlzIGlzIHJlYWxseSBqdXN0IGEgZ3Vlc3MuIFRob3VnaCBJIGNhbid0IHJlYWxseSBpbWFnaW5lIHVzaW5nXG4vLyBhbnl0aGluZyBlbHNlPyBNYXliZSBmb3Igc29tZSBjb21wcmVzc2lvbj9cblxuXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uRm9yVHlwZWRBcnJheVR5cGUodHlwZWRBcnJheVR5cGUpIHtcbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBJbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5KGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5sZW5ndGggPyBhcnJheSA6IGFycmF5LmRhdGE7XG59XG5cbnZhciB0ZXhjb29yZFJFID0gL2Nvb3JkfHRleHR1cmUvaTtcbnZhciBjb2xvclJFID0gL2NvbG9yfGNvbG91ci9pO1xuXG5mdW5jdGlvbiBndWVzc051bUNvbXBvbmVudHNGcm9tTmFtZShuYW1lLCBsZW5ndGgpIHtcbiAgdmFyIG51bUNvbXBvbmVudHM7XG5cbiAgaWYgKHRleGNvb3JkUkUudGVzdChuYW1lKSkge1xuICAgIG51bUNvbXBvbmVudHMgPSAyO1xuICB9IGVsc2UgaWYgKGNvbG9yUkUudGVzdChuYW1lKSkge1xuICAgIG51bUNvbXBvbmVudHMgPSA0O1xuICB9IGVsc2Uge1xuICAgIG51bUNvbXBvbmVudHMgPSAzOyAvLyBwb3NpdGlvbiwgbm9ybWFscywgaW5kaWNlcyAuLi5cbiAgfVxuXG4gIGlmIChsZW5ndGggJSBudW1Db21wb25lbnRzID4gMCkge1xuICAgIHRocm93IFwiQ2FuIG5vdCBndWVzcyBudW1Db21wb25lbnRzIGZvciBhdHRyaWJ1dGUgJ1wiICsgbmFtZSArIFwiJy4gVHJpZWQgXCIgKyBudW1Db21wb25lbnRzICsgXCIgYnV0IFwiICsgbGVuZ3RoICsgXCIgdmFsdWVzIGlzIG5vdCBldmVubHkgZGl2aXNpYmxlIGJ5IFwiICsgbnVtQ29tcG9uZW50cyArIFwiLiBZb3Ugc2hvdWxkIHNwZWNpZnkgaXQuXCI7XG4gIH1cblxuICByZXR1cm4gbnVtQ29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gZ2V0TnVtQ29tcG9uZW50cyhhcnJheSwgYXJyYXlOYW1lKSB7XG4gIHJldHVybiBhcnJheS5udW1Db21wb25lbnRzIHx8IGFycmF5LnNpemUgfHwgZ3Vlc3NOdW1Db21wb25lbnRzRnJvbU5hbWUoYXJyYXlOYW1lLCBnZXRBcnJheShhcnJheSkubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gbWFrZVR5cGVkQXJyYXkoYXJyYXksIG5hbWUpIHtcbiAgaWYgKHR5cGVkQXJyYXlzLmlzQXJyYXlCdWZmZXIoYXJyYXkpKSB7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgaWYgKHR5cGVkQXJyYXlzLmlzQXJyYXlCdWZmZXIoYXJyYXkuZGF0YSkpIHtcbiAgICByZXR1cm4gYXJyYXkuZGF0YTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgIGFycmF5ID0ge1xuICAgICAgZGF0YTogYXJyYXlcbiAgICB9O1xuICB9XG5cbiAgdmFyIFR5cGUgPSBhcnJheS50eXBlO1xuXG4gIGlmICghVHlwZSkge1xuICAgIGlmIChpc0luZGljZXMobmFtZSkpIHtcbiAgICAgIFR5cGUgPSBVaW50MTZBcnJheTtcbiAgICB9IGVsc2Uge1xuICAgICAgVHlwZSA9IEZsb2F0MzJBcnJheTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFR5cGUoYXJyYXkuZGF0YSk7XG59XG4vKipcbiAqIFRoZSBpbmZvIGZvciBhbiBhdHRyaWJ1dGUuIFRoaXMgaXMgZWZmZWN0aXZlbHkganVzdCB0aGUgYXJndW1lbnRzIHRvIGBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyYCBwbHVzIHRoZSBXZWJHTEJ1ZmZlclxuICogZm9yIHRoZSBhdHRyaWJ1dGUuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQXR0cmliSW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtudW1Db21wb25lbnRzXSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgZm9yIHRoaXMgYXR0cmlidXRlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplXSBzeW5vbnltIGZvciBgbnVtQ29tcG9uZW50c2AuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3R5cGVdIHRoZSB0eXBlIG9mIHRoZSBhdHRyaWJ1dGUgKGVnLiBgZ2wuRkxPQVRgLCBgZ2wuVU5TSUdORURfQllURWAsIGV0Yy4uLikgRGVmYXVsdCA9IGBnbC5GTE9BVGBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW25vcm1hbGl6ZV0gd2hldGhlciBvciBub3QgdG8gbm9ybWFsaXplIHRoZSBkYXRhLiBEZWZhdWx0ID0gZmFsc2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb2Zmc2V0XSBvZmZzZXQgaW50byBidWZmZXIgaW4gYnl0ZXMuIERlZmF1bHQgPSAwXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0cmlkZV0gdGhlIHN0cmlkZSBpbiBieXRlcyBwZXIgZWxlbWVudC4gRGVmYXVsdCA9IDBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGl2aXNvcl0gdGhlIGRpdmlzb3IgaW4gaW5zdGFuY2VzLiBEZWZhdWx0ID0gdW5kZWZpbmVkLiBOb3RlOiB1bmRlZmluZWQgPSBkb24ndCBjYWxsIGdsLnZlcnRleEF0dHJpYkRpdmlzb3JcbiAqICAgIHdoZXJlIGFzIGFueXRoaW5nIGVsc2UgPSBkbyBjYWxsIGl0IHdpdGggdGhpcyB2YWx1ZVxuICogQHByb3BlcnR5IHtXZWJHTEJ1ZmZlcn0gYnVmZmVyIHRoZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgZGF0YSBmb3IgdGhpcyBhdHRyaWJ1dGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHJhd1R5cGVdIHRoZSBkcmF3IHR5cGUgcGFzc2VkIHRvIGdsLmJ1ZmZlckRhdGEuIERlZmF1bHQgPSBnbC5TVEFUSUNfRFJBV1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBVc2UgdGhpcyB0eXBlIG9mIGFycmF5IHNwZWMgd2hlbiBUV0dMIGNhbid0IGd1ZXNzIHRoZSB0eXBlIG9yIG51bWJlciBvZiBjb21wb21lbnRzIG9mIGFuIGFycmF5XG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGdWxsQXJyYXlTcGVjXG4gKiBAcHJvcGVydHkgeyhudW1iZXJ8bnVtYmVyW118QXJyYXlCdWZmZXJWaWV3KX0gZGF0YSBUaGUgZGF0YSBvZiB0aGUgYXJyYXkuIEEgbnVtYmVyIGFsb25lIGJlY29tZXMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiB0eXBlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtudW1Db21wb25lbnRzXSBudW1iZXIgb2YgY29tcG9uZW50cyBmb3IgYHZlcnRleEF0dHJpYlBvaW50ZXJgLiBEZWZhdWx0IGlzIGJhc2VkIG9uIHRoZSBuYW1lIG9mIHRoZSBhcnJheS5cbiAqICAgIElmIGBjb29yZGAgaXMgaW4gdGhlIG5hbWUgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDJgLlxuICogICAgSWYgYGNvbG9yYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gNGAuXG4gKiAgICBvdGhlcndpc2UgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDNgXG4gKiBAcHJvcGVydHkge2NvbnN0cnVjdG9yfSB0eXBlIFRoZSB0eXBlLiBUaGlzIGlzIG9ubHkgdXNlZCBpZiBgZGF0YWAgaXMgYSBKYXZhU2NyaXB0IGFycmF5LiBJdCBpcyB0aGUgY29uc3RydWN0b3IgZm9yIHRoZSB0eXBlZGFycmF5LiAoZWcuIGBVaW50OEFycmF5YCkuXG4gKiBGb3IgZXhhbXBsZSBpZiB5b3Ugd2FudCBjb2xvcnMgaW4gYSBgVWludDhBcnJheWAgeW91IG1pZ2h0IGhhdmUgYSBgRnVsbEFycmF5U3BlY2AgbGlrZSBgeyB0eXBlOiBVaW50OEFycmF5LCBkYXRhOiBbMjU1LDAsMjU1LDI1NSwgLi4uXSwgfWAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3NpemVdIHN5bm9ueW0gZm9yIGBudW1Db21wb25lbnRzYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW25vcm1hbGl6ZV0gbm9ybWFsaXplIGZvciBgdmVydGV4QXR0cmliUG9pbnRlcmAuIERlZmF1bHQgaXMgdHJ1ZSBpZiB0eXBlIGlzIGBJbnQ4QXJyYXlgIG9yIGBVaW50OEFycmF5YCBvdGhlcndpc2UgZmFsc2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0cmlkZV0gc3RyaWRlIGZvciBgdmVydGV4QXR0cmliUG9pbnRlcmAuIERlZmF1bHQgPSAwXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29mZnNldF0gb2Zmc2V0IGZvciBgdmVydGV4QXR0cmliUG9pbnRlcmAuIERlZmF1bHQgPSAwXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2Rpdmlzb3JdIGRpdmlzb3IgZm9yIGB2ZXJ0ZXhBdHRyaWJEaXZpc29yYC4gRGVmYXVsdCA9IHVuZGVmaW5lZC4gTm90ZTogdW5kZWZpbmVkID0gZG9uJ3QgY2FsbCBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yXG4gKiAgICB3aGVyZSBhcyBhbnl0aGluZyBlbHNlID0gZG8gY2FsbCBpdCB3aXRoIHRoaXMgdmFsdWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXR0cmliXSBuYW1lIG9mIGF0dHJpYnV0ZSB0aGlzIGFycmF5IG1hcHMgdG8uIERlZmF1bHRzIHRvIHNhbWUgbmFtZSBhcyBhcnJheSBwcmVmaXhlZCBieSB0aGUgZGVmYXVsdCBhdHRyaWJQcmVmaXguXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIHN5bm9ueW0gZm9yIGBhdHRyaWJgLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthdHRyaWJOYW1lXSBzeW5vbnltIGZvciBgYXR0cmliYC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQW4gaW5kaXZpZHVhbCBhcnJheSBpbiB7QGxpbmsgbW9kdWxlOnR3Z2wuQXJyYXlzfVxuICpcbiAqIFdoZW4gcGFzc2VkIHRvIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5c30gaWYgYW4gQXJyYXlTcGVjIGlzIGBudW1iZXJbXWAgb3IgYEFycmF5QnVmZmVyVmlld2BcbiAqIHRoZSB0eXBlcyB3aWxsIGJlIGd1ZXNzZWQgYmFzZWQgb24gdGhlIG5hbWUuIGBpbmRpY2VzYCB3aWxsIGJlIGBVaW50MTZBcnJheWAsIGV2ZXJ5dGhpbmcgZWxzZSB3aWxsXG4gKiBiZSBgRmxvYXQzMkFycmF5YC4gSWYgYW4gQXJyYXlTcGVjIGlzIGEgbnVtYmVyIGl0J3MgdGhlIG51bWJlciBvZiBmbG9hdHMgZm9yIGFuIGVtcHR5ICh6ZXJvZWQpIGJ1ZmZlci5cbiAqXG4gKiBAdHlwZWRlZiB7KG51bWJlcnxudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd8bW9kdWxlOnR3Z2wuRnVsbEFycmF5U3BlYyl9IEFycmF5U3BlY1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgSmF2YVNjcmlwdCBvYmplY3Qgb2YgYXJyYXlzIGJ5IG5hbWUuIFRoZSBuYW1lcyBzaG91bGQgbWF0Y2ggeW91ciBzaGFkZXIncyBhdHRyaWJ1dGVzLiBJZiB5b3VyXG4gKiBhdHRyaWJ1dGVzIGhhdmUgYSBjb21tb24gcHJlZml4IHlvdSBjYW4gc3BlY2lmeSBpdCBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6dHdnbC5zZXRBdHRyaWJ1dGVQcmVmaXh9LlxuICpcbiAqICAgICBCYXJlIEphdmFTY3JpcHQgQXJyYXlzXG4gKlxuICogICAgICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgICAgICBwb3NpdGlvbjogWy0xLCAxLCAwXSxcbiAqICAgICAgICAgICAgbm9ybWFsOiBbMCwgMSwgMF0sXG4gKiAgICAgICAgICAgIC4uLlxuICogICAgICAgICB9XG4gKlxuICogICAgIEJhcmUgVHlwZWRBcnJheXNcbiAqXG4gKiAgICAgICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFstMSwgMSwgMF0pLFxuICogICAgICAgICAgICBjb2xvcjogbmV3IFVpbnQ4QXJyYXkoWzI1NSwgMTI4LCA2NCwgMjU1XSksXG4gKiAgICAgICAgICAgIC4uLlxuICogICAgICAgICB9XG4gKlxuICogKiAgIFdpbGwgZ3Vlc3MgYXQgYG51bUNvbXBvbmVudHNgIGlmIG5vdCBzcGVjaWZpZWQgYmFzZWQgb24gbmFtZS5cbiAqXG4gKiAgICAgSWYgYGNvb3JkYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gMmBcbiAqXG4gKiAgICAgSWYgYGNvbG9yYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gNGBcbiAqXG4gKiAgICAgb3RoZXJ3aXNlIGFzc3VtZXMgYG51bUNvbXBvbmVudHMgPSAzYFxuICpcbiAqIE9iamVjdHMgd2l0aCB2YXJpb3VzIGZpZWxkcy4gU2VlIHtAbGluayBtb2R1bGU6dHdnbC5GdWxsQXJyYXlTcGVjfS5cbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgIHBvc2l0aW9uOiB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAwLCAwLCAxMCwgMCwgMCwgMCwgMTAsIDAsIDEwLCAxMCwgMF0sIH0sXG4gKiAgICAgICB0ZXhjb29yZDogeyBudW1Db21wb25lbnRzOiAyLCBkYXRhOiBbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0sICAgICAgICAgICAgICAgICB9LFxuICogICAgICAgbm9ybWFsOiAgIHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdLCAgICAgfSxcbiAqICAgICAgIGluZGljZXM6ICB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAxLCAyLCAxLCAyLCAzXSwgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgfTtcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkFycmF5U3BlYz59IEFycmF5c1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9mIGF0dHJpYnV0ZSBkYXRhIGFuZCBXZWJHTEJ1ZmZlcnMgZnJvbSBzZXQgb2YgYXJyYXlzXG4gKlxuICogR2l2ZW5cbiAqXG4gKiAgICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgcG9zaXRpb246IHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDAsIDAsIDEwLCAwLCAwLCAwLCAxMCwgMCwgMTAsIDEwLCAwXSwgfSxcbiAqICAgICAgICB0ZXhjb29yZDogeyBudW1Db21wb25lbnRzOiAyLCBkYXRhOiBbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0sICAgICAgICAgICAgICAgICB9LFxuICogICAgICAgIG5vcm1hbDogICB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSwgICAgIH0sXG4gKiAgICAgICAgY29sb3I6ICAgIHsgbnVtQ29tcG9uZW50czogNCwgZGF0YTogWzI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAwLCAwLCAyNTUsIDAsIDAsIDI1NSwgMjU1XSwgdHlwZTogVWludDhBcnJheSwgfSxcbiAqICAgICAgICBpbmRpY2VzOiAgeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMSwgMiwgMSwgMiwgM10sICAgICAgICAgICAgICAgICAgICAgICB9LFxuICogICAgICB9O1xuICpcbiAqIHJldHVybnMgc29tZXRoaW5nIGxpa2VcbiAqXG4gKiAgICAgIHZhciBhdHRyaWJzID0ge1xuICogICAgICAgIHBvc2l0aW9uOiB7IG51bUNvbXBvbmVudHM6IDMsIHR5cGU6IGdsLkZMT0FULCAgICAgICAgIG5vcm1hbGl6ZTogZmFsc2UsIGJ1ZmZlcjogV2ViR0xCdWZmZXIsIH0sXG4gKiAgICAgICAgdGV4Y29vcmQ6IHsgbnVtQ29tcG9uZW50czogMiwgdHlwZTogZ2wuRkxPQVQsICAgICAgICAgbm9ybWFsaXplOiBmYWxzZSwgYnVmZmVyOiBXZWJHTEJ1ZmZlciwgfSxcbiAqICAgICAgICBub3JtYWw6ICAgeyBudW1Db21wb25lbnRzOiAzLCB0eXBlOiBnbC5GTE9BVCwgICAgICAgICBub3JtYWxpemU6IGZhbHNlLCBidWZmZXI6IFdlYkdMQnVmZmVyLCB9LFxuICogICAgICAgIGNvbG9yOiAgICB7IG51bUNvbXBvbmVudHM6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIG5vcm1hbGl6ZTogdHJ1ZSwgIGJ1ZmZlcjogV2ViR0xCdWZmZXIsIH0sXG4gKiAgICAgIH07XG4gKlxuICogbm90ZXM6XG4gKlxuICogKiAgIEFycmF5cyBjYW4gdGFrZSB2YXJpb3VzIGZvcm1zXG4gKlxuICogICAgIEJhcmUgSmF2YVNjcmlwdCBBcnJheXNcbiAqXG4gKiAgICAgICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgICAgIHBvc2l0aW9uOiBbLTEsIDEsIDBdLFxuICogICAgICAgICAgICBub3JtYWw6IFswLCAxLCAwXSxcbiAqICAgICAgICAgICAgLi4uXG4gKiAgICAgICAgIH1cbiAqXG4gKiAgICAgQmFyZSBUeXBlZEFycmF5c1xuICpcbiAqICAgICAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICAgICAgcG9zaXRpb246IG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAxLCAwXSksXG4gKiAgICAgICAgICAgIGNvbG9yOiBuZXcgVWludDhBcnJheShbMjU1LCAxMjgsIDY0LCAyNTVdKSxcbiAqICAgICAgICAgICAgLi4uXG4gKiAgICAgICAgIH1cbiAqXG4gKiAqICAgV2lsbCBndWVzcyBhdCBgbnVtQ29tcG9uZW50c2AgaWYgbm90IHNwZWNpZmllZCBiYXNlZCBvbiBuYW1lLlxuICpcbiAqICAgICBJZiBgY29vcmRgIGlzIGluIHRoZSBuYW1lIGFzc3VtZXMgYG51bUNvbXBvbmVudHMgPSAyYFxuICpcbiAqICAgICBJZiBgY29sb3JgIGlzIGluIHRoZSBuYW1lIGFzc3VtZXMgYG51bUNvbXBvbmVudHMgPSA0YFxuICpcbiAqICAgICBvdGhlcndpc2UgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDNgXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSB3ZWJnbCByZW5kZXJpbmcgY29udGV4dC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQXJyYXlzfSBhcnJheXMgVGhlIGFycmF5c1xuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+fSB0aGUgYXR0cmlic1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnNGcm9tQXJyYXlzKGdsLCBhcnJheXMpIHtcbiAgdmFyIGF0dHJpYnMgPSB7fTtcbiAgT2JqZWN0LmtleXMoYXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChhcnJheU5hbWUpIHtcbiAgICBpZiAoIWlzSW5kaWNlcyhhcnJheU5hbWUpKSB7XG4gICAgICB2YXIgYXJyYXkgPSBhcnJheXNbYXJyYXlOYW1lXTtcbiAgICAgIHZhciBhdHRyaWJOYW1lID0gYXJyYXkuYXR0cmliIHx8IGFycmF5Lm5hbWUgfHwgYXJyYXkuYXR0cmliTmFtZSB8fCBkZWZhdWx0cy5hdHRyaWJQcmVmaXggKyBhcnJheU5hbWU7XG4gICAgICB2YXIgYnVmZmVyO1xuICAgICAgdmFyIHR5cGU7XG4gICAgICB2YXIgbm9ybWFsaXphdGlvbjtcbiAgICAgIHZhciBudW1Db21wb25lbnRzO1xuICAgICAgdmFyIG51bVZhbHVlcztcblxuICAgICAgaWYgKHR5cGVvZiBhcnJheSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgYXJyYXkuZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBudW1WYWx1ZXMgPSBhcnJheS5kYXRhIHx8IGFycmF5O1xuICAgICAgICB2YXIgYXJyYXlUeXBlID0gYXJyYXkudHlwZSB8fCBGbG9hdDMyQXJyYXk7XG4gICAgICAgIHZhciBudW1CeXRlcyA9IG51bVZhbHVlcyAqIGFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgdHlwZSA9IHR5cGVkQXJyYXlzLmdldEdMVHlwZUZvclR5cGVkQXJyYXlUeXBlKGFycmF5VHlwZSk7XG4gICAgICAgIG5vcm1hbGl6YXRpb24gPSBhcnJheS5ub3JtYWxpemUgIT09IHVuZGVmaW5lZCA/IGFycmF5Lm5vcm1hbGl6ZSA6IGdldE5vcm1hbGl6YXRpb25Gb3JUeXBlZEFycmF5VHlwZShhcnJheVR5cGUpO1xuICAgICAgICBudW1Db21wb25lbnRzID0gYXJyYXkubnVtQ29tcG9uZW50cyB8fCBhcnJheS5zaXplIHx8IGd1ZXNzTnVtQ29tcG9uZW50c0Zyb21OYW1lKGFycmF5TmFtZSwgbnVtVmFsdWVzKTtcbiAgICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbnVtQnl0ZXMsIGFycmF5LmRyYXdUeXBlIHx8IGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0eXBlZEFycmF5ID0gbWFrZVR5cGVkQXJyYXkoYXJyYXksIGFycmF5TmFtZSk7XG4gICAgICAgIGJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlckZyb21UeXBlZEFycmF5KGdsLCB0eXBlZEFycmF5LCB1bmRlZmluZWQsIGFycmF5LmRyYXdUeXBlKTtcbiAgICAgICAgdHlwZSA9IHR5cGVkQXJyYXlzLmdldEdMVHlwZUZvclR5cGVkQXJyYXkodHlwZWRBcnJheSk7XG4gICAgICAgIG5vcm1hbGl6YXRpb24gPSBhcnJheS5ub3JtYWxpemUgIT09IHVuZGVmaW5lZCA/IGFycmF5Lm5vcm1hbGl6ZSA6IGdldE5vcm1hbGl6YXRpb25Gb3JUeXBlZEFycmF5KHR5cGVkQXJyYXkpO1xuICAgICAgICBudW1Db21wb25lbnRzID0gZ2V0TnVtQ29tcG9uZW50cyhhcnJheSwgYXJyYXlOYW1lKTtcbiAgICAgICAgbnVtVmFsdWVzID0gdHlwZWRBcnJheS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGF0dHJpYnNbYXR0cmliTmFtZV0gPSB7XG4gICAgICAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgICAgICBudW1Db21wb25lbnRzOiBudW1Db21wb25lbnRzLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBub3JtYWxpemU6IG5vcm1hbGl6YXRpb24sXG4gICAgICAgIHN0cmlkZTogYXJyYXkuc3RyaWRlIHx8IDAsXG4gICAgICAgIG9mZnNldDogYXJyYXkub2Zmc2V0IHx8IDAsXG4gICAgICAgIGRpdmlzb3I6IGFycmF5LmRpdmlzb3IgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGFycmF5LmRpdmlzb3IsXG4gICAgICAgIGRyYXdUeXBlOiBhcnJheS5kcmF3VHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gIHJldHVybiBhdHRyaWJzO1xufVxuLyoqXG4gKiBTZXRzIHRoZSBjb250ZW50cyBvZiBhIGJ1ZmZlciBhdHRhY2hlZCB0byBhbiBhdHRyaWJJbmZvXG4gKlxuICogVGhpcyBpcyBoZWxwZXIgZnVuY3Rpb24gdG8gZHluYW1pY2FsbHkgdXBkYXRlIGEgYnVmZmVyLlxuICpcbiAqIExldCdzIHNheSB5b3UgbWFrZSBhIGJ1ZmZlckluZm9cbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICBwb3NpdGlvbjogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdKSxcbiAqICAgICAgICB0ZXhjb29yZDogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0pLFxuICogICAgICAgIG5vcm1hbDogICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSksXG4gKiAgICAgICAgaW5kaWNlczogIG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMSwgMiwgM10pLFxuICogICAgIH07XG4gKiAgICAgdmFyIGJ1ZmZlckluZm8gPSB0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCBhcnJheXMpO1xuICpcbiAqICBBbmQgeW91IHdhbnQgdG8gZHluYW1pY2FsbHkgdXBhdGUgdGhlIHBvc2l0aW9ucy4gWW91IGNvdWxkIGRvIHRoaXNcbiAqXG4gKiAgICAgLy8gYXNzdW1pbmcgYXJyYXlzLnBvc2l0aW9uIGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZCB3aXRoIG5ldyBkYXRhLlxuICogICAgIHR3Z2wuc2V0QXR0cmliSW5mb0J1ZmZlckZyb21BcnJheShnbCwgYnVmZmVySW5mby5hdHRyaWJzLnBvc2l0aW9uLCBhcnJheXMucG9zaXRpb24pO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICogQHBhcmFtIHtBdHRyaWJJbmZvfSBhdHRyaWJJbmZvIFRoZSBhdHRyaWJJbmZvIHdobydzIGJ1ZmZlciBjb250ZW50cyB0byBzZXQuIE5PVEU6IElmIHlvdSBoYXZlIGFuIGF0dHJpYnV0ZSBwcmVmaXhcbiAqICAgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB3aWxsIGluY2x1ZGUgdGhlIHByZWZpeC5cbiAqIEBwYXJhbSB7QXJyYXlTcGVjfSBhcnJheSBOb3RlOiBpdCBpcyBhcmd1YWJseSBpbmVmZmllbnQgdG8gcGFzcyBpbiBhbnl0aGluZyBidXQgYSB0eXBlZCBhcnJheSBiZWNhdXNlIGFueXRoaW5nXG4gKiAgICBlbHNlIHdpbGwgaGF2ZSB0byBiZSBjb252ZXJ0ZWQgdG8gYSB0eXBlZCBhcnJheSBiZWZvcmUgaXQgY2FuIGJlIHVzZWQgYnkgV2ViR0wuIER1cmluZyBpbml0IHRpbWUgdGhhdFxuICogICAgaW5lZmZpY2llbmN5IGlzIHVzdWFsbHkgbm90IGltcG9ydGFudCBidXQgaWYgeW91J3JlIHVwZGF0aW5nIGRhdGEgZHluYW1pY2FsbHkgYmVzdCB0byBiZSBlZmZpY2llbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29mZnNldF0gYW4gb3B0aW9uYWwgb2Zmc2V0IGludG8gdGhlIGJ1ZmZlci4gVGhpcyBpcyBvbmx5IGFuIG9mZnNldCBpbnRvIHRoZSBXZWJHTCBidWZmZXJcbiAqICAgIG5vdCB0aGUgYXJyYXkuIFRvIHBhc3MgaW4gYW4gb2Zmc2V0IGludG8gdGhlIGFycmF5IGl0c2VsZiB1c2UgYSB0eXBlZCBhcnJheSBhbmQgY3JlYXRlIGFuIGBBcnJheUJ1ZmZlclZpZXdgXG4gKiAgICBmb3IgdGhlIHBvcnRpb24gb2YgdGhlIGFycmF5IHlvdSB3YW50IHRvIHVzZS5cbiAqXG4gKiAgICAgICAgdmFyIHNvbWVBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMTAwMCk7IC8vIGFuIGFycmF5IHdpdGggMTAwMCBmbG9hdHNcbiAqICAgICAgICB2YXIgc29tZVN1YkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShzb21lQXJyYXkuYnVmZmVyLCBvZmZzZXRJbkJ5dGVzLCBzaXplSW5Vbml0cyk7IC8vIGEgdmlldyBpbnRvIHNvbWVBcnJheVxuICpcbiAqICAgIE5vdyB5b3UgY2FuIHBhc3MgYHNvbWVTdWJBcnJheWAgaW50byBzZXRBdHRyaWJJbmZvQnVmZmVyRnJvbUFycmF5YFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXkoZ2wsIGF0dHJpYkluZm8sIGFycmF5LCBvZmZzZXQpIHtcbiAgYXJyYXkgPSBtYWtlVHlwZWRBcnJheShhcnJheSk7XG5cbiAgaWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGF0dHJpYkluZm8uYnVmZmVyKTtcbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgb2Zmc2V0LCBhcnJheSk7XG4gIH0gZWxzZSB7XG4gICAgc2V0QnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgYXR0cmliSW5mby5idWZmZXIsIGFycmF5LCBhdHRyaWJJbmZvLmRyYXdUeXBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCeXRlc1BlclZhbHVlRm9yR0xUeXBlKGdsLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSBnbC5CWVRFKSByZXR1cm4gMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlID09PSBnbC5VTlNJR05FRF9CWVRFKSByZXR1cm4gMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlID09PSBnbC5TSE9SVCkgcmV0dXJuIDI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlQpIHJldHVybiAyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKHR5cGUgPT09IGdsLklOVCkgcmV0dXJuIDQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZSA9PT0gZ2wuVU5TSUdORURfSU5UKSByZXR1cm4gNDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlID09PSBnbC5GTE9BVCkgcmV0dXJuIDQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICByZXR1cm4gMDtcbn1cbi8qKlxuICogdHJpZXMgdG8gZ2V0IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBhcnJheXMuXG4gKi9cblxuXG52YXIgcG9zaXRpb25LZXlzID0gWydwb3NpdGlvbicsICdwb3NpdGlvbnMnLCAnYV9wb3NpdGlvbiddO1xuXG5mdW5jdGlvbiBnZXROdW1FbGVtZW50c0Zyb21Ob25JbmRleGVkQXJyYXlzKGFycmF5cykge1xuICB2YXIga2V5O1xuXG4gIGZvciAodmFyIF9paSA9IDA7IF9paSA8IHBvc2l0aW9uS2V5cy5sZW5ndGg7ICsrX2lpKSB7XG4gICAga2V5ID0gcG9zaXRpb25LZXlzW19paV07XG5cbiAgICBpZiAoa2V5IGluIGFycmF5cykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlpID09PSBwb3NpdGlvbktleXMubGVuZ3RoKSB7XG4gICAga2V5ID0gT2JqZWN0LmtleXMoYXJyYXlzKVswXTtcbiAgfVxuXG4gIHZhciBhcnJheSA9IGFycmF5c1trZXldO1xuICB2YXIgbGVuZ3RoID0gZ2V0QXJyYXkoYXJyYXkpLmxlbmd0aDtcbiAgdmFyIG51bUNvbXBvbmVudHMgPSBnZXROdW1Db21wb25lbnRzKGFycmF5LCBrZXkpO1xuICB2YXIgbnVtRWxlbWVudHMgPSBsZW5ndGggLyBudW1Db21wb25lbnRzO1xuXG4gIGlmIChsZW5ndGggJSBudW1Db21wb25lbnRzID4gMCkge1xuICAgIHRocm93IFwibnVtQ29tcG9uZW50cyBcIiArIG51bUNvbXBvbmVudHMgKyBcIiBub3QgY29ycmVjdCBmb3IgbGVuZ3RoIFwiICsgbGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG51bUVsZW1lbnRzO1xufVxuXG5mdW5jdGlvbiBnZXROdW1FbGVtZW50c0Zyb21BdHRyaWJ1dGVzKGdsLCBhdHRyaWJzKSB7XG4gIHZhciBrZXk7XG4gIHZhciBpaTtcblxuICBmb3IgKGlpID0gMDsgaWkgPCBwb3NpdGlvbktleXMubGVuZ3RoOyArK2lpKSB7XG4gICAga2V5ID0gcG9zaXRpb25LZXlzW2lpXTtcblxuICAgIGlmIChrZXkgaW4gYXR0cmlicykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAga2V5ID0gZGVmYXVsdHMuYXR0cmliUHJlZml4ICsga2V5O1xuXG4gICAgaWYgKGtleSBpbiBhdHRyaWJzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaWkgPT09IHBvc2l0aW9uS2V5cy5sZW5ndGgpIHtcbiAgICBrZXkgPSBPYmplY3Qua2V5cyhhdHRyaWJzKVswXTtcbiAgfVxuXG4gIHZhciBhdHRyaWIgPSBhdHRyaWJzW2tleV07XG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhdHRyaWIuYnVmZmVyKTtcbiAgdmFyIG51bUJ5dGVzID0gZ2wuZ2V0QnVmZmVyUGFyYW1ldGVyKGdsLkFSUkFZX0JVRkZFUiwgZ2wuQlVGRkVSX1NJWkUpO1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gIHZhciBieXRlc1BlclZhbHVlID0gZ2V0Qnl0ZXNQZXJWYWx1ZUZvckdMVHlwZShnbCwgYXR0cmliLnR5cGUpO1xuICB2YXIgdG90YWxFbGVtZW50cyA9IG51bUJ5dGVzIC8gYnl0ZXNQZXJWYWx1ZTtcbiAgdmFyIG51bUNvbXBvbmVudHMgPSBhdHRyaWIubnVtQ29tcG9uZW50cyB8fCBhdHRyaWIuc2l6ZTsgLy8gVE9ETzogY2hlY2sgc3RyaWRlXG5cbiAgdmFyIG51bUVsZW1lbnRzID0gdG90YWxFbGVtZW50cyAvIG51bUNvbXBvbmVudHM7XG5cbiAgaWYgKG51bUVsZW1lbnRzICUgMSAhPT0gMCkge1xuICAgIHRocm93IFwibnVtQ29tcG9uZW50cyBcIiArIG51bUNvbXBvbmVudHMgKyBcIiBub3QgY29ycmVjdCBmb3IgbGVuZ3RoIFwiICsgbGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG51bUVsZW1lbnRzO1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCdWZmZXJJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gbnVtRWxlbWVudHMgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBwYXNzIHRvIGBnbC5kcmF3QXJyYXlzYCBvciBgZ2wuZHJhd0VsZW1lbnRzYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZWxlbWVudFR5cGVdIFRoZSB0eXBlIG9mIGluZGljZXMgYFVOU0lHTkVEX0JZVEVgLCBgVU5TSUdORURfU0hPUlRgIGV0Yy4uXG4gKiBAcHJvcGVydHkge1dlYkdMQnVmZmVyfSBbaW5kaWNlc10gVGhlIGluZGljZXMgYEVMRU1FTlRfQVJSQVlfQlVGRkVSYCBpZiBhbnkgaW5kaWNlcyBleGlzdC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+fSBbYXR0cmlic10gVGhlIGF0dHJpYnMgYXBwcm9yaWF0ZSB0byBjYWxsIGBzZXRBdHRyaWJ1dGVzYFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgQnVmZmVySW5mbyBmcm9tIGFuIG9iamVjdCBvZiBhcnJheXMuXG4gKlxuICogVGhpcyBjYW4gYmUgcGFzc2VkIHRvIHtAbGluayBtb2R1bGU6dHdnbC5zZXRCdWZmZXJzQW5kQXR0cmlidXRlc30gYW5kIHRvXG4gKiB7QGxpbmsgbW9kdWxlOnR3Z2w6ZHJhd0J1ZmZlckluZm99LlxuICpcbiAqIEdpdmVuIGFuIG9iamVjdCBsaWtlXG4gKlxuICogICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICBwb3NpdGlvbjogeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdLCB9LFxuICogICAgICAgdGV4Y29vcmQ6IHsgbnVtQ29tcG9uZW50czogMiwgZGF0YTogWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdLCAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgIG5vcm1hbDogICB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSwgICAgIH0sXG4gKiAgICAgICBpbmRpY2VzOiAgeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMSwgMiwgMSwgMiwgM10sICAgICAgICAgICAgICAgICAgICAgICB9LFxuICogICAgIH07XG4gKlxuICogIENyZWF0ZXMgYW4gQnVmZmVySW5mbyBsaWtlIHRoaXNcbiAqXG4gKiAgICAgYnVmZmVySW5mbyA9IHtcbiAqICAgICAgIG51bUVsZW1lbnRzOiA0LCAgICAgICAgLy8gb3Igd2hhdGV2ZXIgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpc1xuICogICAgICAgaW5kaWNlczogV2ViR0xCdWZmZXIsICAvLyB0aGlzIHByb3BlcnR5IHdpbGwgbm90IGV4aXN0IGlmIHRoZXJlIGFyZSBubyBpbmRpY2VzXG4gKiAgICAgICBhdHRyaWJzOiB7XG4gKiAgICAgICAgIGFfcG9zaXRpb246IHsgYnVmZmVyOiBXZWJHTEJ1ZmZlciwgbnVtQ29tcG9uZW50czogMywgfSxcbiAqICAgICAgICAgYV9ub3JtYWw6ICAgeyBidWZmZXI6IFdlYkdMQnVmZmVyLCBudW1Db21wb25lbnRzOiAzLCB9LFxuICogICAgICAgICBhX3RleGNvb3JkOiB7IGJ1ZmZlcjogV2ViR0xCdWZmZXIsIG51bUNvbXBvbmVudHM6IDIsIH0sXG4gKiAgICAgICB9LFxuICogICAgIH07XG4gKlxuICogIFRoZSBwcm9wZXJ0aWVzIG9mIGFycmF5cyBjYW4gYmUgSmF2YVNjcmlwdCBhcnJheXMgaW4gd2hpY2ggY2FzZSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHNcbiAqICB3aWxsIGJlIGd1ZXNzZWQuXG4gKlxuICogICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgcG9zaXRpb246IFswLCAwLCAwLCAxMCwgMCwgMCwgMCwgMTAsIDAsIDEwLCAxMCwgMF0sXG4gKiAgICAgICAgdGV4Y29vcmQ6IFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSxcbiAqICAgICAgICBub3JtYWw6ICAgWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdLFxuICogICAgICAgIGluZGljZXM6ICBbMCwgMSwgMiwgMSwgMiwgM10sXG4gKiAgICAgfTtcbiAqXG4gKiAgVGhleSBjYW4gYWxzbyBieSBUeXBlZEFycmF5c1xuICpcbiAqICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgIHBvc2l0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxMCwgMCwgMCwgMCwgMTAsIDAsIDEwLCAxMCwgMF0pLFxuICogICAgICAgIHRleGNvb3JkOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSksXG4gKiAgICAgICAgbm9ybWFsOiAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdKSxcbiAqICAgICAgICBpbmRpY2VzOiAgbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAxLCAyLCAzXSksXG4gKiAgICAgfTtcbiAqXG4gKiAgT3IgYXVnbWVudGVkVHlwZWRBcnJheXNcbiAqXG4gKiAgICAgdmFyIHBvc2l0aW9ucyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgNCk7XG4gKiAgICAgdmFyIHRleGNvb3JkcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgNCk7XG4gKiAgICAgdmFyIG5vcm1hbHMgICA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgNCk7XG4gKiAgICAgdmFyIGluZGljZXMgICA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgMiwgVWludDE2QXJyYXkpO1xuICpcbiAqICAgICBwb3NpdGlvbnMucHVzaChbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdKTtcbiAqICAgICB0ZXhjb29yZHMucHVzaChbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0pO1xuICogICAgIG5vcm1hbHMucHVzaChbMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMV0pO1xuICogICAgIGluZGljZXMucHVzaChbMCwgMSwgMiwgMSwgMiwgM10pO1xuICpcbiAqICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbnMsXG4gKiAgICAgICAgdGV4Y29vcmQ6IHRleGNvb3JkcyxcbiAqICAgICAgICBub3JtYWw6ICAgbm9ybWFscyxcbiAqICAgICAgICBpbmRpY2VzOiAgaW5kaWNlcyxcbiAqICAgICB9O1xuICpcbiAqIEZvciB0aGUgbGFzdCBleGFtcGxlIGl0IGlzIGVxdWl2YWxlbnQgdG9cbiAqXG4gKiAgICAgdmFyIGJ1ZmZlckluZm8gPSB7XG4gKiAgICAgICBhdHRyaWJzOiB7XG4gKiAgICAgICAgIGFfcG9zaXRpb246IHsgbnVtQ29tcG9uZW50czogMywgYnVmZmVyOiBnbC5jcmVhdGVCdWZmZXIoKSwgfSxcbiAqICAgICAgICAgYV90ZXhjb29kczogeyBudW1Db21wb25lbnRzOiAyLCBidWZmZXI6IGdsLmNyZWF0ZUJ1ZmZlcigpLCB9LFxuICogICAgICAgICBhX25vcm1hbHM6IHsgbnVtQ29tcG9uZW50czogMywgYnVmZmVyOiBnbC5jcmVhdGVCdWZmZXIoKSwgfSxcbiAqICAgICAgIH0sXG4gKiAgICAgICBpbmRpY2VzOiBnbC5jcmVhdGVCdWZmZXIoKSxcbiAqICAgICAgIG51bUVsZW1lbnRzOiA2LFxuICogICAgIH07XG4gKlxuICogICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJJbmZvLmF0dHJpYnMuYV9wb3NpdGlvbi5idWZmZXIpO1xuICogICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhcnJheXMucG9zaXRpb24sIGdsLlNUQVRJQ19EUkFXKTtcbiAqICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVySW5mby5hdHRyaWJzLmFfdGV4Y29vcmQuYnVmZmVyKTtcbiAqICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXJyYXlzLnRleGNvb3JkLCBnbC5TVEFUSUNfRFJBVyk7XG4gKiAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlckluZm8uYXR0cmlicy5hX25vcm1hbC5idWZmZXIpO1xuICogICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhcnJheXMubm9ybWFsLCBnbC5TVEFUSUNfRFJBVyk7XG4gKiAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnVmZmVySW5mby5pbmRpY2VzKTtcbiAqICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBhcnJheXMuaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5BcnJheXN9IGFycmF5cyBZb3VyIGRhdGFcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IEEgQnVmZmVySW5mb1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCBhcnJheXMpIHtcbiAgdmFyIGJ1ZmZlckluZm8gPSB7XG4gICAgYXR0cmliczogY3JlYXRlQXR0cmlic0Zyb21BcnJheXMoZ2wsIGFycmF5cylcbiAgfTtcbiAgdmFyIGluZGljZXMgPSBhcnJheXMuaW5kaWNlcztcblxuICBpZiAoaW5kaWNlcykge1xuICAgIHZhciBuZXdJbmRpY2VzID0gbWFrZVR5cGVkQXJyYXkoaW5kaWNlcywgXCJpbmRpY2VzXCIpO1xuICAgIGJ1ZmZlckluZm8uaW5kaWNlcyA9IGNyZWF0ZUJ1ZmZlckZyb21UeXBlZEFycmF5KGdsLCBuZXdJbmRpY2VzLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUik7XG4gICAgYnVmZmVySW5mby5udW1FbGVtZW50cyA9IG5ld0luZGljZXMubGVuZ3RoO1xuICAgIGJ1ZmZlckluZm8uZWxlbWVudFR5cGUgPSB0eXBlZEFycmF5cy5nZXRHTFR5cGVGb3JUeXBlZEFycmF5KG5ld0luZGljZXMpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlckluZm8ubnVtRWxlbWVudHMgPSBnZXROdW1FbGVtZW50c0Zyb21BdHRyaWJ1dGVzKGdsLCBidWZmZXJJbmZvLmF0dHJpYnMpO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlckluZm87XG59XG4vKipcbiAqIENyZWF0ZXMgYSBidWZmZXIgZnJvbSBhbiBhcnJheSwgdHlwZWQgYXJyYXksIG9yIGFycmF5IHNwZWNcbiAqXG4gKiBHaXZlbiBzb21ldGhpbmcgbGlrZSB0aGlzXG4gKlxuICogICAgIFsxLCAyLCAzXSxcbiAqXG4gKiBvclxuICpcbiAqICAgICBuZXcgVWludDE2QXJyYXkoWzEsMiwzXSk7XG4gKlxuICogb3JcbiAqXG4gKiAgICAge1xuICogICAgICAgIGRhdGE6IFsxLCAyLCAzXSxcbiAqICAgICAgICB0eXBlOiBVaW50OEFycmF5LFxuICogICAgIH1cbiAqXG4gKiByZXR1cm5zIGEgV2ViR0xCdWZmZXIgdGhhdCBjb25zdGFpbnMgdGhlIGdpdmVuIGRhdGEuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5BcnJheVNwZWN9IGFycmF5IGFuIGFycmF5LCB0eXBlZCBhcnJheSwgb3IgYXJyYXkgc3BlYy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcnJheU5hbWUgbmFtZSBvZiBhcnJheS4gVXNlZCB0byBndWVzcyB0aGUgdHlwZSBpZiB0eXBlIGNhbiBub3QgYmUgZGVydmllZCBvdGhlciB3aXNlLlxuICogQHJldHVybiB7V2ViR0xCdWZmZXJ9IGEgV2ViR0xCdWZmZXIgY29udGFpbmluZyB0aGUgZGF0YSBpbiBhcnJheS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXJGcm9tQXJyYXkoZ2wsIGFycmF5LCBhcnJheU5hbWUpIHtcbiAgdmFyIHR5cGUgPSBhcnJheU5hbWUgPT09IFwiaW5kaWNlc1wiID8gZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgOiBnbC5BUlJBWV9CVUZGRVI7XG4gIHZhciB0eXBlZEFycmF5ID0gbWFrZVR5cGVkQXJyYXkoYXJyYXksIGFycmF5TmFtZSk7XG4gIHJldHVybiBjcmVhdGVCdWZmZXJGcm9tVHlwZWRBcnJheShnbCwgdHlwZWRBcnJheSwgdHlwZSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYnVmZmVycyBmcm9tIGFycmF5cyBvciB0eXBlZCBhcnJheXNcbiAqXG4gKiBHaXZlbiBzb21ldGhpbmcgbGlrZSB0aGlzXG4gKlxuICogICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgcG9zaXRpb25zOiBbMSwgMiwgM10sXG4gKiAgICAgICAgbm9ybWFsczogWzAsIDAsIDFdLFxuICogICAgIH1cbiAqXG4gKiByZXR1cm5zIHNvbWV0aGluZyBsaWtlXG4gKlxuICogICAgIGJ1ZmZlcnMgPSB7XG4gKiAgICAgICBwb3NpdGlvbnM6IFdlYkdMQnVmZmVyLFxuICogICAgICAgbm9ybWFsczogV2ViR0xCdWZmZXIsXG4gKiAgICAgfVxuICpcbiAqIElmIHRoZSBidWZmZXIgaXMgbmFtZWQgJ2luZGljZXMnIGl0IHdpbGwgYmUgbWFkZSBhbiBFTEVNRU5UX0FSUkFZX0JVRkZFUi5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkFycmF5c30gYXJyYXlzXG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IHJldHVybnMgYW4gb2JqZWN0IHdpdGggb25lIFdlYkdMQnVmZmVyIHBlciBhcnJheVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcnNGcm9tQXJyYXlzKGdsLCBhcnJheXMpIHtcbiAgdmFyIGJ1ZmZlcnMgPSB7fTtcbiAgT2JqZWN0LmtleXMoYXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBidWZmZXJzW2tleV0gPSBjcmVhdGVCdWZmZXJGcm9tQXJyYXkoZ2wsIGFycmF5c1trZXldLCBrZXkpO1xuICB9KTsgLy8gVWdoIVxuXG4gIGlmIChhcnJheXMuaW5kaWNlcykge1xuICAgIGJ1ZmZlcnMubnVtRWxlbWVudHMgPSBhcnJheXMuaW5kaWNlcy5sZW5ndGg7XG4gICAgYnVmZmVycy5lbGVtZW50VHlwZSA9IHR5cGVkQXJyYXlzLmdldEdMVHlwZUZvclR5cGVkQXJyYXkobWFrZVR5cGVkQXJyYXkoYXJyYXlzLmluZGljZXMpLCAnaW5kaWNlcycpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlcnMubnVtRWxlbWVudHMgPSBnZXROdW1FbGVtZW50c0Zyb21Ob25JbmRleGVkQXJyYXlzKGFycmF5cyk7XG4gIH1cblxuICByZXR1cm4gYnVmZmVycztcbn1cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnNldFRleHR1cmVEZWZhdWx0c18gPSBzZXREZWZhdWx0cztcbmV4cG9ydHMuY3JlYXRlU2FtcGxlciA9IGNyZWF0ZVNhbXBsZXI7XG5leHBvcnRzLmNyZWF0ZVNhbXBsZXJzID0gY3JlYXRlU2FtcGxlcnM7XG5leHBvcnRzLnNldFNhbXBsZXJQYXJhbWV0ZXJzID0gc2V0U2FtcGxlclBhcmFtZXRlcnM7XG5leHBvcnRzLmNyZWF0ZVRleHR1cmUgPSBjcmVhdGVUZXh0dXJlO1xuZXhwb3J0cy5zZXRFbXB0eVRleHR1cmUgPSBzZXRFbXB0eVRleHR1cmU7XG5leHBvcnRzLnNldFRleHR1cmVGcm9tQXJyYXkgPSBzZXRUZXh0dXJlRnJvbUFycmF5O1xuZXhwb3J0cy5sb2FkVGV4dHVyZUZyb21VcmwgPSBsb2FkVGV4dHVyZUZyb21Vcmw7XG5leHBvcnRzLnNldFRleHR1cmVGcm9tRWxlbWVudCA9IHNldFRleHR1cmVGcm9tRWxlbWVudDtcbmV4cG9ydHMuc2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUgPSBzZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZTtcbmV4cG9ydHMuc2V0VGV4dHVyZVBhcmFtZXRlcnMgPSBzZXRUZXh0dXJlUGFyYW1ldGVycztcbmV4cG9ydHMuc2V0RGVmYXVsdFRleHR1cmVDb2xvciA9IHNldERlZmF1bHRUZXh0dXJlQ29sb3I7XG5leHBvcnRzLmNyZWF0ZVRleHR1cmVzID0gY3JlYXRlVGV4dHVyZXM7XG5leHBvcnRzLnJlc2l6ZVRleHR1cmUgPSByZXNpemVUZXh0dXJlO1xuZXhwb3J0cy5nZXROdW1Db21wb25lbnRzRm9yRm9ybWF0ID0gZ2V0TnVtQ29tcG9uZW50c0ZvckZvcm1hdDtcbmV4cG9ydHMuZ2V0Qnl0ZXNQZXJFbGVtZW50Rm9ySW50ZXJuYWxGb3JtYXQgPSBnZXRCeXRlc1BlckVsZW1lbnRGb3JJbnRlcm5hbEZvcm1hdDtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG5cbnZhciB0eXBlZEFycmF5cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xuXG52YXIgaGVscGVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygwKSk7XG5cbnZhciBfZ2xvYmFsT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMTUsIEdyZWdnIFRhdmFyZXMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4gKiBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4gKiBkaXN0cmlidXRpb24uXG4gKiAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdyZWdnIFRhdmFyZXMuIG5vciB0aGUgbmFtZXMgb2YgaGlzXG4gKiBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuLyoqXG4gKiBMb3cgbGV2ZWwgdGV4dHVyZSByZWxhdGVkIGZ1bmN0aW9uc1xuICpcbiAqIFlvdSBzaG91bGQgZ2VuZXJhbGx5IG5vdCBuZWVkIHRvIHVzZSB0aGVzZSBmdW5jdGlvbnMuIFRoZXkgYXJlIHByb3ZpZGVkXG4gKiBmb3IgdGhvc2UgY2FzZXMgd2hlcmUgeW91J3JlIGRvaW5nIHNvbWV0aGluZyBvdXQgb2YgdGhlIG9yZGluYXJ5XG4gKiBhbmQgeW91IG5lZWQgbG93ZXIgbGV2ZWwgYWNjZXNzLlxuICpcbiAqIEZvciBiYWNrd2FyZCBjb21wYXRpYmlseSB0aGV5IGFyZSBhdmFpbGFibGUgYXQgYm90aCBgdHdnbC50ZXh0dXJlc2AgYW5kIGB0d2dsYFxuICogaXRzZWxmXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6dHdnbH0gZm9yIGNvcmUgZnVuY3Rpb25zXG4gKlxuICogQG1vZHVsZSB0d2dsL3RleHR1cmVzXG4gKi9cbi8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBzZWUgYSBnbG9iYWwgZ2xcbnZhciBnbCA9IHVuZGVmaW5lZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIHRleHR1cmVDb2xvcjogbmV3IFVpbnQ4QXJyYXkoWzEyOCwgMTkyLCAyNTUsIDI1NV0pLFxuICB0ZXh0dXJlT3B0aW9uczoge30sXG4gIGNyb3NzT3JpZ2luOiB1bmRlZmluZWRcbn07XG52YXIgaXNBcnJheUJ1ZmZlciA9IHR5cGVkQXJyYXlzLmlzQXJyYXlCdWZmZXI7IC8vIFNob3VsZCB3ZSBtYWtlIHRoaXMgb24gZGVtYW5kP1xuXG52YXIgY3R4ID0gX2dsb2JhbE9iamVjdC5kZWZhdWx0LmRvY3VtZW50ICYmIF9nbG9iYWxPYmplY3QuZGVmYXVsdC5kb2N1bWVudC5jcmVhdGVFbGVtZW50ID8gX2dsb2JhbE9iamVjdC5kZWZhdWx0LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpIDogbnVsbDsgLy8gTk9URTogQ2hyb21lIHN1cHBvcnRzIDJEIGNhbnZhcyBpbiBhIFdvcmtlciAoYmVoaW5kIGZsYWcgYXMgb2YgdjY0IGJ1dFxuLy8gICAgICAgbm90IG9ubHkgZG9lcyBGaXJlZm94IE5PVCBzdXBwb3J0IGl0IGJ1dCBGaXJlZm94IGZyZWV6ZXMgaW1tZWRpYXRlbHlcbi8vICAgICAgIGlmIHlvdSB0cnkgdG8gY3JlYXRlIG9uZSBpbnN0ZWFkIG9mIGp1c3QgcmV0dXJuaW5nIG51bGwgYW5kIGNvbnRpbnVpbmcuXG4vLyAgOiAoZ2xvYmFsLk9mZnNjcmVlbkNhbnZhcyAmJiAobmV3IGdsb2JhbC5PZmZzY3JlZW5DYW52YXMoMSwgMSkpLmdldENvbnRleHQoXCIyZFwiKSk7ICAvLyBPZmZzY3JlZW5DYW52YXMgbWF5IG5vdCBzdXBwb3J0IDJkXG4vLyBOT1RFOiBXZSBjYW4gbWF5YmUgcmVtb3ZlIHNvbWUgb2YgdGhlIG5lZWQgZm9yIHRoZSAyZCBjYW52YXMuIEluIFdlYkdMMlxuLy8gd2UgY2FuIHVzZSB0aGUgdmFyaW91cyB1bnBhY2sgc2V0dGluZ3MuIE90aGVyd2lzZSB3ZSBjb3VsZCB0cnkgdXNpbmdcbi8vIHRoZSBhYmlsaXR5IG9mIGFuIGltYWdlYml0bWFwIHRvIGJlIGN1dC4gVW5mb3J0dW5hdGVseSBjdXR0aW5nIGFuIGltYWdlYml0bWFwXG4vLyBpcyBhc3luYyBhbmQgdGhlIGN1cnJlbnQgVFdHTCBjb2RlIGV4cGVjdHMgYSBub24tQXN5bmMgcmVzdWx0IHRob3VnaCB0aGF0XG4vLyBtaWdodCBub3QgYmUgYSBwcm9ibGVtLiBJbWFnZUJpdG1hcCB0aG91Z2ggaXMgbm90IGF2YWlsYWJsZSBpbiBFZGdlIG9yIFNhZmFyaVxuLy8gYXMgb2YgMjAxOC0wMS0wMlxuXG4vKiBQaXhlbEZvcm1hdCAqL1xuXG52YXIgQUxQSEEgPSAweDE5MDY7XG52YXIgUkdCID0gMHgxOTA3O1xudmFyIFJHQkEgPSAweDE5MDg7XG52YXIgTFVNSU5BTkNFID0gMHgxOTA5O1xudmFyIExVTUlOQU5DRV9BTFBIQSA9IDB4MTkwQTtcbnZhciBERVBUSF9DT01QT05FTlQgPSAweDE5MDI7XG52YXIgREVQVEhfU1RFTkNJTCA9IDB4ODRGOTtcbi8qIFRleHR1cmVXcmFwTW9kZSAqL1xuXG52YXIgUkVQRUFUID0gMHgyOTAxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbnZhciBNSVJST1JFRF9SRVBFQVQgPSAweDgzNzA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyogVGV4dHVyZU1hZ0ZpbHRlciAqL1xuXG52YXIgTkVBUkVTVCA9IDB4MjYwMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKiBUZXh0dXJlTWluRmlsdGVyICovXG5cbnZhciBORUFSRVNUX01JUE1BUF9ORUFSRVNUID0gMHgyNzAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbnZhciBMSU5FQVJfTUlQTUFQX05FQVJFU1QgPSAweDI3MDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxudmFyIE5FQVJFU1RfTUlQTUFQX0xJTkVBUiA9IDB4MjcwMjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG52YXIgTElORUFSX01JUE1BUF9MSU5FQVIgPSAweDI3MDM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxudmFyIFI4ID0gMHg4MjI5O1xudmFyIFI4X1NOT1JNID0gMHg4Rjk0O1xudmFyIFIxNkYgPSAweDgyMkQ7XG52YXIgUjMyRiA9IDB4ODIyRTtcbnZhciBSOFVJID0gMHg4MjMyO1xudmFyIFI4SSA9IDB4ODIzMTtcbnZhciBSRzE2VUkgPSAweDgyM0E7XG52YXIgUkcxNkkgPSAweDgyMzk7XG52YXIgUkczMlVJID0gMHg4MjNDO1xudmFyIFJHMzJJID0gMHg4MjNCO1xudmFyIFJHOCA9IDB4ODIyQjtcbnZhciBSRzhfU05PUk0gPSAweDhGOTU7XG52YXIgUkcxNkYgPSAweDgyMkY7XG52YXIgUkczMkYgPSAweDgyMzA7XG52YXIgUkc4VUkgPSAweDgyMzg7XG52YXIgUkc4SSA9IDB4ODIzNztcbnZhciBSMTZVSSA9IDB4ODIzNDtcbnZhciBSMTZJID0gMHg4MjMzO1xudmFyIFIzMlVJID0gMHg4MjM2O1xudmFyIFIzMkkgPSAweDgyMzU7XG52YXIgUkdCOCA9IDB4ODA1MTtcbnZhciBTUkdCOCA9IDB4OEM0MTtcbnZhciBSR0I1NjUgPSAweDhENjI7XG52YXIgUkdCOF9TTk9STSA9IDB4OEY5NjtcbnZhciBSMTFGX0cxMUZfQjEwRiA9IDB4OEMzQTtcbnZhciBSR0I5X0U1ID0gMHg4QzNEO1xudmFyIFJHQjE2RiA9IDB4ODgxQjtcbnZhciBSR0IzMkYgPSAweDg4MTU7XG52YXIgUkdCOFVJID0gMHg4RDdEO1xudmFyIFJHQjhJID0gMHg4RDhGO1xudmFyIFJHQjE2VUkgPSAweDhENzc7XG52YXIgUkdCMTZJID0gMHg4RDg5O1xudmFyIFJHQjMyVUkgPSAweDhENzE7XG52YXIgUkdCMzJJID0gMHg4RDgzO1xudmFyIFJHQkE4ID0gMHg4MDU4O1xudmFyIFNSR0I4X0FMUEhBOCA9IDB4OEM0MztcbnZhciBSR0JBOF9TTk9STSA9IDB4OEY5NztcbnZhciBSR0I1X0ExID0gMHg4MDU3O1xudmFyIFJHQkE0ID0gMHg4MDU2O1xudmFyIFJHQjEwX0EyID0gMHg4MDU5O1xudmFyIFJHQkExNkYgPSAweDg4MUE7XG52YXIgUkdCQTMyRiA9IDB4ODgxNDtcbnZhciBSR0JBOFVJID0gMHg4RDdDO1xudmFyIFJHQkE4SSA9IDB4OEQ4RTtcbnZhciBSR0IxMF9BMlVJID0gMHg5MDZGO1xudmFyIFJHQkExNlVJID0gMHg4RDc2O1xudmFyIFJHQkExNkkgPSAweDhEODg7XG52YXIgUkdCQTMySSA9IDB4OEQ4MjtcbnZhciBSR0JBMzJVSSA9IDB4OEQ3MDtcbnZhciBERVBUSF9DT01QT05FTlQxNiA9IDB4ODFBNTtcbnZhciBERVBUSF9DT01QT05FTlQyNCA9IDB4ODFBNjtcbnZhciBERVBUSF9DT01QT05FTlQzMkYgPSAweDhDQUM7XG52YXIgREVQVEgzMkZfU1RFTkNJTDggPSAweDhDQUQ7XG52YXIgREVQVEgyNF9TVEVOQ0lMOCA9IDB4ODhGMDtcbi8qIERhdGFUeXBlICovXG5cbnZhciBCWVRFID0gMHgxNDAwO1xudmFyIFVOU0lHTkVEX0JZVEUgPSAweDE0MDE7XG52YXIgU0hPUlQgPSAweDE0MDI7XG52YXIgVU5TSUdORURfU0hPUlQgPSAweDE0MDM7XG52YXIgSU5UID0gMHgxNDA0O1xudmFyIFVOU0lHTkVEX0lOVCA9IDB4MTQwNTtcbnZhciBGTE9BVCA9IDB4MTQwNjtcbnZhciBVTlNJR05FRF9TSE9SVF80XzRfNF80ID0gMHg4MDMzO1xudmFyIFVOU0lHTkVEX1NIT1JUXzVfNV81XzEgPSAweDgwMzQ7XG52YXIgVU5TSUdORURfU0hPUlRfNV82XzUgPSAweDgzNjM7XG52YXIgSEFMRl9GTE9BVCA9IDB4MTQwQjtcbnZhciBIQUxGX0ZMT0FUX09FUyA9IDB4OEQ2MTsgLy8gVGhhbmtzIEtocm9ub3MgZm9yIG1ha2luZyB0aGlzIGRpZmZlcmVudCA+OihcblxudmFyIFVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFViA9IDB4ODM2ODtcbnZhciBVTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWID0gMHg4QzNCO1xudmFyIFVOU0lHTkVEX0lOVF81XzlfOV85X1JFViA9IDB4OEMzRTtcbnZhciBGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVYgPSAweDhEQUQ7XG52YXIgVU5TSUdORURfSU5UXzI0XzggPSAweDg0RkE7XG52YXIgUkcgPSAweDgyMjc7XG52YXIgUkdfSU5URUdFUiA9IDB4ODIyODtcbnZhciBSRUQgPSAweDE5MDM7XG52YXIgUkVEX0lOVEVHRVIgPSAweDhEOTQ7XG52YXIgUkdCX0lOVEVHRVIgPSAweDhEOTg7XG52YXIgUkdCQV9JTlRFR0VSID0gMHg4RDk5O1xudmFyIGZvcm1hdEluZm8gPSB7fTtcbntcbiAgLy8gTk9URTogdGhpcyBpcyBuYW1lZCBgbnVtQ29sb3JDb21wb25lbnRzYCB2cyBgbnVtQ29tcG9uZW50c2Agc28gd2UgY2FuIGxldCBVZ2xpZnkgbWFuZ2xlXG4gIC8vIHRoZSBuYW1lLlxuICB2YXIgZiA9IGZvcm1hdEluZm87XG4gIGZbQUxQSEFdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogMVxuICB9O1xuICBmW0xVTUlOQU5DRV0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiAxXG4gIH07XG4gIGZbTFVNSU5BTkNFX0FMUEhBXSA9IHtcbiAgICBudW1Db2xvckNvbXBvbmVudHM6IDJcbiAgfTtcbiAgZltSR0JdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogM1xuICB9O1xuICBmW1JHQkFdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogNFxuICB9O1xuICBmW1JFRF0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiAxXG4gIH07XG4gIGZbUkVEX0lOVEVHRVJdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogMVxuICB9O1xuICBmW1JHXSA9IHtcbiAgICBudW1Db2xvckNvbXBvbmVudHM6IDJcbiAgfTtcbiAgZltSR19JTlRFR0VSXSA9IHtcbiAgICBudW1Db2xvckNvbXBvbmVudHM6IDJcbiAgfTtcbiAgZltSR0JdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogM1xuICB9O1xuICBmW1JHQl9JTlRFR0VSXSA9IHtcbiAgICBudW1Db2xvckNvbXBvbmVudHM6IDNcbiAgfTtcbiAgZltSR0JBXSA9IHtcbiAgICBudW1Db2xvckNvbXBvbmVudHM6IDRcbiAgfTtcbiAgZltSR0JBX0lOVEVHRVJdID0ge1xuICAgIG51bUNvbG9yQ29tcG9uZW50czogNFxuICB9O1xuICBmW0RFUFRIX0NPTVBPTkVOVF0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiAxXG4gIH07XG4gIGZbREVQVEhfU1RFTkNJTF0gPSB7XG4gICAgbnVtQ29sb3JDb21wb25lbnRzOiAyXG4gIH07XG59XG52YXIgdGV4dHVyZUludGVybmFsRm9ybWF0SW5mbyA9IHt9O1xue1xuICAvLyBOT1RFOiB0aGVzZSBwcm9wZXJ0aWVzIG5lZWQgdW5pcXVlIG5hbWVzIHNvIHdlIGNhbiBsZXQgVWdsaWZ5IG1hbmdsZSB0aGUgbmFtZS5cbiAgdmFyIHQgPSB0ZXh0dXJlSW50ZXJuYWxGb3JtYXRJbmZvOyAvLyB1bnNpemVkIGZvcm1hdHNcblxuICB0W0FMUEhBXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBBTFBIQSxcbiAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiBbMSwgMiwgMiwgNF0sXG4gICAgdHlwZTogW1VOU0lHTkVEX0JZVEUsIEhBTEZfRkxPQVQsIEhBTEZfRkxPQVRfT0VTLCBGTE9BVF1cbiAgfTtcbiAgdFtMVU1JTkFOQ0VdID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IExVTUlOQU5DRSxcbiAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiBbMSwgMiwgMiwgNF0sXG4gICAgdHlwZTogW1VOU0lHTkVEX0JZVEUsIEhBTEZfRkxPQVQsIEhBTEZfRkxPQVRfT0VTLCBGTE9BVF1cbiAgfTtcbiAgdFtMVU1JTkFOQ0VfQUxQSEFdID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IExVTUlOQU5DRV9BTFBIQSxcbiAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiBbMiwgNCwgNCwgOF0sXG4gICAgdHlwZTogW1VOU0lHTkVEX0JZVEUsIEhBTEZfRkxPQVQsIEhBTEZfRkxPQVRfT0VTLCBGTE9BVF1cbiAgfTtcbiAgdFtSR0JdID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJHQixcbiAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiBbMywgNiwgNiwgMTIsIDJdLFxuICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFLCBIQUxGX0ZMT0FULCBIQUxGX0ZMT0FUX09FUywgRkxPQVQsIFVOU0lHTkVEX1NIT1JUXzVfNl81XVxuICB9O1xuICB0W1JHQkFdID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJHQkEsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogWzQsIDgsIDgsIDE2LCAyLCAyXSxcbiAgICB0eXBlOiBbVU5TSUdORURfQllURSwgSEFMRl9GTE9BVCwgSEFMRl9GTE9BVF9PRVMsIEZMT0FULCBVTlNJR05FRF9TSE9SVF80XzRfNF80LCBVTlNJR05FRF9TSE9SVF81XzVfNV8xXVxuICB9OyAvLyBzaXplZCBmb3JtYXRzXG5cbiAgdFtSOF0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkVELFxuICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDEsXG4gICAgdHlwZTogVU5TSUdORURfQllURVxuICB9O1xuICB0W1I4X1NOT1JNXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSRUQsXG4gICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDEsXG4gICAgdHlwZTogQllURVxuICB9O1xuICB0W1IxNkZdID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJFRCxcbiAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogWzQsIDJdLFxuICAgIHR5cGU6IFtGTE9BVCwgSEFMRl9GTE9BVF1cbiAgfTtcbiAgdFtSMzJGXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSRUQsXG4gICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiA0LFxuICAgIHR5cGU6IEZMT0FUXG4gIH07XG4gIHRbUjhVSV0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkVEX0lOVEVHRVIsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDEsXG4gICAgdHlwZTogVU5TSUdORURfQllURVxuICB9O1xuICB0W1I4SV0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkVEX0lOVEVHRVIsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDEsXG4gICAgdHlwZTogQllURVxuICB9O1xuICB0W1IxNlVJXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSRURfSU5URUdFUixcbiAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogMixcbiAgICB0eXBlOiBVTlNJR05FRF9TSE9SVFxuICB9O1xuICB0W1IxNkldID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJFRF9JTlRFR0VSLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiAyLFxuICAgIHR5cGU6IFNIT1JUXG4gIH07XG4gIHRbUjMyVUldID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJFRF9JTlRFR0VSLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiA0LFxuICAgIHR5cGU6IFVOU0lHTkVEX0lOVFxuICB9O1xuICB0W1IzMkldID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJFRF9JTlRFR0VSLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiA0LFxuICAgIHR5cGU6IElOVFxuICB9O1xuICB0W1JHOF0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkcsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogMixcbiAgICB0eXBlOiBVTlNJR05FRF9CWVRFXG4gIH07XG4gIHRbUkc4X1NOT1JNXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSRyxcbiAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogMixcbiAgICB0eXBlOiBCWVRFXG4gIH07XG4gIHRbUkcxNkZdID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJHLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiBbOCwgNF0sXG4gICAgdHlwZTogW0ZMT0FULCBIQUxGX0ZMT0FUXVxuICB9O1xuICB0W1JHMzJGXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSRyxcbiAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDgsXG4gICAgdHlwZTogRkxPQVRcbiAgfTtcbiAgdFtSRzhVSV0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdfSU5URUdFUixcbiAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogMixcbiAgICB0eXBlOiBVTlNJR05FRF9CWVRFXG4gIH07XG4gIHRbUkc4SV0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdfSU5URUdFUixcbiAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogMixcbiAgICB0eXBlOiBCWVRFXG4gIH07XG4gIHRbUkcxNlVJXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSR19JTlRFR0VSLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiA0LFxuICAgIHR5cGU6IFVOU0lHTkVEX1NIT1JUXG4gIH07XG4gIHRbUkcxNkldID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJHX0lOVEVHRVIsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDQsXG4gICAgdHlwZTogU0hPUlRcbiAgfTtcbiAgdFtSRzMyVUldID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJHX0lOVEVHRVIsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDgsXG4gICAgdHlwZTogVU5TSUdORURfSU5UXG4gIH07XG4gIHRbUkczMkldID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJHX0lOVEVHRVIsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDgsXG4gICAgdHlwZTogSU5UXG4gIH07XG4gIHRbUkdCOF0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdCLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDMsXG4gICAgdHlwZTogVU5TSUdORURfQllURVxuICB9O1xuICB0W1NSR0I4XSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSR0IsXG4gICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDMsXG4gICAgdHlwZTogVU5TSUdORURfQllURVxuICB9O1xuICB0W1JHQjU2NV0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdCLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IFszLCAyXSxcbiAgICB0eXBlOiBbVU5TSUdORURfQllURSwgVU5TSUdORURfU0hPUlRfNV82XzVdXG4gIH07XG4gIHRbUkdCOF9TTk9STV0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdCLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiAzLFxuICAgIHR5cGU6IEJZVEVcbiAgfTtcbiAgdFtSMTFGX0cxMUZfQjEwRl0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdCLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiBbMTIsIDYsIDRdLFxuICAgIHR5cGU6IFtGTE9BVCwgSEFMRl9GTE9BVCwgVU5TSUdORURfSU5UXzEwRl8xMUZfMTFGX1JFVl1cbiAgfTtcbiAgdFtSR0I5X0U1XSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSR0IsXG4gICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IFsxMiwgNiwgNF0sXG4gICAgdHlwZTogW0ZMT0FULCBIQUxGX0ZMT0FULCBVTlNJR05FRF9JTlRfNV85XzlfOV9SRVZdXG4gIH07XG4gIHRbUkdCMTZGXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSR0IsXG4gICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IFsxMiwgNl0sXG4gICAgdHlwZTogW0ZMT0FULCBIQUxGX0ZMT0FUXVxuICB9O1xuICB0W1JHQjMyRl0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdCLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogMTIsXG4gICAgdHlwZTogRkxPQVRcbiAgfTtcbiAgdFtSR0I4VUldID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJHQl9JTlRFR0VSLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogMyxcbiAgICB0eXBlOiBVTlNJR05FRF9CWVRFXG4gIH07XG4gIHRbUkdCOEldID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJHQl9JTlRFR0VSLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogMyxcbiAgICB0eXBlOiBCWVRFXG4gIH07XG4gIHRbUkdCMTZVSV0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdCX0lOVEVHRVIsXG4gICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiA2LFxuICAgIHR5cGU6IFVOU0lHTkVEX1NIT1JUXG4gIH07XG4gIHRbUkdCMTZJXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSR0JfSU5URUdFUixcbiAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDYsXG4gICAgdHlwZTogU0hPUlRcbiAgfTtcbiAgdFtSR0IzMlVJXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSR0JfSU5URUdFUixcbiAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDEyLFxuICAgIHR5cGU6IFVOU0lHTkVEX0lOVFxuICB9O1xuICB0W1JHQjMySV0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdCX0lOVEVHRVIsXG4gICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiAxMixcbiAgICB0eXBlOiBJTlRcbiAgfTtcbiAgdFtSR0JBOF0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdCQSxcbiAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiA0LFxuICAgIHR5cGU6IFVOU0lHTkVEX0JZVEVcbiAgfTtcbiAgdFtTUkdCOF9BTFBIQThdID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJHQkEsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogNCxcbiAgICB0eXBlOiBVTlNJR05FRF9CWVRFXG4gIH07XG4gIHRbUkdCQThfU05PUk1dID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJHQkEsXG4gICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDQsXG4gICAgdHlwZTogQllURVxuICB9O1xuICB0W1JHQjVfQTFdID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJHQkEsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogWzQsIDIsIDRdLFxuICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFLCBVTlNJR05FRF9TSE9SVF81XzVfNV8xLCBVTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVZdXG4gIH07XG4gIHRbUkdCQTRdID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJHQkEsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogWzQsIDJdLFxuICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFLCBVTlNJR05FRF9TSE9SVF80XzRfNF80XVxuICB9O1xuICB0W1JHQjEwX0EyXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDQsXG4gICAgdHlwZTogVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWXG4gIH07XG4gIHRbUkdCQTE2Rl0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdCQSxcbiAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogWzE2LCA4XSxcbiAgICB0eXBlOiBbRkxPQVQsIEhBTEZfRkxPQVRdXG4gIH07XG4gIHRbUkdCQTMyRl0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdCQSxcbiAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDE2LFxuICAgIHR5cGU6IEZMT0FUXG4gIH07XG4gIHRbUkdCQThVSV0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdCQV9JTlRFR0VSLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiA0LFxuICAgIHR5cGU6IFVOU0lHTkVEX0JZVEVcbiAgfTtcbiAgdFtSR0JBOEldID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUixcbiAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogNCxcbiAgICB0eXBlOiBCWVRFXG4gIH07XG4gIHRbUkdCMTBfQTJVSV0gPSB7XG4gICAgdGV4dHVyZUZvcm1hdDogUkdCQV9JTlRFR0VSLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiA0LFxuICAgIHR5cGU6IFVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVlxuICB9O1xuICB0W1JHQkExNlVJXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBX0lOVEVHRVIsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDgsXG4gICAgdHlwZTogVU5TSUdORURfU0hPUlRcbiAgfTtcbiAgdFtSR0JBMTZJXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBX0lOVEVHRVIsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDgsXG4gICAgdHlwZTogU0hPUlRcbiAgfTtcbiAgdFtSR0JBMzJJXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBX0lOVEVHRVIsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDE2LFxuICAgIHR5cGU6IElOVFxuICB9O1xuICB0W1JHQkEzMlVJXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBSR0JBX0lOVEVHRVIsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDE2LFxuICAgIHR5cGU6IFVOU0lHTkVEX0lOVFxuICB9OyAvLyBTaXplZCBJbnRlcm5hbFxuXG4gIHRbREVQVEhfQ09NUE9ORU5UMTZdID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IERFUFRIX0NPTVBPTkVOVCxcbiAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsXG4gICAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLFxuICAgIGJ5dGVzUGVyRWxlbWVudDogWzIsIDRdLFxuICAgIHR5cGU6IFtVTlNJR05FRF9TSE9SVCwgVU5TSUdORURfSU5UXVxuICB9O1xuICB0W0RFUFRIX0NPTVBPTkVOVDI0XSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBERVBUSF9DT01QT05FTlQsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDQsXG4gICAgdHlwZTogVU5TSUdORURfSU5UXG4gIH07XG4gIHRbREVQVEhfQ09NUE9ORU5UMzJGXSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBERVBUSF9DT01QT05FTlQsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDQsXG4gICAgdHlwZTogRkxPQVRcbiAgfTtcbiAgdFtERVBUSDI0X1NURU5DSUw4XSA9IHtcbiAgICB0ZXh0dXJlRm9ybWF0OiBERVBUSF9TVEVOQ0lMLFxuICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsXG4gICAgYnl0ZXNQZXJFbGVtZW50OiA0LFxuICAgIHR5cGU6IFVOU0lHTkVEX0lOVF8yNF84XG4gIH07XG4gIHRbREVQVEgzMkZfU1RFTkNJTDhdID0ge1xuICAgIHRleHR1cmVGb3JtYXQ6IERFUFRIX1NURU5DSUwsXG4gICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLFxuICAgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSxcbiAgICBieXRlc1BlckVsZW1lbnQ6IDQsXG4gICAgdHlwZTogRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWXG4gIH07XG4gIE9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24gKGludGVybmFsRm9ybWF0KSB7XG4gICAgdmFyIGluZm8gPSB0W2ludGVybmFsRm9ybWF0XTtcbiAgICBpbmZvLmJ5dGVzUGVyRWxlbWVudE1hcCA9IHt9O1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5mby5ieXRlc1BlckVsZW1lbnQpKSB7XG4gICAgICBpbmZvLmJ5dGVzUGVyRWxlbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChieXRlc1BlckVsZW1lbnQsIG5keCkge1xuICAgICAgICB2YXIgdHlwZSA9IGluZm8udHlwZVtuZHhdO1xuICAgICAgICBpbmZvLmJ5dGVzUGVyRWxlbWVudE1hcFt0eXBlXSA9IGJ5dGVzUGVyRWxlbWVudDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdHlwZSA9IGluZm8udHlwZTtcbiAgICAgIGluZm8uYnl0ZXNQZXJFbGVtZW50TWFwW3R5cGVdID0gaW5mby5ieXRlc1BlckVsZW1lbnQ7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHBlciBlbGVtZW50IGZvciBhIGdpdmVuIGludGVybmFsRm9ybWF0IC8gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IGludGVybmFsRm9ybWF0IFRoZSBpbnRlcm5hbEZvcm1hdCBwYXJhbWV0ZXIgZnJvbSB0ZXhJbWFnZTJEIGV0Yy4uXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgdHlwZSBwYXJhbWV0ZXIgZm9yIHRleEltYWdlMkQgZXRjLi5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBieXRlcyBwZXIgZWxlbWVudCBmb3IgdGhlIGdpdmVuIGludGVybmFsRm9ybWF0LCB0eXBlIGNvbWJvXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRCeXRlc1BlckVsZW1lbnRGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCwgdHlwZSkge1xuICB2YXIgaW5mbyA9IHRleHR1cmVJbnRlcm5hbEZvcm1hdEluZm9baW50ZXJuYWxGb3JtYXRdO1xuXG4gIGlmICghaW5mbykge1xuICAgIHRocm93IFwidW5rbm93biBpbnRlcm5hbCBmb3JtYXRcIjtcbiAgfVxuXG4gIHZhciBieXRlc1BlckVsZW1lbnQgPSBpbmZvLmJ5dGVzUGVyRWxlbWVudE1hcFt0eXBlXTtcblxuICBpZiAoYnl0ZXNQZXJFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBcInVua25vd24gaW50ZXJuYWwgZm9ybWF0XCI7XG4gIH1cblxuICByZXR1cm4gYnl0ZXNQZXJFbGVtZW50O1xufVxuLyoqXG4gKiBHZXRzIHRoZSBmb3JtYXQgZm9yIGEgZ2l2ZW4gaW50ZXJuYWxGb3JtYXRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW50ZXJuYWxGb3JtYXQgVGhlIGludGVybmFsIGZvcm1hdFxuICogQHJldHVybiB7e2Zvcm1hdDpudW1iZXIsIHR5cGU6bnVtYmVyfX0gdGhlIGNvcnJlc3BvbmRpbmcgZm9ybWF0IGFuZCB0eXBlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRGb3JtYXRBbmRUeXBlRm9ySW50ZXJuYWxGb3JtYXQoaW50ZXJuYWxGb3JtYXQpIHtcbiAgdmFyIGluZm8gPSB0ZXh0dXJlSW50ZXJuYWxGb3JtYXRJbmZvW2ludGVybmFsRm9ybWF0XTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB0aHJvdyBcInVua25vd24gaW50ZXJuYWwgZm9ybWF0XCI7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogaW5mby50ZXh0dXJlRm9ybWF0LFxuICAgIHR5cGU6IEFycmF5LmlzQXJyYXkoaW5mby50eXBlKSA/IGluZm8udHlwZVswXSA6IGluZm8udHlwZVxuICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgcG93ZXIgb2YgMlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIG51bWJlciB0byBjaGVjay5cbiAqIEByZXR1cm4gdHJ1ZSBpZiB2YWx1ZSBpcyBwb3dlciBvZiAyXG4gKi9cblxuXG5mdW5jdGlvbiBpc1Bvd2VyT2YyKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiB2YWx1ZSAtIDEpID09PSAwO1xufVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHdlIGNhbiBnZW5lcmF0ZSBtaXBzIGZvciB0aGUgZ2l2ZW4gZm9ybWF0XG4gKiBAcGFyYW0ge251bWJlcn0gaW50ZXJuYWxGb3JtYXQgVGhlIGludGVybmFsRm9ybWF0IHBhcmFtZXRlciBmcm9tIHRleEltYWdlMkQgZXRjLi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSB0eXBlIHBhcmFtZXRlciBmb3IgdGV4SW1hZ2UyRCBldGMuLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB3ZSBjYW4gZ2VuZXJhdGUgbWlwc1xuICovXG5cblxuZnVuY3Rpb24gY2FuR2VuZXJhdGVNaXBtYXAoZ2wsIHdpZHRoLCBoZWlnaHQsIGludGVybmFsRm9ybWF0XG4vKiwgdHlwZSAqL1xuKSB7XG4gIGlmICghdXRpbHMuaXNXZWJHTDIoZ2wpKSB7XG4gICAgcmV0dXJuIGlzUG93ZXJPZjIod2lkdGgpICYmIGlzUG93ZXJPZjIoaGVpZ2h0KTtcbiAgfVxuXG4gIHZhciBpbmZvID0gdGV4dHVyZUludGVybmFsRm9ybWF0SW5mb1tpbnRlcm5hbEZvcm1hdF07XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdGhyb3cgXCJ1bmtub3duIGludGVybmFsIGZvcm1hdFwiO1xuICB9XG5cbiAgcmV0dXJuIGluZm8uY29sb3JSZW5kZXJhYmxlICYmIGluZm8udGV4dHVyZUZpbHRlcmFibGU7XG59XG4vKipcbiAqIEdldHMgd2hldGhlciBvciBub3Qgd2UgY2FuIGdlbmVyYXRlIG1pcHMgZm9yIHRoZSBnaXZlbiBmb3JtYXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcm5hbEZvcm1hdCBUaGUgaW50ZXJuYWxGb3JtYXQgcGFyYW1ldGVyIGZyb20gdGV4SW1hZ2UyRCBldGMuLlxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgVGhlIHR5cGUgcGFyYW1ldGVyIGZvciB0ZXhJbWFnZTJEIGV0Yy4uXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHdlIGNhbiBnZW5lcmF0ZSBtaXBzXG4gKi9cblxuXG5mdW5jdGlvbiBjYW5GaWx0ZXIoaW50ZXJuYWxGb3JtYXRcbi8qLCB0eXBlICovXG4pIHtcbiAgdmFyIGluZm8gPSB0ZXh0dXJlSW50ZXJuYWxGb3JtYXRJbmZvW2ludGVybmFsRm9ybWF0XTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB0aHJvdyBcInVua25vd24gaW50ZXJuYWwgZm9ybWF0XCI7XG4gIH1cblxuICByZXR1cm4gaW5mby50ZXh0dXJlRmlsdGVyYWJsZTtcbn1cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGNvbXBvbnRlbnRzIGZvciBhIGdpdmVuIGltYWdlIGZvcm1hdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3JtYXQgdGhlIGZvcm1hdC5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIGZvciB0aGUgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBnZXROdW1Db21wb25lbnRzRm9yRm9ybWF0KGZvcm1hdCkge1xuICB2YXIgaW5mbyA9IGZvcm1hdEluZm9bZm9ybWF0XTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB0aHJvdyBcInVua25vd24gZm9ybWF0OiBcIiArIGZvcm1hdDtcbiAgfVxuXG4gIHJldHVybiBpbmZvLm51bUNvbG9yQ29tcG9uZW50cztcbn1cbi8qKlxuICogR2V0cyB0aGUgdGV4dHVyZSB0eXBlIGZvciBhIGdpdmVuIGFycmF5IHR5cGUuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgZ2wgdGV4dHVyZSB0eXBlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRUZXh0dXJlVHlwZUZvckFycmF5VHlwZShnbCwgc3JjLCBkZWZhdWx0VHlwZSkge1xuICBpZiAoaXNBcnJheUJ1ZmZlcihzcmMpKSB7XG4gICAgcmV0dXJuIHR5cGVkQXJyYXlzLmdldEdMVHlwZUZvclR5cGVkQXJyYXkoc3JjKTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VHlwZSB8fCBnbC5VTlNJR05FRF9CWVRFO1xufVxuXG5mdW5jdGlvbiBndWVzc0RpbWVuc2lvbnMoZ2wsIHRhcmdldCwgd2lkdGgsIGhlaWdodCwgbnVtRWxlbWVudHMpIHtcbiAgaWYgKG51bUVsZW1lbnRzICUgMSAhPT0gMCkge1xuICAgIHRocm93IFwiY2FuJ3QgZ3Vlc3MgZGltZW5zaW9uc1wiO1xuICB9XG5cbiAgaWYgKCF3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgdmFyIHNpemUgPSBNYXRoLnNxcnQobnVtRWxlbWVudHMgLyAodGFyZ2V0ID09PSBnbC5URVhUVVJFX0NVQkVfTUFQID8gNiA6IDEpKTtcblxuICAgIGlmIChzaXplICUgMSA9PT0gMCkge1xuICAgICAgd2lkdGggPSBzaXplO1xuICAgICAgaGVpZ2h0ID0gc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBudW1FbGVtZW50cztcbiAgICAgIGhlaWdodCA9IDE7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFoZWlnaHQpIHtcbiAgICBoZWlnaHQgPSBudW1FbGVtZW50cyAvIHdpZHRoO1xuXG4gICAgaWYgKGhlaWdodCAlIDEpIHtcbiAgICAgIHRocm93IFwiY2FuJ3QgZ3Vlc3MgZGltZW5zaW9uc1wiO1xuICAgIH1cbiAgfSBlbHNlIGlmICghd2lkdGgpIHtcbiAgICB3aWR0aCA9IG51bUVsZW1lbnRzIC8gaGVpZ2h0O1xuXG4gICAgaWYgKHdpZHRoICUgMSkge1xuICAgICAgdGhyb3cgXCJjYW4ndCBndWVzcyBkaW1lbnNpb25zXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn1cbi8qKlxuICogU2V0cyB0aGUgZGVmYXVsdCB0ZXh0dXJlIGNvbG9yLlxuICpcbiAqIFRoZSBkZWZhdWx0IHRleHR1cmUgY29sb3IgaXMgdXNlZCB3aGVuIGxvYWRpbmcgdGV4dHVyZXMgZnJvbVxuICogdXJscy4gQmVjYXVzZSB0aGUgVVJMIHdpbGwgYmUgbG9hZGVkIGFzeW5jIHdlJ2QgbGlrZSB0byBiZVxuICogYWJsZSB0byB1c2UgdGhlIHRleHR1cmUgaW1tZWRpYXRlbHkuIEJ5IHB1dHRpbmcgYSAxeDEgcGl4ZWxcbiAqIGNvbG9yIGluIHRoZSB0ZXh0dXJlIHdlIGNhbiBzdGFydCB1c2luZyB0aGUgdGV4dHVyZSBiZWZvcmVcbiAqIHRoZSBVUkwgaGFzIGxvYWRlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBjb2xvciBBcnJheSBvZiA0IHZhbHVlcyBpbiB0aGUgcmFuZ2UgMCB0byAxXG4gKiBAZGVwcmVjYXRlZCBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLnNldERlZmF1bHRzfVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBzZXREZWZhdWx0VGV4dHVyZUNvbG9yKGNvbG9yKSB7XG4gIGRlZmF1bHRzLnRleHR1cmVDb2xvciA9IG5ldyBVaW50OEFycmF5KFtjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1LCBjb2xvclszXSAqIDI1NV0pO1xufVxuXG5mdW5jdGlvbiBzZXREZWZhdWx0cyhuZXdEZWZhdWx0cykge1xuICBoZWxwZXIuY29weUV4aXN0aW5nUHJvcGVydGllcyhuZXdEZWZhdWx0cywgZGVmYXVsdHMpO1xuXG4gIGlmIChuZXdEZWZhdWx0cy50ZXh0dXJlQ29sb3IpIHtcbiAgICBzZXREZWZhdWx0VGV4dHVyZUNvbG9yKG5ld0RlZmF1bHRzLnRleHR1cmVDb2xvcik7XG4gIH1cbn1cbi8qKlxuICogQSBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgc291cmNlIGZvciBhIHRleHR1cmUuXG4gKiBAY2FsbGJhY2sgVGV4dHVyZUZ1bmNcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyB0aGUgdGV4dHVyZSBvcHRpb25zXG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIGFueSBvZiB0aGUgdGhpbmdzIGRvY3VtZW50ZW50ZWQgZm9yIGBzcmNgIGZvciB7QGxpbmsgbW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBUZXh0dXJlIG9wdGlvbnMgcGFzc2VkIHRvIG1vc3QgdGV4dHVyZSBmdW5jdGlvbnMuIEVhY2ggZnVuY3Rpb24gd2lsbCB1c2Ugd2hhdGV2ZXIgb3B0aW9uc1xuICogYXJlIGFwcHJvcHJpYXRlIGZvciBpdHMgbmVlZHMuIFRoaXMgbGV0cyB5b3UgcGFzcyB0aGUgc2FtZSBvcHRpb25zIHRvIGFsbCBmdW5jdGlvbnMuXG4gKlxuICogTm90ZTogQSBgVGV4SW1hZ2VTb3VyY2VgIGlzIGRlZmluZWQgaW4gdGhlIFdlYkdMIHNwZWMgYXMgYSBgSFRNTEltYWdlRWxlbWVudGAsIGBIVE1MVmlkZW9FbGVtZW50YCxcbiAqIGBIVE1MQ2FudmFzRWxlbWVudGAsIGBJbWFnZUJpdG1hcGAsIG9yIGBJbWFnZURhdGFgLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHR1cmVPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RhcmdldF0gdGhlIHR5cGUgb2YgdGV4dHVyZSBgZ2wuVEVYVFVSRV8yRGAgb3IgYGdsLlRFWFRVUkVfQ1VCRV9NQVBgLiBEZWZhdWx0cyB0byBgZ2wuVEVYVFVSRV8yRGAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xldmVsXSB0aGUgbWlwIGxldmVsIHRvIGFmZmVjdC4gRGVmYXVsdHMgdG8gMC4gTm90ZSwgaWYgc2V0IGF1dG8gd2lsbCBiZSBjb25zaWRlcmVkIGZhbHNlIHVubGVzcyBleHBsaWNpdGx5IHNldCB0byB0cnVlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3aWR0aF0gdGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLiBPbmx5IHVzZWQgaWYgc3JjIGlzIGFuIGFycmF5IG9yIHR5cGVkIGFycmF5IG9yIG51bGwuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hlaWdodF0gdGhlIGhlaWdodCBvZiBhIHRleHR1cmUuIE9ubHkgdXNlZCBpZiBzcmMgaXMgYW4gYXJyYXkgb3IgdHlwZWQgYXJyYXkgb3IgbnVsbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVwdGhdIHRoZSBkZXB0aCBvZiBhIHRleHR1cmUuIE9ubHkgdXNlZCBpZiBzcmMgaXMgYW4gYXJyYXkgb3IgdHlwZSBhcnJheSBvciBudWxsIGFuZCB0YXJnZXQgaXMgYFRFWFRVUkVfM0RgIC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluXSB0aGUgbWluIGZpbHRlciBzZXR0aW5nIChlZy4gYGdsLkxJTkVBUmApLiBEZWZhdWx0cyB0byBgZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSYFxuICogICAgIG9yIGlmIHRleHR1cmUgaXMgbm90IGEgcG93ZXIgb2YgMiBvbiBib3RoIGRpbWVuc2lvbnMgdGhlbiBkZWZhdWx0cyB0byBgZ2wuTElORUFSYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWFnXSB0aGUgbWFnIGZpbHRlciBzZXR0aW5nIChlZy4gYGdsLkxJTkVBUmApLiBEZWZhdWx0cyB0byBgZ2wuTElORUFSYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5NYWddIGJvdGggdGhlIG1pbiBhbmQgbWFnIGZpbHRlciBzZXR0aW5ncy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaW50ZXJuYWxGb3JtYXRdIGludGVybmFsIGZvcm1hdCBmb3IgdGV4dHVyZS4gRGVmYXVsdHMgdG8gYGdsLlJHQkFgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2Zvcm1hdF0gZm9ybWF0IGZvciB0ZXh0dXJlLiBEZWZhdWx0cyB0byBgZ2wuUkdCQWAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3R5cGVdIHR5cGUgZm9yIHRleHR1cmUuIERlZmF1bHRzIHRvIGBnbC5VTlNJR05FRF9CWVRFYCB1bmxlc3MgYHNyY2AgaXMgQXJyYXlCdWZmZXJWaWV3LiBJZiBgc3JjYFxuICogICAgIGlzIEFycmF5QnVmZmVyVmlldyBkZWZhdWx0cyB0byB0eXBlIHRoYXQgbWF0Y2hlcyBBcnJheUJ1ZmZlclZpZXcgdHlwZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd3JhcF0gVGV4dHVyZSB3cmFwcGluZyBmb3IgYm90aCBTIGFuZCBUIChhbmQgUiBpZiBURVhUVVJFXzNEIG9yIFdlYkdMU2FtcGxlcikuIERlZmF1bHRzIHRvIGBnbC5SRVBFQVRgIGZvciAyRCB1bmxlc3Mgc3JjIGlzIFdlYkdMMSBhbmQgc3JjIG5vdCBucG90IGFuZCBgZ2wuQ0xBTVBfVE9fRURHRWAgZm9yIGN1YmVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd3JhcFNdIFRleHR1cmUgd3JhcHBpbmcgZm9yIFMuIERlZmF1bHRzIHRvIGBnbC5SRVBFQVRgIGFuZCBgZ2wuQ0xBTVBfVE9fRURHRWAgZm9yIGN1YmUuIElmIHNldCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYHdyYXBgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3cmFwVF0gVGV4dHVyZSB3cmFwcGluZyBmb3IgVC4gRGVmYXVsdHMgdG8gYGdsLlJFUEVBVGAgYW5kIGBnbC5DTEFNUF9UT19FREdFYCBmb3IgY3ViZS4gSWYgc2V0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgd3JhcGAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dyYXBSXSBUZXh0dXJlIHdyYXBwaW5nIGZvciBSLiBEZWZhdWx0cyB0byBgZ2wuUkVQRUFUYCBhbmQgYGdsLkNMQU1QX1RPX0VER0VgIGZvciBjdWJlLiBJZiBzZXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGB3cmFwYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluTG9kXSBURVhUVVJFX01JTl9MT0Qgc2V0dGluZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhMb2RdIFRFWFRVUkVfTUFYX0xPRCBzZXR0aW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2Jhc2VMZXZlbF0gVEVYVFVSRV9CQVNFX0xFVkVMIHNldHRpbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4TGV2ZWxdIFRFWFRVUkVfTUFYX0xFVkVMIHNldHRpbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdW5wYWNrQWxpZ25tZW50XSBUaGUgYGdsLlVOUEFDS19BTElHTk1FTlRgIHVzZWQgd2hlbiB1cGxvYWRpbmcgYW4gYXJyYXkuIERlZmF1bHRzIHRvIDEuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3ByZW11bHRpcGx5QWxwaGFdIFdoZXRoZXIgb3Igbm90IHRvIHByZW11bHRpcGx5IGFscGhhLiBEZWZhdWx0cyB0byB3aGF0ZXZlciB0aGUgY3VycmVudCBzZXR0aW5nIGlzLlxuICogICAgIFRoaXMgbGV0cyB5b3Ugc2V0IGl0IG9uY2UgYmVmb3JlIGNhbGxpbmcgYHR3Z2wuY3JlYXRlVGV4dHVyZWAgb3IgYHR3Z2wuY3JlYXRlVGV4dHVyZXNgIGFuZCBvbmx5IG92ZXJyaWRlXG4gKiAgICAgdGhlIGN1cnJlbnQgc2V0dGluZyBmb3Igc3BlY2lmaWMgdGV4dHVyZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZsaXBZXSBXaGV0aGVyIG9yIG5vdCB0byBmbGlwIHRoZSB0ZXh0dXJlIHZlcnRpY2FsbHkgb24gdXBsb2FkLiBEZWZhdWx0cyB0byB3aGF0ZXZlciB0aGUgY3VycmVudCBzZXR0aW5nIGlzLlxuICogICAgIFRoaXMgbGV0cyB5b3Ugc2V0IGl0IG9uY2UgYmVmb3JlIGNhbGxpbmcgYHR3Z2wuY3JlYXRlVGV4dHVyZWAgb3IgYHR3Z2wuY3JlYXRlVGV4dHVyZXNgIGFuZCBvbmx5IG92ZXJyaWRlXG4gKiAgICAgdGhlIGN1cnJlbnQgc2V0dGluZyBmb3Igc3BlY2lmaWMgdGV4dHVyZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NvbG9yc3BhY2VDb252ZXJzaW9uXSBXaGV0aGVyIG9yIG5vdCB0byBsZXQgdGhlIGJyb3dzZXIgZG8gY29sb3JzcGFjZSBjb252ZXJzaW9uIG9mIHRoZSB0ZXh0dXJlIG9uIHVwbG9hZC4gRGVmYXVsdHMgdG8gd2hhdGV2ZXIgdGhlIGN1cnJlbnQgc2V0dGluZyBpcy5cbiAqICAgICBUaGlzIGxldHMgeW91IHNldCBpdCBvbmNlIGJlZm9yZSBjYWxsaW5nIGB0d2dsLmNyZWF0ZVRleHR1cmVgIG9yIGB0d2dsLmNyZWF0ZVRleHR1cmVzYCBhbmQgb25seSBvdmVycmlkZVxuICogICAgIHRoZSBjdXJyZW50IHNldHRpbmcgZm9yIHNwZWNpZmljIHRleHR1cmVzLlxuICogQHByb3BlcnR5IHsobnVtYmVyW118QXJyYXlCdWZmZXJWaWV3KX0gY29sb3IgY29sb3IgdXNlZCBhcyB0ZW1wb3JhcnkgMXgxIHBpeGVsIGNvbG9yIGZvciB0ZXh0dXJlcyBsb2FkZWQgYXN5bmMgd2hlbiBzcmMgaXMgYSBzdHJpbmcuXG4gKiAgICBJZiBpdCdzIGEgSmF2YVNjcmlwdCBhcnJheSBhc3N1bWVzIGNvbG9yIGlzIDAgdG8gMSBsaWtlIG1vc3QgR0wgY29sb3JzIGFzIGluIGBbMSwgMCwgMCwgMV0gPSByZWQ9MSwgZ3JlZW49MCwgYmx1ZT0wLCBhbHBoYT0wYC5cbiAqICAgIERlZmF1bHRzIHRvIGBbMC41LCAwLjc1LCAxLCAxXWAuIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0RGVmYXVsdFRleHR1cmVDb2xvcn0uIElmIGBmYWxzZWAgdGV4dHVyZSBpcyBzZXQuIENhbiBiZSB1c2VkIHRvIHJlLWxvYWQgYSB0ZXh0dXJlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdXRvXSBJZiBgdW5kZWZpbmVkYCBvciBgdHJ1ZWAsIGluIFdlYkdMMSwgdGV4dHVyZSBmaWx0ZXJpbmcgaXMgc2V0IGF1dG9tYXRpY2FsbHkgZm9yIG5vbi1wb3dlciBvZiAyIGltYWdlcyBhbmRcbiAqICAgIG1pcHMgYXJlIGdlbmVyYXRlZCBmb3IgcG93ZXIgb2YgMiBpbWFnZXMuIEluIFdlYkdMMiBtaXBzIGFyZSBnZW5lcmF0ZWQgaWYgdGhleSBjYW4gYmUuIE5vdGU6IGlmIGBsZXZlbGAgaXMgc2V0IGFib3ZlXG4gKiAgICB0aGVuIHRoZW4gYGF1dG9gIGlzIGFzc3VtZWQgdG8gYmUgYGZhbHNlYCB1bmxlc3MgZXhwbGljaXR5IHNldCB0byBgdHJ1ZWAuXG4gKiBAcHJvcGVydHkge251bWJlcltdfSBbY3ViZUZhY2VPcmRlcl0gVGhlIG9yZGVyIHRoYXQgY3ViZSBmYWNlcyBhcmUgcHVsbGVkIG91dCBvZiBhbiBpbWcgb3Igc2V0IG9mIGltYWdlcy4gVGhlIGRlZmF1bHQgaXNcbiAqXG4gKiAgICAgW2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCxcbiAqICAgICAgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLFxuICogICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ksXG4gKiAgICAgIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSxcbiAqICAgICAgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aLFxuICogICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1pdXG4gKlxuICogQHByb3BlcnR5IHsobnVtYmVyW118QXJyYXlCdWZmZXJWaWV3fFRleEltYWdlU291cmNlfFRleEltYWdlU291cmNlW118c3RyaW5nfHN0cmluZ1tdfG1vZHVsZTp0d2dsLlRleHR1cmVGdW5jKX0gW3NyY10gc291cmNlIGZvciB0ZXh0dXJlXG4gKlxuICogICAgSWYgYHN0cmluZ2AgdGhlbiBpdCdzIGFzc3VtZWQgdG8gYmUgYSBVUkwgdG8gYW4gaW1hZ2UuIFRoZSBpbWFnZSB3aWxsIGJlIGRvd25sb2FkZWQgYXN5bmMuIEEgdXNhYmxlXG4gKiAgICAxeDEgcGl4ZWwgdGV4dHVyZSB3aWxsIGJlIHJldHVybmVkIGltbWVkaWF0bGV5LiBUaGUgdGV4dHVyZSB3aWxsIGJlIHVwZGF0ZWQgb25jZSB0aGUgaW1hZ2UgaGFzIGRvd25sb2FkZWQuXG4gKiAgICBJZiBgdGFyZ2V0YCBpcyBgZ2wuVEVYVFVSRV9DVUJFX01BUGAgd2lsbCBhdHRlbXB0IHRvIGRpdmlkZSBpbWFnZSBpbnRvIDYgc3F1YXJlIHBpZWNlcy4gMXg2LCA2eDEsIDN4MiwgMngzLlxuICogICAgVGhlIHBpZWNlcyB3aWxsIGJlIHVwbG9hZGVkIGluIGBjdWJlRmFjZU9yZGVyYFxuICpcbiAqICAgIElmIGBzdHJpbmdbXWAgb3IgYFRleEltYWdlU291cmNlW11gIGFuZCB0YXJnZXQgaXMgYGdsLlRFWFRVUkVfQ1VCRV9NQVBgIHRoZW4gaXQgbXVzdCBoYXZlIDYgZW50cmllcywgb25lIGZvciBlYWNoIGZhY2Ugb2YgYSBjdWJlIG1hcC5cbiAqXG4gKiAgICBJZiBgc3RyaW5nW11gIG9yIGBUZXhJbWFnZVNvdXJjZVtdYCBhbmQgdGFyZ2V0IGlzIGBnbC5URVhUVVJFXzJEX0FSUkFZYCB0aGVuIGVhY3QgZW50cnkgaXMgYSBzbGljZSBvZiB0aGUgYSAyZCBhcnJheSB0ZXh0dXJlXG4gKiAgICBhbmQgd2lsbCBiZSBzY2FsZWQgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0IE9SIHRvIHRoZSBzaXplIG9mIHRoZSBmaXJzdCBpbWFnZSB0aGF0IGxvYWRzLlxuICpcbiAqICAgIElmIGBUZXhJbWFnZVNvdXJjZWAgdGhlbiBpdCB3aWwgYmUgdXNlZCBpbW1lZGlhdGVseSB0byBjcmVhdGUgdGhlIGNvbnRlbnRzIG9mIHRoZSB0ZXh0dXJlLiBFeGFtcGxlcyBgSFRNTEltYWdlRWxlbWVudGAsXG4gKiAgICBgSFRNTENhbnZhc0VsZW1lbnRgLCBgSFRNTFZpZGVvRWxlbWVudGAuXG4gKlxuICogICAgSWYgYG51bWJlcltdYCBvciBgQXJyYXlCdWZmZXJWaWV3YCBpdCdzIGFzc3VtZWQgdG8gYmUgZGF0YSBmb3IgYSB0ZXh0dXJlLiBJZiBgd2lkdGhgIG9yIGBoZWlnaHRgIGlzXG4gKiAgICBub3Qgc3BlY2lmaWVkIGl0IGlzIGd1ZXNzZWQgYXMgZm9sbG93cy4gRmlyc3QgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpcyBjb21wdXRlZCBieSBgc3JjLmxlbmd0aCAvIG51bUNvbXBvbmVudHNgXG4gKiAgICB3aGVyZSBgbnVtQ29tcG9uZW50c2AgaXMgZGVyaXZlZCBmcm9tIGBmb3JtYXRgLiBJZiBgdGFyZ2V0YCBpcyBgZ2wuVEVYVFVSRV9DVUJFX01BUGAgdGhlbiBgbnVtRWxlbWVudHNgIGlzIGRpdmlkZWRcbiAqICAgIGJ5IDYuIFRoZW5cbiAqXG4gKiAgICAqICAgSWYgbmVpdGhlciBgd2lkdGhgIG5vciBgaGVpZ2h0YCBhcmUgc3BlY2lmaWVkIGFuZCBgc3FydChudW1FbGVtZW50cylgIGlzIGFuIGludGVnZXIgdGhlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gKiAgICAgICAgYXJlIHNldCB0byBgc3FydChudW1FbGVtZW50cylgLiBPdGhlcndpc2UgYHdpZHRoID0gbnVtRWxlbWVudHNgIGFuZCBgaGVpZ2h0ID0gMWAuXG4gKlxuICogICAgKiAgIElmIG9ubHkgb25lIG9mIGB3aWR0aGAgb3IgYGhlaWdodGAgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIG90aGVyIGVxdWFscyBgbnVtRWxlbWVudHMgLyBzcGVjaWZpZWREaW1lbnNpb25gLlxuICpcbiAqIElmIGBudW1iZXJbXWAgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYHR5cGVgLlxuICpcbiAqIElmIGBzcmNgIGlzIGEgZnVuY3Rpb24gaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIGBXZWJHTFJlbmRlcmluZ0NvbnRleHRgIGFuZCB0aGVzZSBvcHRpb25zLlxuICogV2hhdGV2ZXIgaXQgcmV0dXJucyBpcyBzdWJqZWN0IHRvIHRoZXNlIHJ1bGVzLiBTbyBpdCBjYW4gcmV0dXJuIGEgc3RyaW5nIHVybCwgYW4gYEhUTUxFbGVtZW50YFxuICogYW4gYXJyYXkgZXRjLi4uXG4gKlxuICogSWYgYHNyY2AgaXMgdW5kZWZpbmVkIHRoZW4gYW4gZW1wdHkgdGV4dHVyZSB3aWxsIGJlIGNyZWF0ZWQgb2Ygc2l6ZSBgd2lkdGhgIGJ5IGBoZWlnaHRgLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY3Jvc3NPcmlnaW5dIFdoYXQgdG8gc2V0IHRoZSBjcm9zc09yaWdpbiBwcm9wZXJ0eSBvZiBpbWFnZXMgd2hlbiB0aGV5IGFyZSBkb3dubG9hZGVkLlxuICogICAgZGVmYXVsdDogdW5kZWZpbmVkLiBBbHNvIHNlZSB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0RGVmYXVsdHN9LlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG4vLyBOT1RFOiBXaGlsZSBxdWVyeWluZyBHTCBpcyBjb25zaWRlcmVkIHNsb3cgaXQncyBub3QgcmVtb3RlbHkgYXMgc2xvd1xuLy8gYXMgdXBsb2FkaW5nIGEgdGV4dHVyZS4gT24gdG9wIG9mIHRoYXQgeW91J3JlIHVubGlrZWx5IHRvIGNhbGwgdGhpcyBpblxuLy8gYSBwZXJmIGNyaXRpY2FsIGxvb3AuIEV2ZW4gaWYgdXBsb2FkIGEgdGV4dHVyZSBldmVyeSBmcmFtZSB0aGF0J3MgdW5saWtlbHlcbi8vIHRvIGJlIG1vcmUgdGhhbiAxIG9yIDIgdGV4dHVyZXMgYSBmcmFtZS4gSW4gb3RoZXIgd29yZHMsIHRoZSBiZW5lZml0cyBvZlxuLy8gbWFraW5nIHRoZSBBUEkgZWFzeSB0byB1c2Ugb3V0d2VpZ2ggYW55IHN1cHBvc2VkIHBlcmYgYmVuZWZpdHNcbi8vXG4vLyBBbHNvIG5vdGUgSSBnZXQgdGhhdCBoYXZpbmcgb25lIGdsb2JhbCBvZiB0aGVzZSBpcyBiYWQgcHJhY3RpY2UuXG4vLyBBcyBsb25nIGFzIGl0J3MgdXNlZCBjb3JyZWN0bHkgaXQgbWVhbnMgbm8gZ2FyYmFnZSB3aGljaCBwcm9iYWJseVxuLy8gZG9lc24ndCBtYXR0ZXIgd2hlbiBkZWFsaW5nIHdpdGggdGV4dHVyZXMgYnV0IG9sZCBoYWJpdHMgZGllIGhhcmQuXG5cblxudmFyIGxhc3RQYWNrU3RhdGUgPSB7fTtcbi8qKlxuICogU2F2ZXMgYW55IHBhY2tpbmcgc3RhdGUgdGhhdCB3aWxsIGJlIHNldCBiYXNlZCBvbiB0aGUgb3B0aW9ucy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKi9cblxuZnVuY3Rpb24gc2F2ZVBhY2tTdGF0ZShnbCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5jb2xvcnNwYWNlQ29udmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGFzdFBhY2tTdGF0ZS5jb2xvcnNwYWNlQ29udmVyc2lvbiA9IGdsLmdldFBhcmFtZXRlcihnbC5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBvcHRpb25zLmNvbG9yc3BhY2VDb252ZXJzaW9uKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnByZW11bHRpcGx5QWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgIGxhc3RQYWNrU3RhdGUucHJlbXVsdGlwbHlBbHBoYSA9IGdsLmdldFBhcmFtZXRlcihnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgb3B0aW9ucy5wcmVtdWx0aXBseUFscGhhKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmZsaXBZICE9PSB1bmRlZmluZWQpIHtcbiAgICBsYXN0UGFja1N0YXRlLmZsaXBZID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlVOUEFDS19GTElQX1lfV0VCR0wpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIG9wdGlvbnMuZmxpcFkpO1xuICB9XG59XG4vKipcbiAqIFJlc3RvcmVzIGFueSBwYWNraW5nIHN0YXRlIHRoYXQgd2FzIHNldCBiYXNlZCBvbiB0aGUgb3B0aW9ucy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKi9cblxuXG5mdW5jdGlvbiByZXN0b3JlUGFja1N0YXRlKGdsLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmNvbG9yc3BhY2VDb252ZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBsYXN0UGFja1N0YXRlLmNvbG9yc3BhY2VDb252ZXJzaW9uKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnByZW11bHRpcGx5QWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgbGFzdFBhY2tTdGF0ZS5wcmVtdWx0aXBseUFscGhhKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmZsaXBZICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBsYXN0UGFja1N0YXRlLmZsaXBZKTtcbiAgfVxufVxuLyoqXG4gKiBTYXZlcyBzdGF0ZSByZWxhdGVkIHRvIGRhdGEgc2l6ZVxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmVTa2lwU3RhdGUoZ2wpIHtcbiAgbGFzdFBhY2tTdGF0ZS51bnBhY2tBbGlnbm1lbnQgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuVU5QQUNLX0FMSUdOTUVOVCk7XG5cbiAgaWYgKHV0aWxzLmlzV2ViR0wyKGdsKSkge1xuICAgIGxhc3RQYWNrU3RhdGUudW5wYWNrUm93TGVuZ3RoID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlVOUEFDS19ST1dfTEVOR1RIKTtcbiAgICBsYXN0UGFja1N0YXRlLnVucGFja0ltYWdlSGVpZ2h0ID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlVOUEFDS19JTUFHRV9IRUlHSFQpO1xuICAgIGxhc3RQYWNrU3RhdGUudW5wYWNrU2tpcFBpeGVscyA9IGdsLmdldFBhcmFtZXRlcihnbC5VTlBBQ0tfU0tJUF9QSVhFTFMpO1xuICAgIGxhc3RQYWNrU3RhdGUudW5wYWNrU2tpcFJvd3MgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuVU5QQUNLX1NLSVBfUk9XUyk7XG4gICAgbGFzdFBhY2tTdGF0ZS51bnBhY2tTa2lwSW1hZ2VzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlVOUEFDS19TS0lQX0lNQUdFUyk7XG4gIH1cbn1cbi8qKlxuICogUmVzdG9yZXMgc3RhdGUgcmVsYXRlZCB0byBkYXRhIHNpemVcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKi9cblxuXG5mdW5jdGlvbiByZXN0b3JlU2tpcFN0YXRlKGdsKSB7XG4gIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19BTElHTk1FTlQsIGxhc3RQYWNrU3RhdGUudW5wYWNrQWxpZ25tZW50KTtcblxuICBpZiAodXRpbHMuaXNXZWJHTDIoZ2wpKSB7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1JPV19MRU5HVEgsIGxhc3RQYWNrU3RhdGUudW5wYWNrUm93TGVuZ3RoKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfSU1BR0VfSEVJR0hULCBsYXN0UGFja1N0YXRlLnVucGFja0ltYWdlSGVpZ2h0KTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfU0tJUF9QSVhFTFMsIGxhc3RQYWNrU3RhdGUudW5wYWNrU2tpcFBpeGVscyk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1NLSVBfUk9XUywgbGFzdFBhY2tTdGF0ZS51bnBhY2tTa2lwUm93cyk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1NLSVBfSU1BR0VTLCBsYXN0UGFja1N0YXRlLnVucGFja1NraXBJbWFnZXMpO1xuICB9XG59XG4vKipcbiAqIFNldHMgdGhlIHBhcmFtZXRlcnMgb2YgYSB0ZXh0dXJlIG9yIHNhbXBsZXJcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcnxXZWJHTFNhbXBsZXJ9IHRhcmdldCB0ZXh0dXJlIHRhcmdldCBvciBzYW1wbGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IHBhcmFtZXRlcmlGbiB0ZXhQYXJhbXRlcmkgb3Igc2FtcGxlclBhcmFtZXRlcmkgZm5cbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIFdlYkdMVGV4dHVyZSB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqICAgVGhpcyBpcyBvZnRlbiB0aGUgc2FtZSBvcHRpb25zIHlvdSBwYXNzZWQgaW4gd2hlbiB5b3UgY3JlYXRlZCB0aGUgdGV4dHVyZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRleHR1cmVTYW1wbGVyUGFyYW1ldGVycyhnbCwgdGFyZ2V0LCBwYXJhbWV0ZXJpRm4sIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMubWluTWFnKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBvcHRpb25zLm1pbk1hZyk7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBvcHRpb25zLm1pbk1hZyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5taW4pIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBnbC5URVhUVVJFX01JTl9GSUxURVIsIG9wdGlvbnMubWluKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm1hZykge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgb3B0aW9ucy5tYWcpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMud3JhcCkge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9TLCBvcHRpb25zLndyYXApO1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9ULCBvcHRpb25zLndyYXApO1xuXG4gICAgaWYgKHRhcmdldCA9PT0gZ2wuVEVYVFVSRV8zRCB8fCBoZWxwZXIuaXNTYW1wbGVyKGdsLCB0YXJnZXQpKSB7XG4gICAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfUiwgb3B0aW9ucy53cmFwKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy53cmFwUikge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9SLCBvcHRpb25zLndyYXBSKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLndyYXBTKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgZ2wuVEVYVFVSRV9XUkFQX1MsIG9wdGlvbnMud3JhcFMpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMud3JhcFQpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfVCwgb3B0aW9ucy53cmFwVCk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5taW5Mb2QpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBnbC5URVhUVVJFX01JTl9MT0QsIG9wdGlvbnMubWluTG9kKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm1heExvZCkge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIGdsLlRFWFRVUkVfTUFYX0xPRCwgb3B0aW9ucy5tYXhMb2QpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYmFzZUxldmVsKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgZ2wuVEVYVFVSRV9CQVNFX0xFVkVMLCBvcHRpb25zLmJhc2VMZXZlbCk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5tYXhMZXZlbCkge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIGdsLlRFWFRVUkVfTUFYX0xFVkVMLCBvcHRpb25zLm1heExldmVsKTtcbiAgfVxufVxuLyoqXG4gKiBTZXRzIHRoZSB0ZXh0dXJlIHBhcmFtZXRlcnMgb2YgYSB0ZXh0dXJlLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIFdlYkdMVGV4dHVyZSB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqICAgVGhpcyBpcyBvZnRlbiB0aGUgc2FtZSBvcHRpb25zIHlvdSBwYXNzZWQgaW4gd2hlbiB5b3UgY3JlYXRlZCB0aGUgdGV4dHVyZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gc2V0VGV4dHVyZVBhcmFtZXRlcnMoZ2wsIHRleCwgb3B0aW9ucykge1xuICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgZ2wuVEVYVFVSRV8yRDtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuICBzZXRUZXh0dXJlU2FtcGxlclBhcmFtZXRlcnMoZ2wsIHRhcmdldCwgZ2wudGV4UGFyYW1ldGVyaSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIFNldHMgdGhlIHNhbXBsZXIgcGFyYW1ldGVycyBvZiBhIHNhbXBsZXIuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFNhbXBsZXJ9IHNhbXBsZXIgdGhlIFdlYkdMU2FtcGxlciB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gc2V0U2FtcGxlclBhcmFtZXRlcnMoZ2wsIHNhbXBsZXIsIG9wdGlvbnMpIHtcbiAgc2V0VGV4dHVyZVNhbXBsZXJQYXJhbWV0ZXJzKGdsLCBzYW1wbGVyLCBnbC5zYW1wbGVyUGFyYW1ldGVyaSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc2FtcGxlciBvYmplY3QgYW5kIHNldHMgcGFyYW1ldGVycy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgY29uc3Qgc2FtcGxlciA9IHR3Z2wuY3JlYXRlU2FtcGxlcihnbCwge1xuICogICAgICAgIG1pbk1hZzogZ2wuTkVBUkVTVCwgICAgICAgICAvLyBzZXRzIGJvdGggVEVYVFVSRV9NSU5fRklMVEVSIGFuZCBURVhUVVJFX01BR19GSUxURVJcbiAqICAgICAgICB3cmFwOiBnbC5DTEFNUF9UT19ORUFSRVNULCAgLy8gc2V0cyBib3RoIFRFWFRVUkVfV1JBUF9TIGFuZCBURVhUVVJFX1dSQVBfVCBhbmQgVEVYVFVSRV9XUkFQX1JcbiAqICAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsbW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnM+fSBvcHRpb25zIEEgb2JqZWN0IG9mIFRleHR1cmVPcHRpb25zIG9uZSBwZXIgc2FtcGxlci5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLFdlYkdMU2FtcGxlcj59IHRoZSBjcmVhdGVkIHNhbXBsZXJzIGJ5IG5hbWVcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNhbXBsZXIoZ2wsIG9wdGlvbnMpIHtcbiAgdmFyIHNhbXBsZXIgPSBnbC5jcmVhdGVTYW1wbGVyKCk7XG4gIHNldFNhbXBsZXJQYXJhbWV0ZXJzKGdsLCBzYW1wbGVyLCBvcHRpb25zKTtcbiAgcmV0dXJuIHNhbXBsZXI7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtdWx0aXBsZSBzYW1wbGVyIG9iamVjdHMgYW5kIHNldHMgcGFyYW1ldGVycyBvbiBlYWNoLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICBjb25zdCBzYW1wbGVycyA9IHR3Z2wuY3JlYXRlU2FtcGxlcnMoZ2wsIHtcbiAqICAgICAgICBuZWFyZXN0OiB7XG4gKiAgICAgICAgICBtaW5NYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBuZWFyZXN0Q2xhbXBTOiB7XG4gKiAgICAgICAgICBtaW5NYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgICB3cmFwUzogZ2wuQ0xBTVBfVE9fTkVBUkVTVCxcbiAqICAgICAgICB9LFxuICogICAgICAgIGxpbmVhcjoge1xuICogICAgICAgICAgbWluTWFnOiBnbC5MSU5FQVIsXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBuZWFyZXN0Q2xhbXA6IHtcbiAqICAgICAgICAgIG1pbk1hZzogZ2wuTkVBUkVTVCxcbiAqICAgICAgICAgIHdyYXA6IGdsLkNMQU1QX1RPX0VER0UsXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBsaW5lYXJDbGFtcDoge1xuICogICAgICAgICAgbWluTWFnOiBnbC5MSU5FQVIsXG4gKiAgICAgICAgICB3cmFwOiBnbC5DTEFNUF9UT19FREdFLFxuICogICAgICAgIH0sXG4gKiAgICAgICAgbGluZWFyQ2xhbXBUOiB7XG4gKiAgICAgICAgICBtaW5NYWc6IGdsLkxJTkVBUixcbiAqICAgICAgICAgIHdyYXBUOiBnbC5DTEFNUF9UT19FREdFLFxuICogICAgICAgIH0sXG4gKiAgICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldCBvbiB0aGUgc2FtcGxlclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlU2FtcGxlcnMoZ2wsIHNhbXBsZXJPcHRpb25zKSB7XG4gIHZhciBzYW1wbGVycyA9IHt9O1xuICBPYmplY3Qua2V5cyhzYW1wbGVyT3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHNhbXBsZXJzW25hbWVdID0gY3JlYXRlU2FtcGxlcihnbCwgc2FtcGxlck9wdGlvbnNbbmFtZV0pO1xuICB9KTtcbiAgcmV0dXJuIHNhbXBsZXJzO1xufVxuLyoqXG4gKiBNYWtlcyBhIDF4MSBwaXhlbFxuICogSWYgbm8gY29sb3IgaXMgcGFzc2VkIGluIHVzZXMgdGhlIGRlZmF1bHQgY29sb3Igd2hpY2ggY2FuIGJlIHNldCBieSBjYWxsaW5nIGBzZXREZWZhdWx0VGV4dHVyZUNvbG9yYC5cbiAqIEBwYXJhbSB7KG51bWJlcltdfEFycmF5QnVmZmVyVmlldyl9IFtjb2xvcl0gVGhlIGNvbG9yIHVzaW5nIDAtMSB2YWx1ZXNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IFVuaXQ4QXJyYXkgd2l0aCBjb2xvci5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1ha2UxUGl4ZWwoY29sb3IpIHtcbiAgY29sb3IgPSBjb2xvciB8fCBkZWZhdWx0cy50ZXh0dXJlQ29sb3I7XG5cbiAgaWYgKGlzQXJyYXlCdWZmZXIoY29sb3IpKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1LCBjb2xvclszXSAqIDI1NV0pO1xufVxuLyoqXG4gKiBTZXRzIGZpbHRlcmluZyBvciBnZW5lcmF0ZXMgbWlwcyBmb3IgdGV4dHVyZSBiYXNlZCBvbiB3aWR0aCBvciBoZWlnaHRcbiAqIElmIHdpZHRoIG9yIGhlaWdodCBpcyBub3QgcGFzc2VkIGluIHVzZXMgYG9wdGlvbnMud2lkdGhgIGFuZC8vb3IgYG9wdGlvbnMuaGVpZ2h0YFxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqICAgVGhpcyBpcyBvZnRlbiB0aGUgc2FtZSBvcHRpb25zIHlvdSBwYXNzZWQgaW4gd2hlbiB5b3UgY3JlYXRlZCB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIHdpZHRoIG9mIHRleHR1cmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSBoZWlnaHQgb2YgdGV4dHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbnRlcm5hbEZvcm1hdF0gVGhlIGludGVybmFsRm9ybWF0IHBhcmFtZXRlciBmcm9tIHRleEltYWdlMkQgZXRjLi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbdHlwZV0gVGhlIHR5cGUgcGFyYW1ldGVyIGZvciB0ZXhJbWFnZTJEIGV0Yy4uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKGdsLCB0ZXgsIG9wdGlvbnMsIHdpZHRoLCBoZWlnaHQsIGludGVybmFsRm9ybWF0LCB0eXBlKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzLnRleHR1cmVPcHRpb25zO1xuICBpbnRlcm5hbEZvcm1hdCA9IGludGVybmFsRm9ybWF0IHx8IGdsLlJHQkE7XG4gIHR5cGUgPSB0eXBlIHx8IGdsLlVOU0lHTkVEX0JZVEU7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBnbC5URVhUVVJFXzJEO1xuICB3aWR0aCA9IHdpZHRoIHx8IG9wdGlvbnMud2lkdGg7XG4gIGhlaWdodCA9IGhlaWdodCB8fCBvcHRpb25zLmhlaWdodDtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuXG4gIGlmIChjYW5HZW5lcmF0ZU1pcG1hcChnbCwgd2lkdGgsIGhlaWdodCwgaW50ZXJuYWxGb3JtYXQsIHR5cGUpKSB7XG4gICAgZ2wuZ2VuZXJhdGVNaXBtYXAodGFyZ2V0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmlsdGVyaW5nID0gY2FuRmlsdGVyKGludGVybmFsRm9ybWF0LCB0eXBlKSA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1Q7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyaW5nKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJpbmcpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRBdXRvbWF0aWNhbGx5U2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5hdXRvID09PSB0cnVlIHx8IG9wdGlvbnMuYXV0byA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMubGV2ZWwgPT09IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogR2V0cyBhbiBhcnJheSBvZiBjdWJlbWFwIGZhY2UgZW51bXNcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiAgIFRoaXMgaXMgb2Z0ZW4gdGhlIHNhbWUgb3B0aW9ucyB5b3UgcGFzc2VkIGluIHdoZW4geW91IGNyZWF0ZWQgdGhlIHRleHR1cmUuXG4gKiBAcmV0dXJuIHtudW1iZXJbXX0gY3ViZW1hcCBmYWNlIGVudW1zXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDdWJlRmFjZU9yZGVyKGdsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICByZXR1cm4gb3B0aW9ucy5jdWJlRmFjZU9yZGVyIHx8IFtnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZLCBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ksIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWiwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aXTtcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRmFjZUluZm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmYWNlIGdsIGVudW0gZm9yIHRleEltYWdlMkRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZHggZmFjZSBpbmRleCAoMCAtIDUpIGludG8gc291cmNlIGRhdGFcbiAqIEBpZ25vcmVcbiAqL1xuXG4vKipcbiAqIEdldHMgYW4gYXJyYXkgb2YgRmFjZUluZm9zXG4gKiBUaGVyZSdzIGEgYnVnIGluIHNvbWUgTlZpZGlhIGRyaXZlcnMgdGhhdCB3aWxsIGNyYXNoIHRoZSBkcml2ZXIgaWZcbiAqIGBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1hgIGlzIG5vdCB1cGxvYWRlZCBmaXJzdC4gU28sIHdlIHRha2VcbiAqIHRoZSB1c2VyJ3MgZGVzaXJlZCBvcmRlciBmcm9tIGhpcyBmYWNlcyB0byBXZWJHTCBhbmQgbWFrZSBzdXJlIHdlXG4gKiBkbyB0aGUgZmFjZXMgaW4gV2ViR0wgb3JkZXJcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogQHJldHVybiB7RmFjZUluZm9bXX0gY3ViZW1hcCBmYWNlIGluZm9zLiBBcmd1YWJseSB0aGUgYGZhY2VgIHByb3BlcnR5IG9mIGVhY2ggZWxlbWVudCBpcyByZWR1bmRlbnQgYnV0XG4gKiAgICBpdCdzIG5lZWRlZCBpbnRlcm5hbGx5IHRvIHNvcnQgdGhlIGFycmF5IG9mIGBuZHhgIHByb3BlcnRpZXMgYnkgYGZhY2VgLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q3ViZUZhY2VzV2l0aE5keChnbCwgb3B0aW9ucykge1xuICB2YXIgZmFjZXMgPSBnZXRDdWJlRmFjZU9yZGVyKGdsLCBvcHRpb25zKTsgLy8gd29yayBhcm91bmQgYnVnIGluIE5WaWRpYSBkcml2ZXJzLiBXZSBoYXZlIHRvIHVwbG9hZCB0aGUgZmlyc3QgZmFjZSBmaXJzdCBlbHNlIHRoZSBkcml2ZXIgY3Jhc2hlcyA6KFxuXG4gIHZhciBmYWNlc1dpdGhOZHggPSBmYWNlcy5tYXAoZnVuY3Rpb24gKGZhY2UsIG5keCkge1xuICAgIHJldHVybiB7XG4gICAgICBmYWNlOiBmYWNlLFxuICAgICAgbmR4OiBuZHhcbiAgICB9O1xuICB9KTtcbiAgZmFjZXNXaXRoTmR4LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mYWNlIC0gYi5mYWNlO1xuICB9KTtcbiAgcmV0dXJuIGZhY2VzV2l0aE5keDtcbn1cbi8qKlxuICogU2V0IGEgdGV4dHVyZSBmcm9tIHRoZSBjb250ZW50cyBvZiBhbiBlbGVtZW50LiBXaWxsIGFsc28gc2V0XG4gKiB0ZXh0dXJlIGZpbHRlcmluZyBvciBnZW5lcmF0ZSBtaXBzIGJhc2VkIG9uIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBlbGVtZW50XG4gKiB1bmxlc3MgYG9wdGlvbnMuYXV0byA9PT0gZmFsc2VgLiBJZiBgdGFyZ2V0ID09PSBnbC5URVhUVVJFX0NVQkVfTUFQYCB3aWxsXG4gKiBhdHRlbXB0IHRvIHNsaWNlIGltYWdlIGludG8gMXg2LCAyeDMsIDN4Miwgb3IgNngxIGltYWdlcywgb25lIGZvciBlYWNoIGZhY2UuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBhIGNhbnZhcywgaW1nLCBvciB2aWRlbyBlbGVtZW50LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gW29wdGlvbnNdIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiAgIFRoaXMgaXMgb2Z0ZW4gdGhlIHNhbWUgb3B0aW9ucyB5b3UgcGFzc2VkIGluIHdoZW4geW91IGNyZWF0ZWQgdGhlIHRleHR1cmUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqIEBraW5kIGZ1bmN0aW9uXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRUZXh0dXJlRnJvbUVsZW1lbnQoZ2wsIHRleCwgZWxlbWVudCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cy50ZXh0dXJlT3B0aW9ucztcbiAgdmFyIHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IGdsLlRFWFRVUkVfMkQ7XG4gIHZhciBsZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwgMDtcbiAgdmFyIHdpZHRoID0gZWxlbWVudC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnQuaGVpZ2h0O1xuICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBvcHRpb25zLmludGVybmFsRm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0IHx8IGdsLlJHQkE7XG4gIHZhciBmb3JtYXRUeXBlID0gZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0KTtcbiAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdFR5cGUuZm9ybWF0O1xuICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBmb3JtYXRUeXBlLnR5cGU7XG4gIHNhdmVQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG5cbiAgaWYgKHRhcmdldCA9PT0gZ2wuVEVYVFVSRV9DVUJFX01BUCkge1xuICAgIC8vIGd1ZXNzIHRoZSBwYXJ0c1xuICAgIHZhciBpbWdXaWR0aCA9IGVsZW1lbnQud2lkdGg7XG4gICAgdmFyIGltZ0hlaWdodCA9IGVsZW1lbnQuaGVpZ2h0O1xuICAgIHZhciBzaXplO1xuICAgIHZhciBzbGljZXM7XG5cbiAgICBpZiAoaW1nV2lkdGggLyA2ID09PSBpbWdIZWlnaHQpIHtcbiAgICAgIC8vIEl0J3MgNngxXG4gICAgICBzaXplID0gaW1nSGVpZ2h0O1xuICAgICAgc2xpY2VzID0gWzAsIDAsIDEsIDAsIDIsIDAsIDMsIDAsIDQsIDAsIDUsIDBdO1xuICAgIH0gZWxzZSBpZiAoaW1nSGVpZ2h0IC8gNiA9PT0gaW1nV2lkdGgpIHtcbiAgICAgIC8vIEl0J3MgMXg2XG4gICAgICBzaXplID0gaW1nV2lkdGg7XG4gICAgICBzbGljZXMgPSBbMCwgMCwgMCwgMSwgMCwgMiwgMCwgMywgMCwgNCwgMCwgNV07XG4gICAgfSBlbHNlIGlmIChpbWdXaWR0aCAvIDMgPT09IGltZ0hlaWdodCAvIDIpIHtcbiAgICAgIC8vIEl0J3MgM3gyXG4gICAgICBzaXplID0gaW1nV2lkdGggLyAzO1xuICAgICAgc2xpY2VzID0gWzAsIDAsIDEsIDAsIDIsIDAsIDAsIDEsIDEsIDEsIDIsIDFdO1xuICAgIH0gZWxzZSBpZiAoaW1nV2lkdGggLyAyID09PSBpbWdIZWlnaHQgLyAzKSB7XG4gICAgICAvLyBJdCdzIDJ4M1xuICAgICAgc2l6ZSA9IGltZ1dpZHRoIC8gMjtcbiAgICAgIHNsaWNlcyA9IFswLCAwLCAxLCAwLCAwLCAxLCAxLCAxLCAwLCAyLCAxLCAyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJjYW4ndCBmaWd1cmUgb3V0IGN1YmUgbWFwIGZyb20gZWxlbWVudDogXCIgKyAoZWxlbWVudC5zcmMgPyBlbGVtZW50LnNyYyA6IGVsZW1lbnQubm9kZU5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5jYW52YXMud2lkdGggPSBzaXplO1xuICAgICAgY3R4LmNhbnZhcy5oZWlnaHQgPSBzaXplO1xuICAgICAgd2lkdGggPSBzaXplO1xuICAgICAgaGVpZ2h0ID0gc2l6ZTtcbiAgICAgIGdldEN1YmVGYWNlc1dpdGhOZHgoZ2wsIG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdmFyIHhPZmZzZXQgPSBzbGljZXNbZi5uZHggKiAyICsgMF0gKiBzaXplO1xuICAgICAgICB2YXIgeU9mZnNldCA9IHNsaWNlc1tmLm5keCAqIDIgKyAxXSAqIHNpemU7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoZWxlbWVudCwgeE9mZnNldCwgeU9mZnNldCwgc2l6ZSwgc2l6ZSwgMCwgMCwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZi5mYWNlLCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgY3R4LmNhbnZhcyk7XG4gICAgICB9KTsgLy8gRnJlZSB1cCB0aGUgY2FudmFzIG1lbW9yeVxuXG4gICAgICBjdHguY2FudmFzLndpZHRoID0gMTtcbiAgICAgIGN0eC5jYW52YXMuaGVpZ2h0ID0gMTtcbiAgICB9IGVsc2UgaWYgKF9nbG9iYWxPYmplY3QuZGVmYXVsdC5jcmVhdGVJbWFnZUJpdG1hcCkge1xuICAgICAgLy8gTk9URTogSXQgc2VlbXMgbGlrZSB3ZSBzaG91bGQgcHJlZmVyIEltYWdlQml0bWFwIGJlY2F1c2UgdW5saWtlIGNhbnZhcyBpdCdzXG4gICAgICAvLyBub3RlIGxvc3N5PyAoYWxwaGEgaXMgbm90IHByZW11bHRpcGxpZWQ/IGFsdGhvdWdoIEknbSBub3Qgc3VyZSB3aGF0XG4gICAgICB3aWR0aCA9IHNpemU7XG4gICAgICBoZWlnaHQgPSBzaXplO1xuICAgICAgZ2V0Q3ViZUZhY2VzV2l0aE5keChnbCwgb3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgeE9mZnNldCA9IHNsaWNlc1tmLm5keCAqIDIgKyAwXSAqIHNpemU7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gc2xpY2VzW2YubmR4ICogMiArIDFdICogc2l6ZTsgLy8gV2UgY2FuJ3QgZWFzaWx5IHVzZSBhIGRlZmF1bHQgdGV4dHVyZSBjb2xvciBoZXJlIGFzIGl0IHdvdWxkIGhhdmUgdG8gbWF0Y2hcbiAgICAgICAgLy8gdGhlIHR5cGUgYWNyb3NzIGFsbCBmYWNlcyB3aGVyZSBhcyB3aXRoIGEgMkQgb25lIHRoZXJlJ3Mgb25seSBvbmUgZmFjZVxuICAgICAgICAvLyBzbyB3ZSdyZSByZXBsYWNpbmcgZXZlcnl0aGluZyBhbGwgYXQgb25jZS4gSXQgYWxzbyBoYXMgdG8gYmUgdGhlIGNvcnJlY3Qgc2l6ZS5cbiAgICAgICAgLy8gT24gdGhlIG90aGVyIGhhbmQgd2UgbmVlZCBhbGwgZmFjZXMgdG8gYmUgdGhlIHNhbWUgc2l6ZSBzbyBhcyBvbmUgZmFjZSBsb2Fkc1xuICAgICAgICAvLyB0aGUgcmVzdCBtYXRjaCBlbHNlIHRoZSB0ZXh0dXJlIHdpbGwgYmUgdW5yZW5kZXJhYmxlLlxuXG4gICAgICAgIGdsLnRleEltYWdlMkQoZi5mYWNlLCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHNpemUsIHNpemUsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XG5cbiAgICAgICAgX2dsb2JhbE9iamVjdC5kZWZhdWx0LmNyZWF0ZUltYWdlQml0bWFwKGVsZW1lbnQsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIHNpemUsIHtcbiAgICAgICAgICBwcmVtdWx0aXBseUFscGhhOiAnbm9uZScsXG4gICAgICAgICAgY29sb3JTcGFjZUNvbnZlcnNpb246ICdub25lJ1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChpbWFnZUJpdG1hcCkge1xuICAgICAgICAgIHNhdmVQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcbiAgICAgICAgICBnbC50ZXhJbWFnZTJEKGYuZmFjZSwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIGltYWdlQml0bWFwKTtcbiAgICAgICAgICByZXN0b3JlUGFja1N0YXRlKGdsLCBvcHRpb25zKTtcblxuICAgICAgICAgIGlmIChzaG91bGRBdXRvbWF0aWNhbGx5U2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKGdsLCB0ZXgsIG9wdGlvbnMsIHdpZHRoLCBoZWlnaHQsIGludGVybmFsRm9ybWF0LCB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gZ2wuVEVYVFVSRV8zRCB8fCB0YXJnZXQgPT09IGdsLlRFWFRVUkVfMkRfQVJSQVkpIHtcbiAgICB2YXIgc21hbGxlc3QgPSBNYXRoLm1pbihlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCk7XG4gICAgdmFyIGxhcmdlc3QgPSBNYXRoLm1heChlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCk7XG4gICAgdmFyIGRlcHRoID0gbGFyZ2VzdCAvIHNtYWxsZXN0O1xuXG4gICAgaWYgKGRlcHRoICUgMSAhPT0gMCkge1xuICAgICAgdGhyb3cgXCJjYW4gbm90IGNvbXB1dGUgM0QgZGltZW5zaW9ucyBvZiBlbGVtZW50XCI7XG4gICAgfVxuXG4gICAgdmFyIHhNdWx0ID0gZWxlbWVudC53aWR0aCA9PT0gbGFyZ2VzdCA/IDEgOiAwO1xuICAgIHZhciB5TXVsdCA9IGVsZW1lbnQuaGVpZ2h0ID09PSBsYXJnZXN0ID8gMSA6IDA7XG4gICAgc2F2ZVNraXBTdGF0ZShnbCk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0FMSUdOTUVOVCwgMSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1JPV19MRU5HVEgsIGVsZW1lbnQud2lkdGgpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19JTUFHRV9IRUlHSFQsIDApO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19TS0lQX0lNQUdFUywgMCk7XG4gICAgZ2wudGV4SW1hZ2UzRCh0YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgc21hbGxlc3QsIHNtYWxsZXN0LCBzbWFsbGVzdCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcblxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGVwdGg7ICsrZCkge1xuICAgICAgdmFyIHNyY1ggPSBkICogc21hbGxlc3QgKiB4TXVsdDtcbiAgICAgIHZhciBzcmNZID0gZCAqIHNtYWxsZXN0ICogeU11bHQ7XG4gICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfU0tJUF9QSVhFTFMsIHNyY1gpO1xuICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1NLSVBfUk9XUywgc3JjWSk7XG4gICAgICBnbC50ZXhTdWJJbWFnZTNEKHRhcmdldCwgbGV2ZWwsIDAsIDAsIGQsIHNtYWxsZXN0LCBzbWFsbGVzdCwgMSwgZm9ybWF0LCB0eXBlLCBlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXN0b3JlU2tpcFN0YXRlKGdsKTtcbiAgfSBlbHNlIHtcbiAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIGVsZW1lbnQpO1xuICB9XG5cbiAgcmVzdG9yZVBhY2tTdGF0ZShnbCwgb3B0aW9ucyk7XG5cbiAgaWYgKHNob3VsZEF1dG9tYXRpY2FsbHlTZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShvcHRpb25zKSkge1xuICAgIHNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKGdsLCB0ZXgsIG9wdGlvbnMsIHdpZHRoLCBoZWlnaHQsIGludGVybmFsRm9ybWF0LCB0eXBlKTtcbiAgfVxuXG4gIHNldFRleHR1cmVQYXJhbWV0ZXJzKGdsLCB0ZXgsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbi8qKlxuICogTG9hZHMgYW4gaW1hZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgdXJsIHRvIGltYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gY3Jvc3NPcmlnaW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyLCBpbWcpfSBbY2FsbGJhY2tdIGEgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCBhbiBlcnJvciBhbmQgdGhlIGltYWdlLiBUaGUgZXJyb3Igd2lsbCBiZSBub24tbnVsbFxuICogICAgIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gdGhlIGltYWdlIGJlaW5nIGxvYWRlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRJbWFnZSh1cmwsIGNyb3NzT3JpZ2luLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gIHZhciBpbWc7XG5cbiAgaWYgKF9nbG9iYWxPYmplY3QuZGVmYXVsdC5JbWFnZSkge1xuICAgIGltZyA9IG5ldyBfZ2xvYmFsT2JqZWN0LmRlZmF1bHQuSW1hZ2UoKTtcbiAgICBjcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgPyBjcm9zc09yaWdpbiA6IGRlZmF1bHRzLmNyb3NzT3JpZ2luO1xuXG4gICAgaWYgKGNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgIH1cblxuICAgIHZhciBjbGVhckV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiBjbGVhckV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICBpbWcucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICBpbWcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgaW1nID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgdmFyIG1zZyA9IFwiY291bGRuJ3QgbG9hZCBpbWFnZTogXCIgKyB1cmw7XG4gICAgICBoZWxwZXIuZXJyb3IobXNnKTtcbiAgICAgIGNhbGxiYWNrKG1zZywgaW1nKTtcbiAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpO1xuICAgIH07XG5cbiAgICB2YXIgb25Mb2FkID0gZnVuY3Rpb24gb25Mb2FkKCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgaW1nKTtcbiAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpO1xuICAgIH07XG5cbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgaW1nLnNyYyA9IHVybDtcbiAgICByZXR1cm4gaW1nO1xuICB9IGVsc2UgaWYgKF9nbG9iYWxPYmplY3QuZGVmYXVsdC5JbWFnZUJpdG1hcCkge1xuICAgIHZhciBlcnI7XG4gICAgdmFyIGJtO1xuXG4gICAgdmFyIGNiID0gZnVuY3Rpb24gY2IoKSB7XG4gICAgICBjYWxsYmFjayhlcnIsIGJtKTtcbiAgICB9O1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgb3B0aW9ucy5tb2RlID0gJ2NvcnMnOyAvLyBUT0RPOiBub3Qgc3VyZSBob3cgdG8gdHJhbnNsYXRlIGltYWdlLmNyb3NzT3JpZ2luXG4gICAgfVxuXG4gICAgZmV0Y2godXJsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyByZXNwb25zZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICByZXR1cm4gX2dsb2JhbE9iamVjdC5kZWZhdWx0LmNyZWF0ZUltYWdlQml0bWFwKGJsb2IsIHtcbiAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogJ25vbmUnLFxuICAgICAgICBjb2xvclNwYWNlQ29udmVyc2lvbjogJ25vbmUnXG4gICAgICB9KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChiaXRtYXApIHtcbiAgICAgIC8vIG5vdCBzdXJlIGlmIHRoaXMgd29ya3MuIFdlIGRvbid0IHdhbnRcbiAgICAgIC8vIHRvIGNhdGNoIHRoZSB1c2VyJ3MgZXJyb3IuIFNvLCBjYWxsXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgaW4gYSB0aW1lb3V0IHNvIHdlJ3JlXG4gICAgICAvLyBub3QgaW4gdGhpcyBzY29wZSBpbnNpZGUgdGhlIHByb21pc2UuXG4gICAgICBibSA9IGJpdG1hcDtcbiAgICAgIHNldFRpbWVvdXQoY2IpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgICAgc2V0VGltZW91dChjYik7XG4gICAgfSk7XG4gICAgaW1nID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBpbWc7XG59XG4vKipcbiAqIGNoZWNrIGlmIG9iamVjdCBpcyBhIFRleEltYWdlU291cmNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgYSBUZXhJbWFnZVNvdXJjZVxuICovXG5cblxuZnVuY3Rpb24gaXNUZXhJbWFnZVNvdXJjZShvYmopIHtcbiAgcmV0dXJuIF9nbG9iYWxPYmplY3QuZGVmYXVsdC5JbWFnZUJpdG1hcCAmJiBvYmogaW5zdGFuY2VvZiBfZ2xvYmFsT2JqZWN0LmRlZmF1bHQuSW1hZ2VCaXRtYXAgfHwgX2dsb2JhbE9iamVjdC5kZWZhdWx0LkltYWdlRGF0YSAmJiBvYmogaW5zdGFuY2VvZiBfZ2xvYmFsT2JqZWN0LmRlZmF1bHQuSW1hZ2VEYXRhIHx8IF9nbG9iYWxPYmplY3QuZGVmYXVsdC5IVE1MRWxlbWVudCAmJiBvYmogaW5zdGFuY2VvZiBfZ2xvYmFsT2JqZWN0LmRlZmF1bHQuSFRNTEVsZW1lbnQ7XG59XG4vKipcbiAqIGlmIG9iaiBpcyBhbiBUZXhJbWFnZVNvdXJjZSB0aGVuIGp1c3RcbiAqIHVzZXMgaXQgb3RoZXJ3aXNlIGlmIG9iaiBpcyBhIHN0cmluZ1xuICogdGhlbiBsb2FkIGl0IGZpcnN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFRleEltYWdlU291cmNlfSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjcm9zc09yaWdpblxuICogQHBhcmFtIHtmdW5jdGlvbihlcnIsIGltZyl9IFtjYWxsYmFja10gYSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIGFuIGVycm9yIGFuZCB0aGUgaW1hZ2UuIFRoZSBlcnJvciB3aWxsIGJlIG5vbi1udWxsXG4gKiAgICAgaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gKi9cblxuXG5mdW5jdGlvbiBsb2FkQW5kVXNlSW1hZ2Uob2JqLCBjcm9zc09yaWdpbiwgY2FsbGJhY2spIHtcbiAgaWYgKGlzVGV4SW1hZ2VTb3VyY2Uob2JqKSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgb2JqKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRJbWFnZShvYmosIGNyb3NzT3JpZ2luLCBjYWxsYmFjayk7XG59XG4vKipcbiAqIFNldHMgYSB0ZXh0dXJlIHRvIGEgMXgxIHBpeGVsIGNvbG9yLiBJZiBgb3B0aW9ucy5jb2xvciA9PT0gZmFsc2VgIGlzIG5vdGhpbmcgaGFwcGVucy4gSWYgaXQncyBub3Qgc2V0XG4gKiB0aGUgZGVmYXVsdCB0ZXh0dXJlIGNvbG9yIGlzIHVzZWQgd2hpY2ggY2FuIGJlIHNldCBieSBjYWxsaW5nIGBzZXREZWZhdWx0VGV4dHVyZUNvbG9yYC5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqICAgVGhpcyBpcyBvZnRlbiB0aGUgc2FtZSBvcHRpb25zIHlvdSBwYXNzZWQgaW4gd2hlbiB5b3UgY3JlYXRlZCB0aGUgdGV4dHVyZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gc2V0VGV4dHVyZVRvMVBpeGVsQ29sb3IoZ2wsIHRleCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cy50ZXh0dXJlT3B0aW9ucztcbiAgdmFyIHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IGdsLlRFWFRVUkVfMkQ7XG4gIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcblxuICBpZiAob3B0aW9ucy5jb2xvciA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQXNzdW1lIGl0J3MgYSBVUkxcbiAgLy8gUHV0IDF4MSBwaXhlbHMgaW4gdGV4dHVyZS4gVGhhdCBtYWtlcyBpdCByZW5kZXJhYmxlIGltbWVkaWF0ZWx5IHJlZ2FyZGxlc3Mgb2YgZmlsdGVyaW5nLlxuXG5cbiAgdmFyIGNvbG9yID0gbWFrZTFQaXhlbChvcHRpb25zLmNvbG9yKTtcblxuICBpZiAodGFyZ2V0ID09PSBnbC5URVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDY7ICsraWkpIHtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaWksIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGNvbG9yKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBnbC5URVhUVVJFXzNEIHx8IHRhcmdldCA9PT0gZ2wuVEVYVFVSRV8yRF9BUlJBWSkge1xuICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCAwLCBnbC5SR0JBLCAxLCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBjb2xvcik7XG4gIH0gZWxzZSB7XG4gICAgZ2wudGV4SW1hZ2UyRCh0YXJnZXQsIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGNvbG9yKTtcbiAgfVxufVxuLyoqXG4gKiBUaGUgc3JjIGltYWdlKHMpIHVzZWQgdG8gY3JlYXRlIGEgdGV4dHVyZS5cbiAqXG4gKiBXaGVuIHlvdSBjYWxsIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVUZXh0dXJlfSBvciB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVGV4dHVyZXN9XG4gKiB5b3UgY2FuIHBhc3MgaW4gdXJscyBmb3IgaW1hZ2VzIHRvIGxvYWQgaW50byB0aGUgdGV4dHVyZXMuIElmIGl0J3MgYSBzaW5nbGUgdXJsXG4gKiB0aGVuIHRoaXMgd2lsbCBiZSBhIHNpbmdsZSBIVE1MSW1hZ2VFbGVtZW50LiBJZiBpdCdzIGFuIGFycmF5IG9mIHVybHMgdXNlZCBmb3IgYSBjdWJlbWFwXG4gKiB0aGlzIHdpbGwgYmUgYSBjb3JyZXNwb25kaW5nIGFycmF5IG9mIGltYWdlcyBmb3IgdGhlIGN1YmVtYXAuXG4gKlxuICogQHR5cGVkZWYge0hUTUxJbWFnZUVsZW1lbnR8SFRNTEltYWdlRWxlbWVudFtdfSBUZXh0dXJlU3JjXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgZm9yIHdoZW4gYW4gaW1hZ2UgZmluaXNoZWQgZG93bmxvYWRpbmcgYW5kIGJlZW4gdXBsb2FkZWQgaW50byBhIHRleHR1cmVcbiAqIEBjYWxsYmFjayBUZXh0dXJlUmVhZHlDYWxsYmFja1xuICogQHBhcmFtIHsqfSBlcnIgSWYgdHJ1dGh5IHRoZXJlIHdhcyBhbiBlcnJvci5cbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXh0dXJlIHRoZSB0ZXh0dXJlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlU3JjfSBzb3VjZSBpbWFnZShzKSB1c2VkIHRvIGFzIHRoZSBzcmMgZm9yIHRoZSB0ZXh0dXJlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgZm9yIHdoZW4gYWxsIGltYWdlcyBoYXZlIGZpbmlzaGVkIGRvd25sb2FkaW5nIGFuZCBiZWVuIHVwbG9hZGVkIGludG8gdGhlaXIgcmVzcGVjdGl2ZSB0ZXh0dXJlc1xuICogQGNhbGxiYWNrIFRleHR1cmVzUmVhZHlDYWxsYmFja1xuICogQHBhcmFtIHsqfSBlcnIgSWYgdHJ1dGh5IHRoZXJlIHdhcyBhbiBlcnJvci5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIFdlYkdMVGV4dHVyZT59IHRleHR1cmVzIHRoZSBjcmVhdGVkIHRleHR1cmVzIGJ5IG5hbWUuIFNhbWUgYXMgcmV0dXJuZWQgYnkge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVRleHR1cmVzfS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLlRleHR1cmVTcmM+fSBzb3VyY2VzIHRoZSBpbWFnZShzKSB1c2VkIGZvciB0aGUgdGV4dHVyZSBieSBuYW1lLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBBIGNhbGxiYWNrIGZvciB3aGVuIGFuIGltYWdlIGZpbmlzaGVkIGRvd25sb2FkaW5nIGFuZCBiZWVuIHVwbG9hZGVkIGludG8gYSB0ZXh0dXJlXG4gKiBAY2FsbGJhY2sgQ3ViZW1hcFJlYWR5Q2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gZXJyIElmIHRydXRoeSB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSB0ZXh0dXJlLlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50W119IGltZ3MgdGhlIGltYWdlcyBmb3IgZWFjaCBmYWNlLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBBIGNhbGxiYWNrIGZvciB3aGVuIGFuIGltYWdlIGZpbmlzaGVkIGRvd25sb2FkaW5nIGFuZCBiZWVuIHVwbG9hZGVkIGludG8gYSB0ZXh0dXJlXG4gKiBAY2FsbGJhY2sgVGhyZWVEUmVhZHlDYWxsYmFja1xuICogQHBhcmFtIHsqfSBlcnIgSWYgdHJ1dGh5IHRoZXJlIHdhcyBhbiBlcnJvci5cbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIHRleHR1cmUuXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnRbXX0gaW1ncyB0aGUgaW1hZ2VzIGZvciBlYWNoIHNsaWNlLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBMb2FkcyBhIHRleHR1cmUgZnJvbSBhbiBpbWFnZSBmcm9tIGEgVXJsIGFzIHNwZWNpZmllZCBpbiBgb3B0aW9ucy5zcmNgXG4gKiBJZiBgb3B0aW9ucy5jb2xvciAhPT0gZmFsc2VgIHdpbGwgc2V0IHRoZSB0ZXh0dXJlIHRvIGEgMXgxIHBpeGVsIGNvbG9yIHNvIHRoYXQgdGhlIHRleHR1cmUgaXNcbiAqIGltbWVkaWF0ZWx5IHVzZWFibGUuIEl0IHdpbGwgYmUgdXBkYXRlZCB3aXRoIHRoZSBjb250ZW50cyBvZiB0aGUgaW1hZ2Ugb25jZSB0aGUgaW1hZ2UgaGFzIGZpbmlzaGVkXG4gKiBkb3dubG9hZGluZy4gRmlsdGVyaW5nIG9wdGlvbnMgd2lsbCBiZSBzZXQgYXMgYXBwcm9yaWF0ZSBmb3IgaW1hZ2UgdW5sZXNzIGBvcHRpb25zLmF1dG8gPT09IGZhbHNlYC5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZVJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgaW1hZ2UgaGFzIGZpbmlzaGVkIGxvYWRpbmcuIGVyciB3aWxsXG4gKiAgICBiZSBub24gbnVsbCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSB0aGUgaW1hZ2UgYmVpbmcgZG93bmxvYWRlZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gbG9hZFRleHR1cmVGcm9tVXJsKGdsLCB0ZXgsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHMudGV4dHVyZU9wdGlvbnM7XG4gIHNldFRleHR1cmVUbzFQaXhlbENvbG9yKGdsLCB0ZXgsIG9wdGlvbnMpOyAvLyBCZWNhdXNlIGl0J3MgYXN5bmMgd2UgbmVlZCB0byBjb3B5IHRoZSBvcHRpb25zLlxuXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgdmFyIGltZyA9IGxvYWRBbmRVc2VJbWFnZShvcHRpb25zLnNyYywgb3B0aW9ucy5jcm9zc09yaWdpbiwgZnVuY3Rpb24gKGVyciwgaW1nKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyLCB0ZXgsIGltZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRleHR1cmVGcm9tRWxlbWVudChnbCwgdGV4LCBpbWcsIG9wdGlvbnMpO1xuICAgICAgY2FsbGJhY2sobnVsbCwgdGV4LCBpbWcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbWc7XG59XG4vKipcbiAqIExvYWRzIGEgY3ViZW1hcCBmcm9tIDYgdXJscyBvciBUZXhJbWFnZVNvdXJjZXMgYXMgc3BlY2lmaWVkIGluIGBvcHRpb25zLnNyY2AuIFdpbGwgc2V0IHRoZSBjdWJlbWFwIHRvIGEgMXgxIHBpeGVsIGNvbG9yXG4gKiBzbyB0aGF0IGl0IGlzIHVzYWJsZSBpbW1lZGlhdGVseSB1bmxlc3MgYG9wdGlvbi5jb2xvciA9PT0gZmFsc2VgLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIFdlYkdMVGV4dHVyZSB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQ3ViZW1hcFJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBhbGwgdGhlIGltYWdlcyBoYXZlIGZpbmlzaGVkIGxvYWRpbmcuIGVyciB3aWxsXG4gKiAgICBiZSBub24gbnVsbCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRDdWJlbWFwRnJvbVVybHMoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICB2YXIgdXJscyA9IG9wdGlvbnMuc3JjO1xuXG4gIGlmICh1cmxzLmxlbmd0aCAhPT0gNikge1xuICAgIHRocm93IFwidGhlcmUgbXVzdCBiZSA2IHVybHMgZm9yIGEgY3ViZW1hcFwiO1xuICB9XG5cbiAgdmFyIGxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCAwO1xuICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBvcHRpb25zLmludGVybmFsRm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0IHx8IGdsLlJHQkE7XG4gIHZhciBmb3JtYXRUeXBlID0gZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0KTtcbiAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdFR5cGUuZm9ybWF0O1xuICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBnbC5VTlNJR05FRF9CWVRFO1xuICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgZ2wuVEVYVFVSRV8yRDtcblxuICBpZiAodGFyZ2V0ICE9PSBnbC5URVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgdGhyb3cgXCJ0YXJnZXQgbXVzdCBiZSBURVhUVVJFX0NVQkVfTUFQXCI7XG4gIH1cblxuICBzZXRUZXh0dXJlVG8xUGl4ZWxDb2xvcihnbCwgdGV4LCBvcHRpb25zKTsgLy8gQmVjYXVzZSBpdCdzIGFzeW5jIHdlIG5lZWQgdG8gY29weSB0aGUgb3B0aW9ucy5cblxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gIHZhciBudW1Ub0xvYWQgPSA2O1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBmYWNlcyA9IGdldEN1YmVGYWNlT3JkZXIoZ2wsIG9wdGlvbnMpO1xuICB2YXIgaW1nczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGZ1bmN0aW9uIHVwbG9hZEltZyhmYWNlVGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIGltZykge1xuICAgICAgLS1udW1Ub0xvYWQ7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbWcud2lkdGggIT09IGltZy5oZWlnaHQpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChcImN1YmVtYXAgZmFjZSBpbWcgaXMgbm90IGEgc3F1YXJlOiBcIiArIGltZy5zcmMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNhdmVQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTsgLy8gU28gYXNzdW1pbmcgdGhpcyBpcyB0aGUgZmlyc3QgaW1hZ2Ugd2Ugbm93IGhhdmUgb25lIGZhY2UgdGhhdCdzIGltZyBzaXplZFxuICAgICAgICAgIC8vIGFuZCA1IGZhY2VzIHRoYXQgYXJlIDF4MSBwaXhlbCBzbyBzaXplIHRoZSBvdGhlciBmYWNlc1xuXG4gICAgICAgICAgaWYgKG51bVRvTG9hZCA9PT0gNSkge1xuICAgICAgICAgICAgLy8gdXNlIHRoZSBkZWZhdWx0IG9yZGVyXG4gICAgICAgICAgICBnZXRDdWJlRmFjZU9yZGVyKGdsKS5mb3JFYWNoKGZ1bmN0aW9uIChvdGhlclRhcmdldCkge1xuICAgICAgICAgICAgICAvLyBTaG91bGQgd2UgcmUtdXNlIHRoZSBzYW1lIGZhY2Ugb3IgYSBjb2xvcj9cbiAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChvdGhlclRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIGltZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChmYWNlVGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgaW1nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN0b3JlUGFja1N0YXRlKGdsLCBvcHRpb25zKTtcblxuICAgICAgICAgIGlmIChzaG91bGRBdXRvbWF0aWNhbGx5U2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1Ub0xvYWQgPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IHVuZGVmaW5lZCwgdGV4LCBpbWdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaW1ncyA9IHVybHMubWFwKGZ1bmN0aW9uICh1cmwsIG5keCkge1xuICAgIHJldHVybiBsb2FkQW5kVXNlSW1hZ2UodXJsLCBvcHRpb25zLmNyb3NzT3JpZ2luLCB1cGxvYWRJbWcoZmFjZXNbbmR4XSkpO1xuICB9KTtcbn1cbi8qKlxuICogTG9hZHMgYSAyZCBhcnJheSBvciAzZCB0ZXh0dXJlIGZyb20gdXJscyBPUiBUZXhJbWFnZVNvdXJjZXMgYXMgc3BlY2lmaWVkIGluIGBvcHRpb25zLnNyY2AuXG4gKiBXaWxsIHNldCB0aGUgdGV4dHVyZSB0byBhIDF4MSBwaXhlbCBjb2xvclxuICogc28gdGhhdCBpdCBpcyB1c2FibGUgaW1tZWRpYXRlbHkgdW5sZXNzIGBvcHRpb24uY29sb3IgPT09IGZhbHNlYC5cbiAqXG4gKiBJZiB0aGUgd2lkdGggYW5kIGhlaWdodCBpcyBub3Qgc3BlY2lmaWVkIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBmaXJzdFxuICogaW1hZ2UgbG9hZGVkIHdpbGwgYmUgdXNlZC4gTm90ZSB0aGF0IHNpbmNlIGltYWdlcyBhcmUgbG9hZGVkIGFzeW5jXG4gKiB3aGljaCBpbWFnZSBkb3dubG9hZHMgZmlyc3QgaXMgdW5rbm93bi5cbiAqXG4gKiBJZiBhbiBpbWFnZSBpcyBub3QgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgd2lkdGggYW5kIGhlaWdodCBpdCB3aWxsIGJlIHNjYWxlZFxuICogdG8gdGhhdCB3aWR0aCBhbmQgaGVpZ2h0LlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRocmVlRFJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBhbGwgdGhlIGltYWdlcyBoYXZlIGZpbmlzaGVkIGxvYWRpbmcuIGVyciB3aWxsXG4gKiAgICBiZSBub24gbnVsbCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRTbGljZXNGcm9tVXJscyhnbCwgdGV4LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gIHZhciB1cmxzID0gb3B0aW9ucy5zcmM7XG4gIHZhciBpbnRlcm5hbEZvcm1hdCA9IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgfHwgb3B0aW9ucy5mb3JtYXQgfHwgZ2wuUkdCQTtcbiAgdmFyIGZvcm1hdFR5cGUgPSBnZXRGb3JtYXRBbmRUeXBlRm9ySW50ZXJuYWxGb3JtYXQoaW50ZXJuYWxGb3JtYXQpO1xuICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgZm9ybWF0VHlwZS5mb3JtYXQ7XG4gIHZhciB0eXBlID0gb3B0aW9ucy50eXBlIHx8IGdsLlVOU0lHTkVEX0JZVEU7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBnbC5URVhUVVJFXzJEX0FSUkFZO1xuXG4gIGlmICh0YXJnZXQgIT09IGdsLlRFWFRVUkVfM0QgJiYgdGFyZ2V0ICE9PSBnbC5URVhUVVJFXzJEX0FSUkFZKSB7XG4gICAgdGhyb3cgXCJ0YXJnZXQgbXVzdCBiZSBURVhUVVJFXzNEIG9yIFRFWFRVUkVfMkRfQVJSQVlcIjtcbiAgfVxuXG4gIHNldFRleHR1cmVUbzFQaXhlbENvbG9yKGdsLCB0ZXgsIG9wdGlvbnMpOyAvLyBCZWNhdXNlIGl0J3MgYXN5bmMgd2UgbmVlZCB0byBjb3B5IHRoZSBvcHRpb25zLlxuXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgdmFyIG51bVRvTG9hZCA9IHVybHMubGVuZ3RoO1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBpbWdzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgdmFyIGxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCAwO1xuICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBkZXB0aCA9IHVybHMubGVuZ3RoO1xuICB2YXIgZmlyc3RJbWFnZSA9IHRydWU7XG5cbiAgZnVuY3Rpb24gdXBsb2FkSW1nKHNsaWNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIGltZykge1xuICAgICAgLS1udW1Ub0xvYWQ7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNhdmVQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG5cbiAgICAgICAgaWYgKGZpcnN0SW1hZ2UpIHtcbiAgICAgICAgICBmaXJzdEltYWdlID0gZmFsc2U7XG4gICAgICAgICAgd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IGltZy53aWR0aDtcbiAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCBpbWcuaGVpZ2h0O1xuICAgICAgICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpOyAvLyBwdXQgaXQgaW4gZXZlcnkgc2xpY2Ugb3RoZXJ3aXNlIHNvbWUgc2xpY2VzIHdpbGwgYmUgMCwwLDAsMFxuXG4gICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBkZXB0aDsgKytzKSB7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTNEKHRhcmdldCwgbGV2ZWwsIDAsIDAsIHMsIHdpZHRoLCBoZWlnaHQsIDEsIGZvcm1hdCwgdHlwZSwgaW1nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNyYyA9IGltZztcblxuICAgICAgICAgIGlmIChpbWcud2lkdGggIT09IHdpZHRoIHx8IGltZy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgLy8gU2l6ZSB0aGUgaW1hZ2UgdG8gZml4XG4gICAgICAgICAgICBzcmMgPSBjdHguY2FudmFzO1xuICAgICAgICAgICAgY3R4LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY3R4LmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2wudGV4U3ViSW1hZ2UzRCh0YXJnZXQsIGxldmVsLCAwLCAwLCBzbGljZSwgd2lkdGgsIGhlaWdodCwgMSwgZm9ybWF0LCB0eXBlLCBzcmMpOyAvLyBmcmVlIHRoZSBjYW52YXMgbWVtb3J5XG5cbiAgICAgICAgICBpZiAoc3JjID09PSBjdHguY2FudmFzKSB7XG4gICAgICAgICAgICBjdHguY2FudmFzLndpZHRoID0gMDtcbiAgICAgICAgICAgIGN0eC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN0b3JlUGFja1N0YXRlKGdsLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoc2hvdWxkQXV0b21hdGljYWxseVNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKG9wdGlvbnMpKSB7XG4gICAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobnVtVG9Mb2FkID09PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9ycy5sZW5ndGggPyBlcnJvcnMgOiB1bmRlZmluZWQsIHRleCwgaW1ncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGltZ3MgPSB1cmxzLm1hcChmdW5jdGlvbiAodXJsLCBuZHgpIHtcbiAgICByZXR1cm4gbG9hZEFuZFVzZUltYWdlKHVybCwgb3B0aW9ucy5jcm9zc09yaWdpbiwgdXBsb2FkSW1nKG5keCkpO1xuICB9KTtcbn1cbi8qKlxuICogU2V0cyBhIHRleHR1cmUgZnJvbSBhbiBhcnJheSBvciB0eXBlZCBhcnJheS4gSWYgdGhlIHdpZHRoIG9yIGhlaWdodCBpcyBub3QgcHJvdmlkZWQgd2lsbCBhdHRlbXB0IHRvXG4gKiBndWVzcyB0aGUgc2l6ZS4gU2VlIHtAbGluayBtb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30uXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHsobnVtYmVyW118QXJyYXlCdWZmZXJWaWV3KX0gc3JjIEFuIGFycmF5IG9yIHR5cGVkIGFycnkgd2l0aCB0ZXh0dXJlIGRhdGEuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqICAgVGhpcyBpcyBvZnRlbiB0aGUgc2FtZSBvcHRpb25zIHlvdSBwYXNzZWQgaW4gd2hlbiB5b3UgY3JlYXRlZCB0aGUgdGV4dHVyZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gc2V0VGV4dHVyZUZyb21BcnJheShnbCwgdGV4LCBzcmMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHMudGV4dHVyZU9wdGlvbnM7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBnbC5URVhUVVJFXzJEO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgdmFyIGRlcHRoID0gb3B0aW9ucy5kZXB0aDtcbiAgdmFyIGxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCAwO1xuICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBvcHRpb25zLmludGVybmFsRm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0IHx8IGdsLlJHQkE7XG4gIHZhciBmb3JtYXRUeXBlID0gZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0KTtcbiAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdFR5cGUuZm9ybWF0O1xuICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBnZXRUZXh0dXJlVHlwZUZvckFycmF5VHlwZShnbCwgc3JjLCBmb3JtYXRUeXBlLnR5cGUpO1xuXG4gIGlmICghaXNBcnJheUJ1ZmZlcihzcmMpKSB7XG4gICAgdmFyIFR5cGUgPSB0eXBlZEFycmF5cy5nZXRUeXBlZEFycmF5VHlwZUZvckdMVHlwZSh0eXBlKTtcbiAgICBzcmMgPSBuZXcgVHlwZShzcmMpO1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgc3JjID0gbmV3IFVpbnQ4QXJyYXkoc3JjLmJ1ZmZlcik7XG4gIH1cblxuICB2YXIgYnl0ZXNQZXJFbGVtZW50ID0gZ2V0Qnl0ZXNQZXJFbGVtZW50Rm9ySW50ZXJuYWxGb3JtYXQoaW50ZXJuYWxGb3JtYXQsIHR5cGUpO1xuICB2YXIgbnVtRWxlbWVudHMgPSBzcmMuYnl0ZUxlbmd0aCAvIGJ5dGVzUGVyRWxlbWVudDsgLy8gVE9ETzogY2hlY2sgVU5QQUNLX0FMSUdOTUVOVD9cblxuICBpZiAobnVtRWxlbWVudHMgJSAxKSB7XG4gICAgdGhyb3cgXCJsZW5ndGggd3Jvbmcgc2l6ZSBmb3IgZm9ybWF0OiBcIiArIHV0aWxzLmdsRW51bVRvU3RyaW5nKGdsLCBmb3JtYXQpO1xuICB9XG5cbiAgdmFyIGRpbWVuc2lvbnM7XG5cbiAgaWYgKHRhcmdldCA9PT0gZ2wuVEVYVFVSRV8zRCkge1xuICAgIGlmICghd2lkdGggJiYgIWhlaWdodCAmJiAhZGVwdGgpIHtcbiAgICAgIHZhciBzaXplID0gTWF0aC5jYnJ0KG51bUVsZW1lbnRzKTtcblxuICAgICAgaWYgKHNpemUgJSAxICE9PSAwKSB7XG4gICAgICAgIHRocm93IFwiY2FuJ3QgZ3Vlc3MgY3ViZSBzaXplIG9mIGFycmF5IG9mIG51bUVsZW1lbnRzOiBcIiArIG51bUVsZW1lbnRzO1xuICAgICAgfVxuXG4gICAgICB3aWR0aCA9IHNpemU7XG4gICAgICBoZWlnaHQgPSBzaXplO1xuICAgICAgZGVwdGggPSBzaXplO1xuICAgIH0gZWxzZSBpZiAod2lkdGggJiYgKCFoZWlnaHQgfHwgIWRlcHRoKSkge1xuICAgICAgZGltZW5zaW9ucyA9IGd1ZXNzRGltZW5zaW9ucyhnbCwgdGFyZ2V0LCBoZWlnaHQsIGRlcHRoLCBudW1FbGVtZW50cyAvIHdpZHRoKTtcbiAgICAgIGhlaWdodCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICBkZXB0aCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ICYmICghd2lkdGggfHwgIWRlcHRoKSkge1xuICAgICAgZGltZW5zaW9ucyA9IGd1ZXNzRGltZW5zaW9ucyhnbCwgdGFyZ2V0LCB3aWR0aCwgZGVwdGgsIG51bUVsZW1lbnRzIC8gaGVpZ2h0KTtcbiAgICAgIHdpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgIGRlcHRoID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpbWVuc2lvbnMgPSBndWVzc0RpbWVuc2lvbnMoZ2wsIHRhcmdldCwgd2lkdGgsIGhlaWdodCwgbnVtRWxlbWVudHMgLyBkZXB0aCk7XG4gICAgICB3aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICBoZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGltZW5zaW9ucyA9IGd1ZXNzRGltZW5zaW9ucyhnbCwgdGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBudW1FbGVtZW50cyk7XG4gICAgd2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgIGhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICB9XG5cbiAgc2F2ZVNraXBTdGF0ZShnbCk7XG4gIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19BTElHTk1FTlQsIG9wdGlvbnMudW5wYWNrQWxpZ25tZW50IHx8IDEpO1xuICBzYXZlUGFja1N0YXRlKGdsLCBvcHRpb25zKTtcblxuICBpZiAodGFyZ2V0ID09PSBnbC5URVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgdmFyIGVsZW1lbnRzUGVyRWxlbWVudCA9IGJ5dGVzUGVyRWxlbWVudCAvIHNyYy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICB2YXIgZmFjZVNpemUgPSBudW1FbGVtZW50cyAvIDYgKiBlbGVtZW50c1BlckVsZW1lbnQ7XG4gICAgZ2V0Q3ViZUZhY2VzV2l0aE5keChnbCwgb3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgdmFyIG9mZnNldCA9IGZhY2VTaXplICogZi5uZHg7XG4gICAgICB2YXIgZGF0YSA9IHNyYy5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGZhY2VTaXplKTtcbiAgICAgIGdsLnRleEltYWdlMkQoZi5mYWNlLCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBnbC5URVhUVVJFXzNEKSB7XG4gICAgZ2wudGV4SW1hZ2UzRCh0YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIDAsIGZvcm1hdCwgdHlwZSwgc3JjKTtcbiAgfSBlbHNlIHtcbiAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIHR5cGUsIHNyYyk7XG4gIH1cblxuICByZXN0b3JlUGFja1N0YXRlKGdsLCBvcHRpb25zKTtcbiAgcmVzdG9yZVNraXBTdGF0ZShnbCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIGRlcHRoOiBkZXB0aCxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG59XG4vKipcbiAqIFNldHMgYSB0ZXh0dXJlIHdpdGggbm8gY29udGVudHMgb2YgYSBjZXJ0YWluIHNpemUuIEluIG90aGVyIHdvcmRzIGNhbGxzIGBnbC50ZXhJbWFnZTJEYCB3aXRoIGBudWxsYC5cbiAqIFlvdSBtdXN0IHNldCBgb3B0aW9ucy53aWR0aGAgYW5kIGBvcHRpb25zLmhlaWdodGAuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRFbXB0eVRleHR1cmUoZ2wsIHRleCwgb3B0aW9ucykge1xuICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgZ2wuVEVYVFVSRV8yRDtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuICB2YXIgbGV2ZWwgPSBvcHRpb25zLmxldmVsIHx8IDA7XG4gIHZhciBpbnRlcm5hbEZvcm1hdCA9IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgfHwgb3B0aW9ucy5mb3JtYXQgfHwgZ2wuUkdCQTtcbiAgdmFyIGZvcm1hdFR5cGUgPSBnZXRGb3JtYXRBbmRUeXBlRm9ySW50ZXJuYWxGb3JtYXQoaW50ZXJuYWxGb3JtYXQpO1xuICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgZm9ybWF0VHlwZS5mb3JtYXQ7XG4gIHZhciB0eXBlID0gb3B0aW9ucy50eXBlIHx8IGZvcm1hdFR5cGUudHlwZTtcbiAgc2F2ZVBhY2tTdGF0ZShnbCwgb3B0aW9ucyk7XG5cbiAgaWYgKHRhcmdldCA9PT0gZ2wuVEVYVFVSRV9DVUJFX01BUCkge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCA2OyArK2lpKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGlpLCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0LCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0YXJnZXQgPT09IGdsLlRFWFRVUkVfM0QpIHtcbiAgICBnbC50ZXhJbWFnZTNEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCwgb3B0aW9ucy5kZXB0aCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgfVxuXG4gIHJlc3RvcmVQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgdGV4dHVyZSBiYXNlZCBvbiB0aGUgb3B0aW9ucyBwYXNzZWQgaW4uXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gW29wdGlvbnNdIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVSZWFkeUNhbGxiYWNrfSBbY2FsbGJhY2tdIEEgY2FsbGJhY2sgY2FsbGVkIHdoZW4gYW4gaW1hZ2UgaGFzIGJlZW4gZG93bmxvYWRlZCBhbmQgdXBsb2FkZWQgdG8gdGhlIHRleHR1cmUuXG4gKiBAcmV0dXJuIHtXZWJHTFRleHR1cmV9IHRoZSBjcmVhdGVkIHRleHR1cmUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUoZ2wsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHMudGV4dHVyZU9wdGlvbnM7XG4gIHZhciB0ZXggPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBnbC5URVhUVVJFXzJEO1xuICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IDE7XG4gIHZhciBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCAxO1xuICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBvcHRpb25zLmludGVybmFsRm9ybWF0IHx8IGdsLlJHQkE7XG4gIHZhciBmb3JtYXRUeXBlID0gZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0KTtcbiAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZm9ybWF0VHlwZS50eXBlO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG5cbiAgaWYgKHRhcmdldCA9PT0gZ2wuVEVYVFVSRV9DVUJFX01BUCkge1xuICAgIC8vIHRoaXMgc2hvdWxkIGhhdmUgYmVlbiB0aGUgZGVmYXVsdCBmb3IgQ1VCRU1BUFMgOihcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gIH1cblxuICB2YXIgc3JjID0gb3B0aW9ucy5zcmM7XG5cbiAgaWYgKHNyYykge1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHNyYyA9IHNyYyhnbCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGxvYWRUZXh0dXJlRnJvbVVybChnbCwgdGV4LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKHNyYykgfHwgQXJyYXkuaXNBcnJheShzcmMpICYmICh0eXBlb2Ygc3JjWzBdID09PSAnbnVtYmVyJyB8fCBBcnJheS5pc0FycmF5KHNyY1swXSkgfHwgaXNBcnJheUJ1ZmZlcihzcmNbMF0pKSkge1xuICAgICAgdmFyIGRpbWVuc2lvbnMgPSBzZXRUZXh0dXJlRnJvbUFycmF5KGdsLCB0ZXgsIHNyYywgb3B0aW9ucyk7XG4gICAgICB3aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICBoZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgIHR5cGUgPSBkaW1lbnNpb25zLnR5cGU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNyYykgJiYgKHR5cGVvZiBzcmNbMF0gPT09ICdzdHJpbmcnIHx8IGlzVGV4SW1hZ2VTb3VyY2Uoc3JjWzBdKSkpIHtcbiAgICAgIGlmICh0YXJnZXQgPT09IGdsLlRFWFRVUkVfQ1VCRV9NQVApIHtcbiAgICAgICAgbG9hZEN1YmVtYXBGcm9tVXJscyhnbCwgdGV4LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkU2xpY2VzRnJvbVVybHMoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUZXhJbWFnZVNvdXJjZShzcmMpKSB7XG4gICAgICBzZXRUZXh0dXJlRnJvbUVsZW1lbnQoZ2wsIHRleCwgc3JjLCBvcHRpb25zKTtcbiAgICAgIHdpZHRoID0gc3JjLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gc3JjLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCBzcmMgdHlwZVwiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXRFbXB0eVRleHR1cmUoZ2wsIHRleCwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoc2hvdWxkQXV0b21hdGljYWxseVNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKG9wdGlvbnMpKSB7XG4gICAgc2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUoZ2wsIHRleCwgb3B0aW9ucywgd2lkdGgsIGhlaWdodCwgaW50ZXJuYWxGb3JtYXQsIHR5cGUpO1xuICB9XG5cbiAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoZ2wsIHRleCwgb3B0aW9ucyk7XG4gIHJldHVybiB0ZXg7XG59XG4vKipcbiAqIFJlc2l6ZXMgYSB0ZXh0dXJlIGJhc2VkIG9uIHRoZSBvcHRpb25zIHBhc3NlZCBpbi5cbiAqXG4gKiBOb3RlOiBUaGlzIGlzIG5vdCBhIGdlbmVyaWMgcmVzaXplIGFueXRoaW5nIGZ1bmN0aW9uLlxuICogSXQncyBtb3N0bHkgdXNlZCBieSB7QGxpbmsgbW9kdWxlOnR3Z2wucmVzaXplRnJhbWVidWZmZXJJbmZvfVxuICogSXQgd2lsbCB1c2UgYG9wdGlvbnMuc3JjYCBpZiBpdCBleGlzdHMgdG8gdHJ5IHRvIGRldGVybWluZSBhIGB0eXBlYFxuICogb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGBnbC5VTlNJR05FRF9CWVRFYC4gTm8gZGF0YSBpcyBwcm92aWRlZFxuICogZm9yIHRoZSB0ZXh0dXJlLiBUZXh0dXJlIHBhcmFtZXRlcnMgd2lsbCBiZSBzZXQgYWNjb3JkaW5nbHlcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgdGV4dHVyZSB0byByZXNpemVcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIHRoZSBuZXcgd2lkdGguIElmIG5vdCBwYXNzZWQgaW4gd2lsbCB1c2UgYG9wdGlvbnMud2lkdGhgXG4gKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gdGhlIG5ldyBoZWlnaHQuIElmIG5vdCBwYXNzZWQgaW4gd2lsbCB1c2UgYG9wdGlvbnMuaGVpZ2h0YFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuXG5mdW5jdGlvbiByZXNpemVUZXh0dXJlKGdsLCB0ZXgsIG9wdGlvbnMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgd2lkdGggPSB3aWR0aCB8fCBvcHRpb25zLndpZHRoO1xuICBoZWlnaHQgPSBoZWlnaHQgfHwgb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBnbC5URVhUVVJFXzJEO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIHZhciBsZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwgMDtcbiAgdmFyIGludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCBvcHRpb25zLmZvcm1hdCB8fCBnbC5SR0JBO1xuICB2YXIgZm9ybWF0VHlwZSA9IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCk7XG4gIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBmb3JtYXRUeXBlLmZvcm1hdDtcbiAgdmFyIHR5cGU7XG4gIHZhciBzcmMgPSBvcHRpb25zLnNyYztcblxuICBpZiAoIXNyYykge1xuICAgIHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZm9ybWF0VHlwZS50eXBlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIoc3JjKSB8fCBBcnJheS5pc0FycmF5KHNyYykgJiYgdHlwZW9mIHNyY1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB0eXBlID0gb3B0aW9ucy50eXBlIHx8IGdldFRleHR1cmVUeXBlRm9yQXJyYXlUeXBlKGdsLCBzcmMsIGZvcm1hdFR5cGUudHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBmb3JtYXRUeXBlLnR5cGU7XG4gIH1cblxuICBpZiAodGFyZ2V0ID09PSBnbC5URVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDY7ICsraWkpIHtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaWksIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZ2wudGV4SW1hZ2UyRCh0YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiBhIHNyYyBpcyBhbiBhc3luYyByZXF1ZXN0LlxuICogaWYgc3JjIGlzIGEgc3RyaW5nIHdlJ3JlIGdvaW5nIHRvIGRvd25sb2FkIGFuIGltYWdlXG4gKiBpZiBzcmMgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncyB3ZSdyZSBnb2luZyB0byBkb3dubG9hZCBjdWJlbWFwIGltYWdlc1xuICogQHBhcmFtIHsqfSBzcmMgVGhlIHNyYyBmcm9tIGEgVGV4dHVyZU9wdGlvbnNcbiAqIEByZXR1cm5zIHtib29sfSB0cnVlIGlmIHNyYyBpcyBhc3luYy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQXN5bmNTcmMoc3JjKSB7XG4gIHJldHVybiB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHNyYykgJiYgdHlwZW9mIHNyY1swXSA9PT0gJ3N0cmluZyc7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBidW5jaCBvZiB0ZXh0dXJlcyBiYXNlZCBvbiB0aGUgcGFzc2VkIGluIG9wdGlvbnMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdGV4dHVyZXMgPSB0d2dsLmNyZWF0ZVRleHR1cmVzKGdsLCB7XG4gKiAgICAgICAvLyBhIHBvd2VyIG9mIDIgaW1hZ2VcbiAqICAgICAgIGhmdEljb246IHsgc3JjOiBcImltYWdlcy9oZnQtaWNvbi0xNi5wbmdcIiwgbWFnOiBnbC5ORUFSRVNUIH0sXG4gKiAgICAgICAvLyBhIG5vbi1wb3dlciBvZiAyIGltYWdlXG4gKiAgICAgICBjbG92ZXI6IHsgc3JjOiBcImltYWdlcy9jbG92ZXIuanBnXCIgfSxcbiAqICAgICAgIC8vIEZyb20gYSBjYW52YXNcbiAqICAgICAgIGZyb21DYW52YXM6IHsgc3JjOiBjdHguY2FudmFzIH0sXG4gKiAgICAgICAvLyBBIGN1YmVtYXAgZnJvbSA2IGltYWdlc1xuICogICAgICAgeW9rb2hhbWE6IHtcbiAqICAgICAgICAgdGFyZ2V0OiBnbC5URVhUVVJFX0NVQkVfTUFQLFxuICogICAgICAgICBzcmM6IFtcbiAqICAgICAgICAgICAnaW1hZ2VzL3lva29oYW1hL3Bvc3guanBnJyxcbiAqICAgICAgICAgICAnaW1hZ2VzL3lva29oYW1hL25lZ3guanBnJyxcbiAqICAgICAgICAgICAnaW1hZ2VzL3lva29oYW1hL3Bvc3kuanBnJyxcbiAqICAgICAgICAgICAnaW1hZ2VzL3lva29oYW1hL25lZ3kuanBnJyxcbiAqICAgICAgICAgICAnaW1hZ2VzL3lva29oYW1hL3Bvc3ouanBnJyxcbiAqICAgICAgICAgICAnaW1hZ2VzL3lva29oYW1hL25lZ3ouanBnJyxcbiAqICAgICAgICAgXSxcbiAqICAgICAgIH0sXG4gKiAgICAgICAvLyBBIGN1YmVtYXAgZnJvbSAxIGltYWdlIChjYW4gYmUgMXg2LCAyeDMsIDN4MiwgNngxKVxuICogICAgICAgZ29sZGVuZ2F0ZToge1xuICogICAgICAgICB0YXJnZXQ6IGdsLlRFWFRVUkVfQ1VCRV9NQVAsXG4gKiAgICAgICAgIHNyYzogJ2ltYWdlcy9nb2xkZW5nYXRlLmpwZycsXG4gKiAgICAgICB9LFxuICogICAgICAgLy8gQSAyeDIgcGl4ZWwgdGV4dHVyZSBmcm9tIGEgSmF2YVNjcmlwdCBhcnJheVxuICogICAgICAgY2hlY2tlcjoge1xuICogICAgICAgICBtYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgIG1pbjogZ2wuTElORUFSLFxuICogICAgICAgICBzcmM6IFtcbiAqICAgICAgICAgICAyNTUsMjU1LDI1NSwyNTUsXG4gKiAgICAgICAgICAgMTkyLDE5MiwxOTIsMjU1LFxuICogICAgICAgICAgIDE5MiwxOTIsMTkyLDI1NSxcbiAqICAgICAgICAgICAyNTUsMjU1LDI1NSwyNTUsXG4gKiAgICAgICAgIF0sXG4gKiAgICAgICB9LFxuICogICAgICAgLy8gYSAxeDIgcGl4ZWwgdGV4dHVyZSBmcm9tIGEgdHlwZWQgYXJyYXkuXG4gKiAgICAgICBzdHJpcGU6IHtcbiAqICAgICAgICAgbWFnOiBnbC5ORUFSRVNULFxuICogICAgICAgICBtaW46IGdsLkxJTkVBUixcbiAqICAgICAgICAgZm9ybWF0OiBnbC5MVU1JTkFOQ0UsXG4gKiAgICAgICAgIHNyYzogbmV3IFVpbnQ4QXJyYXkoW1xuICogICAgICAgICAgIDI1NSxcbiAqICAgICAgICAgICAxMjgsXG4gKiAgICAgICAgICAgMjU1LFxuICogICAgICAgICAgIDEyOCxcbiAqICAgICAgICAgICAyNTUsXG4gKiAgICAgICAgICAgMTI4LFxuICogICAgICAgICAgIDI1NSxcbiAqICAgICAgICAgICAxMjgsXG4gKiAgICAgICAgIF0pLFxuICogICAgICAgICB3aWR0aDogMSxcbiAqICAgICAgIH0sXG4gKiAgICAgfSk7XG4gKlxuICogTm93XG4gKlxuICogKiAgIGB0ZXh0dXJlcy5oZnRJY29uYCB3aWxsIGJlIGEgMmQgdGV4dHVyZVxuICogKiAgIGB0ZXh0dXJlcy5jbG92ZXJgIHdpbGwgYmUgYSAyZCB0ZXh0dXJlXG4gKiAqICAgYHRleHR1cmVzLmZyb21DYW52YXNgIHdpbGwgYmUgYSAyZCB0ZXh0dXJlXG4gKiAqICAgYHRleHR1cmVzLnlvaG9oYW1hYCB3aWxsIGJlIGEgY3ViZW1hcCB0ZXh0dXJlXG4gKiAqICAgYHRleHR1cmVzLmdvbGRlbmdhdGVgIHdpbGwgYmUgYSBjdWJlbWFwIHRleHR1cmVcbiAqICogICBgdGV4dHVyZXMuY2hlY2tlcmAgd2lsbCBiZSBhIDJkIHRleHR1cmVcbiAqICogICBgdGV4dHVyZXMuc3RyaXBlYCB3aWxsIGJlIGEgMmQgdGV4dHVyZVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zPn0gb3B0aW9ucyBBIG9iamVjdCBvZiBUZXh0dXJlT3B0aW9ucyBvbmUgcGVyIHRleHR1cmUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVzUmVhZHlDYWxsYmFja30gW2NhbGxiYWNrXSBBIGNhbGxiYWNrIGNhbGxlZCB3aGVuIGFsbCB0ZXh0dXJlcyBoYXZlIGJlZW4gZG93bmxvYWRlZC5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLFdlYkdMVGV4dHVyZT59IHRoZSBjcmVhdGVkIHRleHR1cmVzIGJ5IG5hbWVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZXMoZ2wsIHRleHR1cmVPcHRpb25zLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gIHZhciBudW1Eb3dubG9hZGluZyA9IDA7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHRleHR1cmVzID0ge307XG4gIHZhciBpbWFnZXMgPSB7fTtcblxuICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2tJZlJlYWR5KCkge1xuICAgIGlmIChudW1Eb3dubG9hZGluZyA9PT0gMCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9ycy5sZW5ndGggPyBlcnJvcnMgOiB1bmRlZmluZWQsIHRleHR1cmVzLCBpbWFnZXMpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXModGV4dHVyZU9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRleHR1cmVPcHRpb25zW25hbWVdO1xuICAgIHZhciBvbkxvYWRGbjtcblxuICAgIGlmIChpc0FzeW5jU3JjKG9wdGlvbnMuc3JjKSkge1xuICAgICAgb25Mb2FkRm4gPSBmdW5jdGlvbiBvbkxvYWRGbihlcnIsIHRleCwgaW1nKSB7XG4gICAgICAgIGltYWdlc1tuYW1lXSA9IGltZztcbiAgICAgICAgLS1udW1Eb3dubG9hZGluZztcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxDYWxsYmFja0lmUmVhZHkoKTtcbiAgICAgIH07XG5cbiAgICAgICsrbnVtRG93bmxvYWRpbmc7XG4gICAgfVxuXG4gICAgdGV4dHVyZXNbbmFtZV0gPSBjcmVhdGVUZXh0dXJlKGdsLCBvcHRpb25zLCBvbkxvYWRGbik7XG4gIH0pOyAvLyBxdWV1ZSB0aGUgY2FsbGJhY2sgaWYgdGhlcmUgYXJlIG5vIGltYWdlcyB0byBkb3dubG9hZC5cbiAgLy8gV2UgZG8gdGhpcyBiZWNhdXNlIGlmIHlvdXIgY29kZSBpcyBzdHJ1Y3R1cmVkIHRvIHdhaXQgZm9yXG4gIC8vIGltYWdlcyB0byBkb3dubG9hZCBidXQgdGhlbiB5b3UgY29tbWVudCBvdXQgYWxsIHRoZSBhc3luY1xuICAvLyBpbWFnZXMgeW91ciBjb2RlIHdvdWxkIGJyZWFrLlxuXG4gIGNhbGxDYWxsYmFja0lmUmVhZHkoKTtcbiAgcmV0dXJuIHRleHR1cmVzO1xufSAvLyBVc2luZyBxdW90ZXMgcHJldmVudHMgVWdsaWZ5IGZyb20gY2hhbmdpbmcgdGhlIG5hbWVzLlxuLy8gTm8gc3BlZWQgZGlmZiBBRkFJQ1QuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIF9leHBvcnROYW1lcyA9IHtcbiAgbTQ6IHRydWUsXG4gIHYzOiB0cnVlLFxuICBwcmltaXRpdmVzOiB0cnVlXG59O1xuZXhwb3J0cy5wcmltaXRpdmVzID0gZXhwb3J0cy52MyA9IGV4cG9ydHMubTQgPSB2b2lkIDA7XG5cbnZhciBtNCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXG5leHBvcnRzLm00ID0gbTQ7XG5cbnZhciB2MyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuXG5leHBvcnRzLnYzID0gdjM7XG5cbnZhciBwcmltaXRpdmVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygxMCkpO1xuXG5leHBvcnRzLnByaW1pdGl2ZXMgPSBwcmltaXRpdmVzO1xuXG52YXIgX3R3Z2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuT2JqZWN0LmtleXMoX3R3Z2wpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF90d2dsW2tleV07XG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNyZWF0ZTNERlZlcnRpY2VzID0gY3JlYXRlM0RGVmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5O1xuZXhwb3J0cy5jcmVhdGVDdWJlVmVydGljZXMgPSBjcmVhdGVDdWJlVmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZVBsYW5lVmVydGljZXMgPSBjcmVhdGVQbGFuZVZlcnRpY2VzO1xuZXhwb3J0cy5jcmVhdGVTcGhlcmVWZXJ0aWNlcyA9IGNyZWF0ZVNwaGVyZVZlcnRpY2VzO1xuZXhwb3J0cy5jcmVhdGVUcnVuY2F0ZWRDb25lVmVydGljZXMgPSBjcmVhdGVUcnVuY2F0ZWRDb25lVmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZVhZUXVhZFZlcnRpY2VzID0gY3JlYXRlWFlRdWFkVmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZUNyZXNlbnRWZXJ0aWNlcyA9IGNyZWF0ZUNyZXNlbnRWZXJ0aWNlcztcbmV4cG9ydHMuY3JlYXRlQ3lsaW5kZXJWZXJ0aWNlcyA9IGNyZWF0ZUN5bGluZGVyVmVydGljZXM7XG5leHBvcnRzLmNyZWF0ZVRvcnVzVmVydGljZXMgPSBjcmVhdGVUb3J1c1ZlcnRpY2VzO1xuZXhwb3J0cy5jcmVhdGVEaXNjVmVydGljZXMgPSBjcmVhdGVEaXNjVmVydGljZXM7XG5leHBvcnRzLmRlaW5kZXhWZXJ0aWNlcyA9IGRlaW5kZXhWZXJ0aWNlcztcbmV4cG9ydHMuZmxhdHRlbk5vcm1hbHMgPSBmbGF0dGVuTm9ybWFscztcbmV4cG9ydHMubWFrZVJhbmRvbVZlcnRleENvbG9ycyA9IG1ha2VSYW5kb21WZXJ0ZXhDb2xvcnM7XG5leHBvcnRzLnJlb3JpZW50RGlyZWN0aW9ucyA9IHJlb3JpZW50RGlyZWN0aW9ucztcbmV4cG9ydHMucmVvcmllbnROb3JtYWxzID0gcmVvcmllbnROb3JtYWxzO1xuZXhwb3J0cy5yZW9yaWVudFBvc2l0aW9ucyA9IHJlb3JpZW50UG9zaXRpb25zO1xuZXhwb3J0cy5yZW9yaWVudFZlcnRpY2VzID0gcmVvcmllbnRWZXJ0aWNlcztcbmV4cG9ydHMuY29uY2F0VmVydGljZXMgPSBjb25jYXRWZXJ0aWNlcztcbmV4cG9ydHMuZHVwbGljYXRlVmVydGljZXMgPSBkdXBsaWNhdGVWZXJ0aWNlcztcbmV4cG9ydHMuY3JlYXRlRGlzY0J1ZmZlcnMgPSBleHBvcnRzLmNyZWF0ZURpc2NCdWZmZXJJbmZvID0gZXhwb3J0cy5jcmVhdGVUb3J1c0J1ZmZlcnMgPSBleHBvcnRzLmNyZWF0ZVRvcnVzQnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlQ3lsaW5kZXJCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGVDeWxpbmRlckJ1ZmZlckluZm8gPSBleHBvcnRzLmNyZWF0ZUNyZXNlbnRCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGVDcmVzZW50QnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlWFlRdWFkQnVmZmVycyA9IGV4cG9ydHMuY3JlYXRlWFlRdWFkQnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlVHJ1bmNhdGVkQ29uZUJ1ZmZlcnMgPSBleHBvcnRzLmNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJJbmZvID0gZXhwb3J0cy5jcmVhdGVTcGhlcmVCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGVTcGhlcmVCdWZmZXJJbmZvID0gZXhwb3J0cy5jcmVhdGVQbGFuZUJ1ZmZlcnMgPSBleHBvcnRzLmNyZWF0ZVBsYW5lQnVmZmVySW5mbyA9IGV4cG9ydHMuY3JlYXRlQ3ViZUJ1ZmZlcnMgPSBleHBvcnRzLmNyZWF0ZUN1YmVCdWZmZXJJbmZvID0gZXhwb3J0cy5jcmVhdGUzREZCdWZmZXJzID0gZXhwb3J0cy5jcmVhdGUzREZCdWZmZXJJbmZvID0gdm9pZCAwO1xuXG52YXIgYXR0cmlidXRlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oNykpO1xuXG52YXIgaGVscGVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygwKSk7XG5cbnZhciB0eXBlZEFycmF5cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xuXG52YXIgbTQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKTtcblxudmFyIHYzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLypcbiAqIENvcHlyaWdodCAyMDE1LCBHcmVnZyBUYXZhcmVzLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuICogaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuICogZGlzdHJpYnV0aW9uLlxuICogICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiBHcmVnZyBUYXZhcmVzLiBub3IgdGhlIG5hbWVzIG9mIGhpc1xuICogY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qKlxuICogVmFyaW91cyBmdW5jdGlvbnMgdG8gbWFrZSBzaW1wbGUgcHJpbWl0aXZlc1xuICpcbiAqIG5vdGU6IE1vc3QgcHJpbWl0aXZlIGZ1bmN0aW9ucyBjb21lIGluIDMgc3R5bGVzXG4gKlxuICogKiAgYGNyZWF0ZVNvbWVTaGFwZUJ1ZmZlckluZm9gXG4gKlxuICogICAgVGhlc2UgZnVuY3Rpb25zIGFyZSBhbG1vc3QgYWx3YXlzIHRoZSBmdW5jdGlvbnMgeW91IHdhbnQgdG8gY2FsbC4gVGhleVxuICogICAgY3JlYXRlIHZlcnRpY2VzIHRoZW4gbWFrZSBXZWJHTEJ1ZmZlcnMgYW5kIGNyZWF0ZSB7QGxpbmsgbW9kdWxlOnR3Z2wuQXR0cmliSW5mb31zXG4gKiAgICByZXR1cmluZyBhIHtAbGluayBtb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSB5b3UgY2FuIHBhc3MgdG8ge0BsaW5rIG1vZHVsZTp0d2dsLnNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzfVxuICogICAgYW5kIHtAbGluayBtb2R1bGU6dHdnbC5kcmF3QnVmZmVySW5mb30gZXRjLi4uXG4gKlxuICogKiAgYGNyZWF0ZVNvbWVTaGFwZUJ1ZmZlcnNgXG4gKlxuICogICAgVGhlc2UgY3JlYXRlIFdlYkdMQnVmZmVycyBhbmQgcHV0IHlvdXIgZGF0YSBpbiB0aGVtIGJ1dCBub3RoaW5nIGVsc2UuXG4gKiAgICBJdCdzIGEgc2hvcnRjdXQgdG8gZG9pbmcgaXQgeW91cnNlbGYgaWYgeW91IGRvbid0IHdhbnQgdG8gdXNlXG4gKiAgICB0aGUgaGlnaGVyIGxldmVsIGZ1bmN0aW9ucy5cbiAqXG4gKiAqICBgY3JlYXRlU29tZVNoYXBlVmVydGljZXNgXG4gKlxuICogICAgVGhlc2UganVzdCBjcmVhdGUgdmVydGljZXMsIG5vIGJ1ZmZlcnMuIFRoaXMgYWxsb3dzIHlvdSB0byBtYW5pcHVsYXRlIHRoZSB2ZXJ0aWNlc1xuICogICAgb3IgYWRkIG1vcmUgZGF0YSBiZWZvcmUgZ2VuZXJhdGluZyBhIHtAbGluayBtb2R1bGU6dHdnbC5CdWZmZXJJbmZvfS4gT25jZSB5b3UncmUgZmluaXNoZWRcbiAqICAgIG1hbmlwdWxhdGluZyB0aGUgdmVydGljZXMgY2FsbCB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXN9LlxuICpcbiAqICAgIGV4YW1wbGU6XG4gKlxuICogICAgICAgIGNvbnN0IGFycmF5cyA9IHR3Z2wucHJpbWl0aXZlcy5jcmVhdGVQbGFuZUFycmF5cygxKTtcbiAqICAgICAgICB0d2dsLnByaW1pdGl2ZXMucmVvcmllbnRWZXJ0aWNlcyhhcnJheXMsIG00LnJvdGF0aW9uWChNYXRoLlBJICogMC41KSk7XG4gKiAgICAgICAgY29uc3QgYnVmZmVySW5mbyA9IHR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMoZ2wsIGFycmF5cyk7XG4gKlxuICogQG1vZHVsZSB0d2dsL3ByaW1pdGl2ZXNcbiAqL1xudmFyIGdldEFycmF5ID0gYXR0cmlidXRlcy5nZXRBcnJheV87IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxudmFyIGdldE51bUNvbXBvbmVudHMgPSBhdHRyaWJ1dGVzLmdldE51bUNvbXBvbmVudHNfOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQWRkIGBwdXNoYCB0byBhIHR5cGVkIGFycmF5LiBJdCBqdXN0IGtlZXBzIGEgJ2N1cnNvcidcbiAqIGFuZCBhbGxvd3MgdXNlIHRvIGBwdXNoYCB2YWx1ZXMgaW50byB0aGUgYXJyYXkgc28gd2VcbiAqIGRvbid0IGhhdmUgdG8gbWFudWFsbHkgY29tcHV0ZSBvZmZzZXRzXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHR5cGVkQXJyYXkgVHlwZWRBcnJheSB0byBhdWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gbnVtQ29tcG9uZW50cyBudW1iZXIgb2YgY29tcG9uZW50cy5cbiAqL1xuXG5mdW5jdGlvbiBhdWdtZW50VHlwZWRBcnJheSh0eXBlZEFycmF5LCBudW1Db21wb25lbnRzKSB7XG4gIHZhciBjdXJzb3IgPSAwO1xuXG4gIHR5cGVkQXJyYXkucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpaSkge1xuICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzW2lpXTtcblxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgfHwgdHlwZWRBcnJheXMuaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgZm9yICh2YXIgamogPSAwOyBqaiA8IHZhbHVlLmxlbmd0aDsgKytqaikge1xuICAgICAgICAgIHR5cGVkQXJyYXlbY3Vyc29yKytdID0gdmFsdWVbampdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlZEFycmF5W2N1cnNvcisrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0eXBlZEFycmF5LnJlc2V0ID0gZnVuY3Rpb24gKG9wdF9pbmRleCkge1xuICAgIGN1cnNvciA9IG9wdF9pbmRleCB8fCAwO1xuICB9O1xuXG4gIHR5cGVkQXJyYXkubnVtQ29tcG9uZW50cyA9IG51bUNvbXBvbmVudHM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlZEFycmF5LCAnbnVtRWxlbWVudHMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggLyB0aGlzLm51bUNvbXBvbmVudHMgfCAwO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0eXBlZEFycmF5O1xufVxuLyoqXG4gKiBjcmVhdGVzIGEgdHlwZWQgYXJyYXkgd2l0aCBhIGBwdXNoYCBmdW5jdGlvbiBhdHRhY2hlZFxuICogc28gdGhhdCB5b3UgY2FuIGVhc2lseSAqcHVzaCogdmFsdWVzLlxuICpcbiAqIGBwdXNoYCBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMuIElmIGFuIGFyZ3VtZW50IGlzIGFuIGFycmF5IGVhY2ggZWxlbWVudFxuICogb2YgdGhlIGFycmF5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHR5cGVkIGFycmF5LlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGFycmF5ID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCAyKTsgIC8vIGNyZWF0ZXMgYSBGbG9hdDMyQXJyYXkgd2l0aCA2IHZhbHVlc1xuICogICAgIGFycmF5LnB1c2goMSwgMiwgMyk7XG4gKiAgICAgYXJyYXkucHVzaChbNCwgNSwgNl0pO1xuICogICAgIC8vIGFycmF5IG5vdyBjb250YWlucyBbMSwgMiwgMywgNCwgNSwgNl1cbiAqXG4gKiBBbHNvIGhhcyBgbnVtQ29tcG9uZW50c2AgYW5kIGBudW1FbGVtZW50c2AgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtQ29tcG9uZW50cyBudW1iZXIgb2YgY29tcG9uZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG51bUVsZW1lbnRzIG51bWJlciBvZiBlbGVtZW50cy4gVGhlIHRvdGFsIHNpemUgb2YgdGhlIGFycmF5IHdpbGwgYmUgYG51bUNvbXBvbmVudHMgKiBudW1FbGVtZW50c2AuXG4gKiBAcGFyYW0ge2NvbnN0cnVjdG9yfSBvcHRfdHlwZSBBIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZS4gRGVmYXVsdCA9IGBGbG9hdDMyQXJyYXlgLlxuICogQHJldHVybiB7QXJyYXlCdWZmZXJWaWV3fSBBIHR5cGVkIGFycmF5LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkobnVtQ29tcG9uZW50cywgbnVtRWxlbWVudHMsIG9wdF90eXBlKSB7XG4gIHZhciBUeXBlID0gb3B0X3R5cGUgfHwgRmxvYXQzMkFycmF5O1xuICByZXR1cm4gYXVnbWVudFR5cGVkQXJyYXkobmV3IFR5cGUobnVtQ29tcG9uZW50cyAqIG51bUVsZW1lbnRzKSwgbnVtQ29tcG9uZW50cyk7XG59XG5cbmZ1bmN0aW9uIGFsbEJ1dEluZGljZXMobmFtZSkge1xuICByZXR1cm4gbmFtZSAhPT0gXCJpbmRpY2VzXCI7XG59XG4vKipcbiAqIEdpdmVuIGluZGV4ZWQgdmVydGljZXMgY3JlYXRlcyBhIG5ldyBzZXQgb2YgdmVydGljZXMgdW5pbmRleGVkIGJ5IGV4cGFuZGluZyB0aGUgaW5kZXhlZCB2ZXJ0aWNlcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSB2ZXJ0aWNlcyBUaGUgaW5kZXhlZCB2ZXJ0aWNlcyB0byBkZWluZGV4XG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBkZWluZGV4ZWQgdmVydGljZXNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiBkZWluZGV4VmVydGljZXModmVydGljZXMpIHtcbiAgdmFyIGluZGljZXMgPSB2ZXJ0aWNlcy5pbmRpY2VzO1xuICB2YXIgbmV3VmVydGljZXMgPSB7fTtcbiAgdmFyIG51bUVsZW1lbnRzID0gaW5kaWNlcy5sZW5ndGg7XG5cbiAgZnVuY3Rpb24gZXhwYW5kVG9VbmluZGV4ZWQoY2hhbm5lbCkge1xuICAgIHZhciBzcmNCdWZmZXIgPSB2ZXJ0aWNlc1tjaGFubmVsXTtcbiAgICB2YXIgbnVtQ29tcG9uZW50cyA9IHNyY0J1ZmZlci5udW1Db21wb25lbnRzO1xuICAgIHZhciBkc3RCdWZmZXIgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KG51bUNvbXBvbmVudHMsIG51bUVsZW1lbnRzLCBzcmNCdWZmZXIuY29uc3RydWN0b3IpO1xuXG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG51bUVsZW1lbnRzOyArK2lpKSB7XG4gICAgICB2YXIgbmR4ID0gaW5kaWNlc1tpaV07XG4gICAgICB2YXIgb2Zmc2V0ID0gbmR4ICogbnVtQ29tcG9uZW50cztcblxuICAgICAgZm9yICh2YXIgamogPSAwOyBqaiA8IG51bUNvbXBvbmVudHM7ICsramopIHtcbiAgICAgICAgZHN0QnVmZmVyLnB1c2goc3JjQnVmZmVyW29mZnNldCArIGpqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV3VmVydGljZXNbY2hhbm5lbF0gPSBkc3RCdWZmZXI7XG4gIH1cblxuICBPYmplY3Qua2V5cyh2ZXJ0aWNlcykuZmlsdGVyKGFsbEJ1dEluZGljZXMpLmZvckVhY2goZXhwYW5kVG9VbmluZGV4ZWQpO1xuICByZXR1cm4gbmV3VmVydGljZXM7XG59XG4vKipcbiAqIGZsYXR0ZW5zIHRoZSBub3JtYWxzIG9mIGRlaW5kZXhlZCB2ZXJ0aWNlcyBpbiBwbGFjZS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSB2ZXJ0aWNlcyBUaGUgZGVpbmRleGVkIHZlcnRpY2VzIHdobydzIG5vcm1hbHMgdG8gZmxhdHRlblxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgZmxhdHRlbmVkIHZlcnRpY2VzIChzYW1lIGFzIHdhcyBwYXNzZWQgaW4pXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gZmxhdHRlbk5vcm1hbHModmVydGljZXMpIHtcbiAgaWYgKHZlcnRpY2VzLmluZGljZXMpIHtcbiAgICB0aHJvdyBcImNhbid0IGZsYXR0ZW4gbm9ybWFscyBvZiBpbmRleGVkIHZlcnRpY2VzLiBkZWluZGV4IHRoZW0gZmlyc3RcIjtcbiAgfVxuXG4gIHZhciBub3JtYWxzID0gdmVydGljZXMubm9ybWFsO1xuICB2YXIgbnVtTm9ybWFscyA9IG5vcm1hbHMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1Ob3JtYWxzOyBpaSArPSA5KSB7XG4gICAgLy8gcHVsbCBvdXQgdGhlIDMgbm9ybWFscyBmb3IgdGhpcyB0cmlhbmdsZVxuICAgIHZhciBuYXggPSBub3JtYWxzW2lpICsgMF07XG4gICAgdmFyIG5heSA9IG5vcm1hbHNbaWkgKyAxXTtcbiAgICB2YXIgbmF6ID0gbm9ybWFsc1tpaSArIDJdO1xuICAgIHZhciBuYnggPSBub3JtYWxzW2lpICsgM107XG4gICAgdmFyIG5ieSA9IG5vcm1hbHNbaWkgKyA0XTtcbiAgICB2YXIgbmJ6ID0gbm9ybWFsc1tpaSArIDVdO1xuICAgIHZhciBuY3ggPSBub3JtYWxzW2lpICsgNl07XG4gICAgdmFyIG5jeSA9IG5vcm1hbHNbaWkgKyA3XTtcbiAgICB2YXIgbmN6ID0gbm9ybWFsc1tpaSArIDhdOyAvLyBhZGQgdGhlbVxuXG4gICAgdmFyIG54ID0gbmF4ICsgbmJ4ICsgbmN4O1xuICAgIHZhciBueSA9IG5heSArIG5ieSArIG5jeTtcbiAgICB2YXIgbnogPSBuYXogKyBuYnogKyBuY3o7IC8vIG5vcm1hbGl6ZSB0aGVtXG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KG54ICogbnggKyBueSAqIG55ICsgbnogKiBueik7XG4gICAgbnggLz0gbGVuZ3RoO1xuICAgIG55IC89IGxlbmd0aDtcbiAgICBueiAvPSBsZW5ndGg7IC8vIGNvcHkgdGhlbSBiYWNrIGluXG5cbiAgICBub3JtYWxzW2lpICsgMF0gPSBueDtcbiAgICBub3JtYWxzW2lpICsgMV0gPSBueTtcbiAgICBub3JtYWxzW2lpICsgMl0gPSBuejtcbiAgICBub3JtYWxzW2lpICsgM10gPSBueDtcbiAgICBub3JtYWxzW2lpICsgNF0gPSBueTtcbiAgICBub3JtYWxzW2lpICsgNV0gPSBuejtcbiAgICBub3JtYWxzW2lpICsgNl0gPSBueDtcbiAgICBub3JtYWxzW2lpICsgN10gPSBueTtcbiAgICBub3JtYWxzW2lpICsgOF0gPSBuejtcbiAgfVxuXG4gIHJldHVybiB2ZXJ0aWNlcztcbn1cblxuZnVuY3Rpb24gYXBwbHlGdW5jVG9WM0FycmF5KGFycmF5LCBtYXRyaXgsIGZuKSB7XG4gIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gIHZhciB0bXAgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW47IGlpICs9IDMpIHtcbiAgICBmbihtYXRyaXgsIFthcnJheVtpaV0sIGFycmF5W2lpICsgMV0sIGFycmF5W2lpICsgMl1dLCB0bXApO1xuICAgIGFycmF5W2lpXSA9IHRtcFswXTtcbiAgICBhcnJheVtpaSArIDFdID0gdG1wWzFdO1xuICAgIGFycmF5W2lpICsgMl0gPSB0bXBbMl07XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9ybWFsKG1pLCB2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IHYzLmNyZWF0ZSgpO1xuICB2YXIgdjAgPSB2WzBdO1xuICB2YXIgdjEgPSB2WzFdO1xuICB2YXIgdjIgPSB2WzJdO1xuICBkc3RbMF0gPSB2MCAqIG1pWzAgKiA0ICsgMF0gKyB2MSAqIG1pWzAgKiA0ICsgMV0gKyB2MiAqIG1pWzAgKiA0ICsgMl07XG4gIGRzdFsxXSA9IHYwICogbWlbMSAqIDQgKyAwXSArIHYxICogbWlbMSAqIDQgKyAxXSArIHYyICogbWlbMSAqIDQgKyAyXTtcbiAgZHN0WzJdID0gdjAgKiBtaVsyICogNCArIDBdICsgdjEgKiBtaVsyICogNCArIDFdICsgdjIgKiBtaVsyICogNCArIDJdO1xuICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBSZW9yaWVudHMgZGlyZWN0aW9ucyBieSB0aGUgZ2l2ZW4gbWF0cml4Li5cbiAqIEBwYXJhbSB7bnVtYmVyW118VHlwZWRBcnJheX0gYXJyYXkgVGhlIGFycmF5LiBBc3N1bWVzIHZhbHVlIGZsb2F0cyBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXggQSBtYXRyaXggdG8gbXVsdGlwbHkgYnkuXG4gKiBAcmV0dXJuIHtudW1iZXJbXXxUeXBlZEFycmF5fSB0aGUgc2FtZSBhcnJheSB0aGF0IHdhcyBwYXNzZWQgaW5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiByZW9yaWVudERpcmVjdGlvbnMoYXJyYXksIG1hdHJpeCkge1xuICBhcHBseUZ1bmNUb1YzQXJyYXkoYXJyYXksIG1hdHJpeCwgbTQudHJhbnNmb3JtRGlyZWN0aW9uKTtcbiAgcmV0dXJuIGFycmF5O1xufVxuLyoqXG4gKiBSZW9yaWVudHMgbm9ybWFscyBieSB0aGUgaW52ZXJzZS10cmFuc3Bvc2Ugb2YgdGhlIGdpdmVuXG4gKiBtYXRyaXguLlxuICogQHBhcmFtIHtudW1iZXJbXXxUeXBlZEFycmF5fSBhcnJheSBUaGUgYXJyYXkuIEFzc3VtZXMgdmFsdWUgZmxvYXRzIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeCBBIG1hdHJpeCB0byBtdWx0aXBseSBieS5cbiAqIEByZXR1cm4ge251bWJlcltdfFR5cGVkQXJyYXl9IHRoZSBzYW1lIGFycmF5IHRoYXQgd2FzIHBhc3NlZCBpblxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlb3JpZW50Tm9ybWFscyhhcnJheSwgbWF0cml4KSB7XG4gIGFwcGx5RnVuY1RvVjNBcnJheShhcnJheSwgbTQuaW52ZXJzZShtYXRyaXgpLCB0cmFuc2Zvcm1Ob3JtYWwpO1xuICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIFJlb3JpZW50cyBwb3NpdGlvbnMgYnkgdGhlIGdpdmVuIG1hdHJpeC4gSW4gb3RoZXIgd29yZHMsIGl0XG4gKiBtdWx0aXBsaWVzIGVhY2ggdmVydGV4IGJ5IHRoZSBnaXZlbiBtYXRyaXguXG4gKiBAcGFyYW0ge251bWJlcltdfFR5cGVkQXJyYXl9IGFycmF5IFRoZSBhcnJheS4gQXNzdW1lcyB2YWx1ZSBmbG9hdHMgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4IEEgbWF0cml4IHRvIG11bHRpcGx5IGJ5LlxuICogQHJldHVybiB7bnVtYmVyW118VHlwZWRBcnJheX0gdGhlIHNhbWUgYXJyYXkgdGhhdCB3YXMgcGFzc2VkIGluXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gcmVvcmllbnRQb3NpdGlvbnMoYXJyYXksIG1hdHJpeCkge1xuICBhcHBseUZ1bmNUb1YzQXJyYXkoYXJyYXksIG1hdHJpeCwgbTQudHJhbnNmb3JtUG9pbnQpO1xuICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIFJlb3JpZW50cyBhcnJheXMgYnkgdGhlIGdpdmVuIG1hdHJpeC4gQXNzdW1lcyBhcnJheXMgaGF2ZVxuICogbmFtZXMgdGhhdCBjb250YWlucyAncG9zJyBjb3VsZCBiZSByZW9yaWVudGVkIGFzIHBvc2l0aW9ucyxcbiAqICdiaW5vcm0nIG9yICd0YW4nIGFzIGRpcmVjdGlvbnMsIGFuZCAnbm9ybScgYXMgbm9ybWFscy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCAobnVtYmVyW118VHlwZWRBcnJheSk+fSBhcnJheXMgVGhlIHZlcnRpY2VzIHRvIHJlb3JpZW50XG4gKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4IG1hdHJpeCB0byByZW9yaWVudCBieS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCAobnVtYmVyW118VHlwZWRBcnJheSk+fSBzYW1lIGFycmF5cyB0aGF0IHdlcmUgcGFzc2VkIGluLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlb3JpZW50VmVydGljZXMoYXJyYXlzLCBtYXRyaXgpIHtcbiAgT2JqZWN0LmtleXMoYXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGFycmF5ID0gYXJyYXlzW25hbWVdO1xuXG4gICAgaWYgKG5hbWUuaW5kZXhPZihcInBvc1wiKSA+PSAwKSB7XG4gICAgICByZW9yaWVudFBvc2l0aW9ucyhhcnJheSwgbWF0cml4KTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuaW5kZXhPZihcInRhblwiKSA+PSAwIHx8IG5hbWUuaW5kZXhPZihcImJpbm9ybVwiKSA+PSAwKSB7XG4gICAgICByZW9yaWVudERpcmVjdGlvbnMoYXJyYXksIG1hdHJpeCk7XG4gICAgfSBlbHNlIGlmIChuYW1lLmluZGV4T2YoXCJub3JtXCIpID49IDApIHtcbiAgICAgIHJlb3JpZW50Tm9ybWFscyhhcnJheSwgbWF0cml4KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXJyYXlzO1xufVxuLyoqXG4gKiBDcmVhdGVzIFhZIHF1YWQgQnVmZmVySW5mb1xuICpcbiAqIFRoZSBkZWZhdWx0IHdpdGggbm8gcGFyYW1ldGVycyB3aWxsIHJldHVybiBhIDJ4MiBxdWFkIHdpdGggdmFsdWVzIGZyb20gLTEgdG8gKzEuXG4gKiBJZiB5b3Ugd2FudCBhIHVuaXQgcXVhZCB3aXRoIHRoYXQgZ29lcyBmcm9tIDAgdG8gMSB5b3UnZCBjYWxsIGl0IHdpdGhcbiAqXG4gKiAgICAgdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8oZ2wsIDEsIDAuNSwgMC41KTtcbiAqXG4gKiBJZiB5b3Ugd2FudCBhIHVuaXQgcXVhZCBjZW50ZXJlZCBhYm92ZSAwLDAgeW91J2QgY2FsbCBpdCB3aXRoXG4gKlxuICogICAgIHR3Z2wucHJpbWl0aXZlcy5jcmVhdGVYWVF1YWRCdWZmZXJJbmZvKGdsLCAxLCAwLCAwLjUpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB0aGUgc2l6ZSBhY3Jvc3MgdGhlIHF1YWQuIERlZmF1bHRzIHRvIDIgd2hpY2ggbWVhbnMgdmVydGljZXMgd2lsbCBnbyBmcm9tIC0xIHRvICsxXG4gKiBAcGFyYW0ge251bWJlcn0gW3hPZmZzZXRdIHRoZSBhbW91bnQgdG8gb2Zmc2V0IHRoZSBxdWFkIGluIFhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeU9mZnNldF0gdGhlIGFtb3VudCB0byBvZmZzZXQgdGhlIHF1YWQgaW4gWVxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFdlYkdMQnVmZmVyPn0gdGhlIGNyZWF0ZWQgWFkgUXVhZCBCdWZmZXJJbmZvXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVhZUXVhZEJ1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgWFkgcXVhZCBCdWZmZXJzXG4gKlxuICogVGhlIGRlZmF1bHQgd2l0aCBubyBwYXJhbWV0ZXJzIHdpbGwgcmV0dXJuIGEgMngyIHF1YWQgd2l0aCB2YWx1ZXMgZnJvbSAtMSB0byArMS5cbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIHdpdGggdGhhdCBnb2VzIGZyb20gMCB0byAxIHlvdSdkIGNhbGwgaXQgd2l0aFxuICpcbiAqICAgICB0d2dsLnByaW1pdGl2ZXMuY3JlYXRlWFlRdWFkQnVmZmVySW5mbyhnbCwgMSwgMC41LCAwLjUpO1xuICpcbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIGNlbnRlcmVkIGFib3ZlIDAsMCB5b3UnZCBjYWxsIGl0IHdpdGhcbiAqXG4gKiAgICAgdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8oZ2wsIDEsIDAsIDAuNSk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemVdIHRoZSBzaXplIGFjcm9zcyB0aGUgcXVhZC4gRGVmYXVsdHMgdG8gMiB3aGljaCBtZWFucyB2ZXJ0aWNlcyB3aWxsIGdvIGZyb20gLTEgdG8gKzFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeE9mZnNldF0gdGhlIGFtb3VudCB0byBvZmZzZXQgdGhlIHF1YWQgaW4gWFxuICogQHBhcmFtIHtudW1iZXJ9IFt5T2Zmc2V0XSB0aGUgYW1vdW50IHRvIG9mZnNldCB0aGUgcXVhZCBpbiBZXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSB0aGUgY3JlYXRlZCBYWSBRdWFkIGJ1ZmZlcnNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlWFlRdWFkQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBYWSBxdWFkIHZlcnRpY2VzXG4gKlxuICogVGhlIGRlZmF1bHQgd2l0aCBubyBwYXJhbWV0ZXJzIHdpbGwgcmV0dXJuIGEgMngyIHF1YWQgd2l0aCB2YWx1ZXMgZnJvbSAtMSB0byArMS5cbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIHdpdGggdGhhdCBnb2VzIGZyb20gMCB0byAxIHlvdSdkIGNhbGwgaXQgd2l0aFxuICpcbiAqICAgICB0d2dsLnByaW1pdGl2ZXMuY3JlYXRlWFlRdWFkVmVydGljZXMoMSwgMC41LCAwLjUpO1xuICpcbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIGNlbnRlcmVkIGFib3ZlIDAsMCB5b3UnZCBjYWxsIGl0IHdpdGhcbiAqXG4gKiAgICAgdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVhZUXVhZFZlcnRpY2VzKDEsIDAsIDAuNSk7XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB0aGUgc2l6ZSBhY3Jvc3MgdGhlIHF1YWQuIERlZmF1bHRzIHRvIDIgd2hpY2ggbWVhbnMgdmVydGljZXMgd2lsbCBnbyBmcm9tIC0xIHRvICsxXG4gKiBAcGFyYW0ge251bWJlcn0gW3hPZmZzZXRdIHRoZSBhbW91bnQgdG8gb2Zmc2V0IHRoZSBxdWFkIGluIFhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeU9mZnNldF0gdGhlIGFtb3VudCB0byBvZmZzZXQgdGhlIHF1YWQgaW4gWVxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+IHRoZSBjcmVhdGVkIFhZIFF1YWQgdmVydGljZXNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVYWVF1YWRWZXJ0aWNlcyhzaXplLCB4T2Zmc2V0LCB5T2Zmc2V0KSB7XG4gIHNpemUgPSBzaXplIHx8IDI7XG4gIHhPZmZzZXQgPSB4T2Zmc2V0IHx8IDA7XG4gIHlPZmZzZXQgPSB5T2Zmc2V0IHx8IDA7XG4gIHNpemUgKj0gMC41O1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiB7XG4gICAgICBudW1Db21wb25lbnRzOiAyLFxuICAgICAgZGF0YTogW3hPZmZzZXQgKyAtMSAqIHNpemUsIHlPZmZzZXQgKyAtMSAqIHNpemUsIHhPZmZzZXQgKyAxICogc2l6ZSwgeU9mZnNldCArIC0xICogc2l6ZSwgeE9mZnNldCArIC0xICogc2l6ZSwgeU9mZnNldCArIDEgKiBzaXplLCB4T2Zmc2V0ICsgMSAqIHNpemUsIHlPZmZzZXQgKyAxICogc2l6ZV1cbiAgICB9LFxuICAgIG5vcm1hbDogWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdLFxuICAgIHRleGNvb3JkOiBbMCwgMCwgMSwgMCwgMCwgMSwgMSwgMV0sXG4gICAgaW5kaWNlczogWzAsIDEsIDIsIDIsIDEsIDNdXG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgWFogcGxhbmUgQnVmZmVySW5mby5cbiAqXG4gKiBUaGUgY3JlYXRlZCBwbGFuZSBoYXMgcG9zaXRpb24sIG5vcm1hbCwgYW5kIHRleGNvb3JkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIFdpZHRoIG9mIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGhdIERlcHRoIG9mIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3ViZGl2aXNpb25zV2lkdGhdIE51bWJlciBvZiBzdGVwcyBhY3Jvc3MgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtzdWJkaXZpc2lvbnNEZXB0aF0gTnVtYmVyIG9mIHN0ZXBzIGRvd24gdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtNYXRyaXg0fSBbbWF0cml4XSBBIG1hdHJpeCBieSB3aGljaCB0byBtdWx0aXBseSBhbGwgdGhlIHZlcnRpY2VzLlxuICogQHJldHVybiB7QG1vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIHBsYW5lIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVBsYW5lQnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBYWiBwbGFuZSBidWZmZXJzLlxuICpcbiAqIFRoZSBjcmVhdGVkIHBsYW5lIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCBhbmQgdGV4Y29vcmQgZGF0YVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gV2lkdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aF0gRGVwdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtzdWJkaXZpc2lvbnNXaWR0aF0gTnVtYmVyIG9mIHN0ZXBzIGFjcm9zcyB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3N1YmRpdmlzaW9uc0RlcHRoXSBOdW1iZXIgb2Ygc3RlcHMgZG93biB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge01hdHJpeDR9IFttYXRyaXhdIEEgbWF0cml4IGJ5IHdoaWNoIHRvIG11bHRpcGx5IGFsbCB0aGUgdmVydGljZXMuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBwbGFuZSBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVQbGFuZUJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgWFogcGxhbmUgdmVydGljZXMuXG4gKlxuICogVGhlIGNyZWF0ZWQgcGxhbmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gV2lkdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aF0gRGVwdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtzdWJkaXZpc2lvbnNXaWR0aF0gTnVtYmVyIG9mIHN0ZXBzIGFjcm9zcyB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3N1YmRpdmlzaW9uc0RlcHRoXSBOdW1iZXIgb2Ygc3RlcHMgZG93biB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge01hdHJpeDR9IFttYXRyaXhdIEEgbWF0cml4IGJ5IHdoaWNoIHRvIG11bHRpcGx5IGFsbCB0aGUgdmVydGljZXMuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHBsYW5lIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBsYW5lVmVydGljZXMod2lkdGgsIGRlcHRoLCBzdWJkaXZpc2lvbnNXaWR0aCwgc3ViZGl2aXNpb25zRGVwdGgsIG1hdHJpeCkge1xuICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gIGRlcHRoID0gZGVwdGggfHwgMTtcbiAgc3ViZGl2aXNpb25zV2lkdGggPSBzdWJkaXZpc2lvbnNXaWR0aCB8fCAxO1xuICBzdWJkaXZpc2lvbnNEZXB0aCA9IHN1YmRpdmlzaW9uc0RlcHRoIHx8IDE7XG4gIG1hdHJpeCA9IG1hdHJpeCB8fCBtNC5pZGVudGl0eSgpO1xuICB2YXIgbnVtVmVydGljZXMgPSAoc3ViZGl2aXNpb25zV2lkdGggKyAxKSAqIChzdWJkaXZpc2lvbnNEZXB0aCArIDEpO1xuICB2YXIgcG9zaXRpb25zID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciBub3JtYWxzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciB0ZXhjb29yZHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIG51bVZlcnRpY2VzKTtcblxuICBmb3IgKHZhciB6ID0gMDsgeiA8PSBzdWJkaXZpc2lvbnNEZXB0aDsgeisrKSB7XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPD0gc3ViZGl2aXNpb25zV2lkdGg7IHgrKykge1xuICAgICAgdmFyIHUgPSB4IC8gc3ViZGl2aXNpb25zV2lkdGg7XG4gICAgICB2YXIgdiA9IHogLyBzdWJkaXZpc2lvbnNEZXB0aDtcbiAgICAgIHBvc2l0aW9ucy5wdXNoKHdpZHRoICogdSAtIHdpZHRoICogMC41LCAwLCBkZXB0aCAqIHYgLSBkZXB0aCAqIDAuNSk7XG4gICAgICBub3JtYWxzLnB1c2goMCwgMSwgMCk7XG4gICAgICB0ZXhjb29yZHMucHVzaCh1LCB2KTtcbiAgICB9XG4gIH1cblxuICB2YXIgbnVtVmVydHNBY3Jvc3MgPSBzdWJkaXZpc2lvbnNXaWR0aCArIDE7XG4gIHZhciBpbmRpY2VzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBzdWJkaXZpc2lvbnNXaWR0aCAqIHN1YmRpdmlzaW9uc0RlcHRoICogMiwgVWludDE2QXJyYXkpO1xuXG4gIGZvciAodmFyIF96ID0gMDsgX3ogPCBzdWJkaXZpc2lvbnNEZXB0aDsgX3orKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmb3IgKHZhciBfeCA9IDA7IF94IDwgc3ViZGl2aXNpb25zV2lkdGg7IF94KyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIE1ha2UgdHJpYW5nbGUgMSBvZiBxdWFkLlxuICAgICAgaW5kaWNlcy5wdXNoKChfeiArIDApICogbnVtVmVydHNBY3Jvc3MgKyBfeCwgKF96ICsgMSkgKiBudW1WZXJ0c0Fjcm9zcyArIF94LCAoX3ogKyAwKSAqIG51bVZlcnRzQWNyb3NzICsgX3ggKyAxKTsgLy8gTWFrZSB0cmlhbmdsZSAyIG9mIHF1YWQuXG5cbiAgICAgIGluZGljZXMucHVzaCgoX3ogKyAxKSAqIG51bVZlcnRzQWNyb3NzICsgX3gsIChfeiArIDEpICogbnVtVmVydHNBY3Jvc3MgKyBfeCArIDEsIChfeiArIDApICogbnVtVmVydHNBY3Jvc3MgKyBfeCArIDEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhcnJheXMgPSByZW9yaWVudFZlcnRpY2VzKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXNcbiAgfSwgbWF0cml4KTtcbiAgcmV0dXJuIGFycmF5cztcbn1cbi8qKlxuICogQ3JlYXRlcyBzcGhlcmUgQnVmZmVySW5mby5cbiAqXG4gKiBUaGUgY3JlYXRlZCBzcGhlcmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIHJhZGl1cyBvZiB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0F4aXMgbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0hlaWdodCBudW1iZXIgb2YgdmVydGljYWxseSBvbiB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gc3RhcnQgdGhlXG4gKiAgICAgdG9wIG9mIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnNdIFdoZXJlIHRvIGVuZCB0aGVcbiAqICAgICBib3R0b20gb2YgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IE1hdGguUEkuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9zdGFydExvbmdpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gc3RhcnRcbiAqICAgICB3cmFwcGluZyB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X2VuZExvbmdpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gZW5kXG4gKiAgICAgd3JhcHBpbmcgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDIgKiBNYXRoLlBJLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgc3BoZXJlIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVNwaGVyZUJ1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgc3BoZXJlIGJ1ZmZlcnMuXG4gKlxuICogVGhlIGNyZWF0ZWQgc3BoZXJlIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCBhbmQgdGV4Y29vcmQgZGF0YVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyByYWRpdXMgb2YgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNBeGlzIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNIZWlnaHQgbnVtYmVyIG9mIHZlcnRpY2FsbHkgb24gdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0IHRoZVxuICogICAgIHRvcCBvZiB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zXSBXaGVyZSB0byBlbmQgdGhlXG4gKiAgICAgYm90dG9tIG9mIHRoZSBzcGhlcmUuIERlZmF1bHQgPSBNYXRoLlBJLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0XG4gKiAgICAgd3JhcHBpbmcgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9lbmRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIGVuZFxuICogICAgIHdyYXBwaW5nIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAyICogTWF0aC5QSS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIHNwaGVyZSBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVTcGhlcmVCdWZmZXJzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHNwaGVyZSB2ZXJ0aWNlcy5cbiAqXG4gKiBUaGUgY3JlYXRlZCBzcGhlcmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyByYWRpdXMgb2YgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNBeGlzIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNIZWlnaHQgbnVtYmVyIG9mIHZlcnRpY2FsbHkgb24gdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0IHRoZVxuICogICAgIHRvcCBvZiB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zXSBXaGVyZSB0byBlbmQgdGhlXG4gKiAgICAgYm90dG9tIG9mIHRoZSBzcGhlcmUuIERlZmF1bHQgPSBNYXRoLlBJLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0XG4gKiAgICAgd3JhcHBpbmcgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9lbmRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIGVuZFxuICogICAgIHdyYXBwaW5nIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAyICogTWF0aC5QSS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgc3BoZXJlIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNwaGVyZVZlcnRpY2VzKHJhZGl1cywgc3ViZGl2aXNpb25zQXhpcywgc3ViZGl2aXNpb25zSGVpZ2h0LCBvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFucywgb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zLCBvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnMsIG9wdF9lbmRMb25naXR1ZGVJblJhZGlhbnMpIHtcbiAgaWYgKHN1YmRpdmlzaW9uc0F4aXMgPD0gMCB8fCBzdWJkaXZpc2lvbnNIZWlnaHQgPD0gMCkge1xuICAgIHRocm93IEVycm9yKCdzdWJkaXZpc2lvbkF4aXMgYW5kIHN1YmRpdmlzaW9uSGVpZ2h0IG11c3QgYmUgPiAwJyk7XG4gIH1cblxuICBvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFucyA9IG9wdF9zdGFydExhdGl0dWRlSW5SYWRpYW5zIHx8IDA7XG4gIG9wdF9lbmRMYXRpdHVkZUluUmFkaWFucyA9IG9wdF9lbmRMYXRpdHVkZUluUmFkaWFucyB8fCBNYXRoLlBJO1xuICBvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnMgPSBvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnMgfHwgMDtcbiAgb3B0X2VuZExvbmdpdHVkZUluUmFkaWFucyA9IG9wdF9lbmRMb25naXR1ZGVJblJhZGlhbnMgfHwgTWF0aC5QSSAqIDI7XG4gIHZhciBsYXRSYW5nZSA9IG9wdF9lbmRMYXRpdHVkZUluUmFkaWFucyAtIG9wdF9zdGFydExhdGl0dWRlSW5SYWRpYW5zO1xuICB2YXIgbG9uZ1JhbmdlID0gb3B0X2VuZExvbmdpdHVkZUluUmFkaWFucyAtIG9wdF9zdGFydExvbmdpdHVkZUluUmFkaWFuczsgLy8gV2UgYXJlIGdvaW5nIHRvIGdlbmVyYXRlIG91ciBzcGhlcmUgYnkgaXRlcmF0aW5nIHRocm91Z2ggaXRzXG4gIC8vIHNwaGVyaWNhbCBjb29yZGluYXRlcyBhbmQgZ2VuZXJhdGluZyAyIHRyaWFuZ2xlcyBmb3IgZWFjaCBxdWFkIG9uIGFcbiAgLy8gcmluZyBvZiB0aGUgc3BoZXJlLlxuXG4gIHZhciBudW1WZXJ0aWNlcyA9IChzdWJkaXZpc2lvbnNBeGlzICsgMSkgKiAoc3ViZGl2aXNpb25zSGVpZ2h0ICsgMSk7XG4gIHZhciBwb3NpdGlvbnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIG5vcm1hbHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIHRleGNvb3JkcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgbnVtVmVydGljZXMpOyAvLyBHZW5lcmF0ZSB0aGUgaW5kaXZpZHVhbCB2ZXJ0aWNlcyBpbiBvdXIgdmVydGV4IGJ1ZmZlci5cblxuICBmb3IgKHZhciB5ID0gMDsgeSA8PSBzdWJkaXZpc2lvbnNIZWlnaHQ7IHkrKykge1xuICAgIGZvciAodmFyIHggPSAwOyB4IDw9IHN1YmRpdmlzaW9uc0F4aXM7IHgrKykge1xuICAgICAgLy8gR2VuZXJhdGUgYSB2ZXJ0ZXggYmFzZWQgb24gaXRzIHNwaGVyaWNhbCBjb29yZGluYXRlc1xuICAgICAgdmFyIHUgPSB4IC8gc3ViZGl2aXNpb25zQXhpcztcbiAgICAgIHZhciB2ID0geSAvIHN1YmRpdmlzaW9uc0hlaWdodDtcbiAgICAgIHZhciB0aGV0YSA9IGxvbmdSYW5nZSAqIHU7XG4gICAgICB2YXIgcGhpID0gbGF0UmFuZ2UgKiB2O1xuICAgICAgdmFyIHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgdmFyIGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHNpblBoaSA9IE1hdGguc2luKHBoaSk7XG4gICAgICB2YXIgY29zUGhpID0gTWF0aC5jb3MocGhpKTtcbiAgICAgIHZhciB1eCA9IGNvc1RoZXRhICogc2luUGhpO1xuICAgICAgdmFyIHV5ID0gY29zUGhpO1xuICAgICAgdmFyIHV6ID0gc2luVGhldGEgKiBzaW5QaGk7XG4gICAgICBwb3NpdGlvbnMucHVzaChyYWRpdXMgKiB1eCwgcmFkaXVzICogdXksIHJhZGl1cyAqIHV6KTtcbiAgICAgIG5vcm1hbHMucHVzaCh1eCwgdXksIHV6KTtcbiAgICAgIHRleGNvb3Jkcy5wdXNoKDEgLSB1LCB2KTtcbiAgICB9XG4gIH1cblxuICB2YXIgbnVtVmVydHNBcm91bmQgPSBzdWJkaXZpc2lvbnNBeGlzICsgMTtcbiAgdmFyIGluZGljZXMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIHN1YmRpdmlzaW9uc0F4aXMgKiBzdWJkaXZpc2lvbnNIZWlnaHQgKiAyLCBVaW50MTZBcnJheSk7XG5cbiAgZm9yICh2YXIgX3gyID0gMDsgX3gyIDwgc3ViZGl2aXNpb25zQXhpczsgX3gyKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZm9yICh2YXIgX3kgPSAwOyBfeSA8IHN1YmRpdmlzaW9uc0hlaWdodDsgX3krKykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLy8gTWFrZSB0cmlhbmdsZSAxIG9mIHF1YWQuXG4gICAgICBpbmRpY2VzLnB1c2goKF95ICsgMCkgKiBudW1WZXJ0c0Fyb3VuZCArIF94MiwgKF95ICsgMCkgKiBudW1WZXJ0c0Fyb3VuZCArIF94MiArIDEsIChfeSArIDEpICogbnVtVmVydHNBcm91bmQgKyBfeDIpOyAvLyBNYWtlIHRyaWFuZ2xlIDIgb2YgcXVhZC5cblxuICAgICAgaW5kaWNlcy5wdXNoKChfeSArIDEpICogbnVtVmVydHNBcm91bmQgKyBfeDIsIChfeSArIDApICogbnVtVmVydHNBcm91bmQgKyBfeDIgKyAxLCAoX3kgKyAxKSAqIG51bVZlcnRzQXJvdW5kICsgX3gyICsgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXNcbiAgfTtcbn1cbi8qKlxuICogQXJyYXkgb2YgdGhlIGluZGljZXMgb2YgY29ybmVycyBvZiBlYWNoIGZhY2Ugb2YgYSBjdWJlLlxuICogQHR5cGUge0FycmF5LjxudW1iZXJbXT59XG4gKi9cblxuXG52YXIgQ1VCRV9GQUNFX0lORElDRVMgPSBbWzMsIDcsIDUsIDFdLCAvLyByaWdodFxuWzYsIDIsIDAsIDRdLCAvLyBsZWZ0XG5bNiwgNywgMywgMl0sIC8vID8/XG5bMCwgMSwgNSwgNF0sIC8vID8/XG5bNywgNiwgNCwgNV0sIC8vIGZyb250XG5bMiwgMywgMSwgMF1dO1xuLyoqXG4gKiBDcmVhdGVzIGEgQnVmZmVySW5mbyBmb3IgYSBjdWJlLlxuICpcbiAqIFRoZSBjdWJlIGlzIGNyZWF0ZWQgYXJvdW5kIHRoZSBvcmlnaW4uICgtc2l6ZSAvIDIsIHNpemUgLyAyKS5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZV0gd2lkdGgsIGhlaWdodCBhbmQgZGVwdGggb2YgdGhlIGN1YmUuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBUaGUgY3JlYXRlZCBCdWZmZXJJbmZvLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDdWJlQnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgYnVmZmVycyBhbmQgaW5kaWNlcyBmb3IgYSBjdWJlLlxuICpcbiAqIFRoZSBjdWJlIGlzIGNyZWF0ZWQgYXJvdW5kIHRoZSBvcmlnaW4uICgtc2l6ZSAvIDIsIHNpemUgLyAyKS5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZV0gd2lkdGgsIGhlaWdodCBhbmQgZGVwdGggb2YgdGhlIGN1YmUuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDdWJlQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgdmVydGljZXMgYW5kIGluZGljZXMgZm9yIGEgY3ViZS5cbiAqXG4gKiBUaGUgY3ViZSBpcyBjcmVhdGVkIGFyb3VuZCB0aGUgb3JpZ2luLiAoLXNpemUgLyAyLCBzaXplIC8gMikuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB3aWR0aCwgaGVpZ2h0IGFuZCBkZXB0aCBvZiB0aGUgY3ViZS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUN1YmVWZXJ0aWNlcyhzaXplKSB7XG4gIHNpemUgPSBzaXplIHx8IDE7XG4gIHZhciBrID0gc2l6ZSAvIDI7XG4gIHZhciBjb3JuZXJWZXJ0aWNlcyA9IFtbLWssIC1rLCAta10sIFsraywgLWssIC1rXSwgWy1rLCAraywgLWtdLCBbK2ssICtrLCAta10sIFstaywgLWssICtrXSwgWytrLCAtaywgK2tdLCBbLWssICtrLCAra10sIFsraywgK2ssICtrXV07XG4gIHZhciBmYWNlTm9ybWFscyA9IFtbKzEsICswLCArMF0sIFstMSwgKzAsICswXSwgWyswLCArMSwgKzBdLCBbKzAsIC0xLCArMF0sIFsrMCwgKzAsICsxXSwgWyswLCArMCwgLTFdXTtcbiAgdmFyIHV2Q29vcmRzID0gW1sxLCAwXSwgWzAsIDBdLCBbMCwgMV0sIFsxLCAxXV07XG4gIHZhciBudW1WZXJ0aWNlcyA9IDYgKiA0O1xuICB2YXIgcG9zaXRpb25zID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciBub3JtYWxzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIHZhciB0ZXhjb29yZHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIG51bVZlcnRpY2VzKTtcbiAgdmFyIGluZGljZXMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIDYgKiAyLCBVaW50MTZBcnJheSk7XG5cbiAgZm9yICh2YXIgZiA9IDA7IGYgPCA2OyArK2YpIHtcbiAgICB2YXIgZmFjZUluZGljZXMgPSBDVUJFX0ZBQ0VfSU5ESUNFU1tmXTtcblxuICAgIGZvciAodmFyIHYgPSAwOyB2IDwgNDsgKyt2KSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBjb3JuZXJWZXJ0aWNlc1tmYWNlSW5kaWNlc1t2XV07XG4gICAgICB2YXIgbm9ybWFsID0gZmFjZU5vcm1hbHNbZl07XG4gICAgICB2YXIgdXYgPSB1dkNvb3Jkc1t2XTsgLy8gRWFjaCBmYWNlIG5lZWRzIGFsbCBmb3VyIHZlcnRpY2VzIGJlY2F1c2UgdGhlIG5vcm1hbHMgYW5kIHRleHR1cmVcbiAgICAgIC8vIGNvb3JkaW5hdGVzIGFyZSBub3QgYWxsIHRoZSBzYW1lLlxuXG4gICAgICBwb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gICAgICBub3JtYWxzLnB1c2gobm9ybWFsKTtcbiAgICAgIHRleGNvb3Jkcy5wdXNoKHV2KTtcbiAgICB9IC8vIFR3byB0cmlhbmdsZXMgbWFrZSBhIHNxdWFyZSBmYWNlLlxuXG5cbiAgICB2YXIgb2Zmc2V0ID0gNCAqIGY7XG4gICAgaW5kaWNlcy5wdXNoKG9mZnNldCArIDAsIG9mZnNldCArIDEsIG9mZnNldCArIDIpO1xuICAgIGluZGljZXMucHVzaChvZmZzZXQgKyAwLCBvZmZzZXQgKyAyLCBvZmZzZXQgKyAzKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9ucyxcbiAgICBub3JtYWw6IG5vcm1hbHMsXG4gICAgdGV4Y29vcmQ6IHRleGNvb3JkcyxcbiAgICBpbmRpY2VzOiBpbmRpY2VzXG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBCdWZmZXJJbmZvIGZvciBhIHRydW5jYXRlZCBjb25lLCB3aGljaCBpcyBsaWtlIGEgY3lsaW5kZXJcbiAqIGV4Y2VwdCB0aGF0IGl0IGhhcyBkaWZmZXJlbnQgdG9wIGFuZCBib3R0b20gcmFkaWkuIEEgdHJ1bmNhdGVkIGNvbmVcbiAqIGNhbiBhbHNvIGJlIHVzZWQgdG8gY3JlYXRlIGN5bGluZGVycyBhbmQgcmVndWxhciBjb25lcy4gVGhlXG4gKiB0cnVuY2F0ZWQgY29uZSB3aWxsIGJlIGNyZWF0ZWQgY2VudGVyZWQgYWJvdXQgdGhlIG9yaWdpbiwgd2l0aCB0aGVcbiAqIHkgYXhpcyBhcyBpdHMgdmVydGljYWwgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b21SYWRpdXMgQm90dG9tIHJhZGl1cyBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3BSYWRpdXMgVG9wIHJhZGl1cyBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlXG4gKiAgICAgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgZG93biB0aGVcbiAqICAgICB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdF90b3BDYXBdIENyZWF0ZSB0b3AgY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdF9ib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIGNvbmUgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlVHJ1bmNhdGVkQ29uZUJ1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYnVmZmVycyBmb3IgYSB0cnVuY2F0ZWQgY29uZSwgd2hpY2ggaXMgbGlrZSBhIGN5bGluZGVyXG4gKiBleGNlcHQgdGhhdCBpdCBoYXMgZGlmZmVyZW50IHRvcCBhbmQgYm90dG9tIHJhZGlpLiBBIHRydW5jYXRlZCBjb25lXG4gKiBjYW4gYWxzbyBiZSB1c2VkIHRvIGNyZWF0ZSBjeWxpbmRlcnMgYW5kIHJlZ3VsYXIgY29uZXMuIFRoZVxuICogdHJ1bmNhdGVkIGNvbmUgd2lsbCBiZSBjcmVhdGVkIGNlbnRlcmVkIGFib3V0IHRoZSBvcmlnaW4sIHdpdGggdGhlXG4gKiB5IGF4aXMgYXMgaXRzIHZlcnRpY2FsIGF4aXMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tUmFkaXVzIEJvdHRvbSByYWRpdXMgb2YgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wUmFkaXVzIFRvcCByYWRpdXMgb2YgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZVxuICogICAgIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGRvd24gdGhlXG4gKiAgICAgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRfdG9wQ2FwXSBDcmVhdGUgdG9wIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRfYm90dG9tQ2FwXSBDcmVhdGUgYm90dG9tIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBjb25lIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHZlcnRpY2VzIGZvciBhIHRydW5jYXRlZCBjb25lLCB3aGljaCBpcyBsaWtlIGEgY3lsaW5kZXJcbiAqIGV4Y2VwdCB0aGF0IGl0IGhhcyBkaWZmZXJlbnQgdG9wIGFuZCBib3R0b20gcmFkaWkuIEEgdHJ1bmNhdGVkIGNvbmVcbiAqIGNhbiBhbHNvIGJlIHVzZWQgdG8gY3JlYXRlIGN5bGluZGVycyBhbmQgcmVndWxhciBjb25lcy4gVGhlXG4gKiB0cnVuY2F0ZWQgY29uZSB3aWxsIGJlIGNyZWF0ZWQgY2VudGVyZWQgYWJvdXQgdGhlIG9yaWdpbiwgd2l0aCB0aGVcbiAqIHkgYXhpcyBhcyBpdHMgdmVydGljYWwgYXhpcy4gLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b21SYWRpdXMgQm90dG9tIHJhZGl1cyBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3BSYWRpdXMgVG9wIHJhZGl1cyBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlXG4gKiAgICAgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgZG93biB0aGVcbiAqICAgICB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdF90b3BDYXBdIENyZWF0ZSB0b3AgY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdF9ib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgY29uZSB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVUcnVuY2F0ZWRDb25lVmVydGljZXMoYm90dG9tUmFkaXVzLCB0b3BSYWRpdXMsIGhlaWdodCwgcmFkaWFsU3ViZGl2aXNpb25zLCB2ZXJ0aWNhbFN1YmRpdmlzaW9ucywgb3B0X3RvcENhcCwgb3B0X2JvdHRvbUNhcCkge1xuICBpZiAocmFkaWFsU3ViZGl2aXNpb25zIDwgMykge1xuICAgIHRocm93IEVycm9yKCdyYWRpYWxTdWJkaXZpc2lvbnMgbXVzdCBiZSAzIG9yIGdyZWF0ZXInKTtcbiAgfVxuXG4gIGlmICh2ZXJ0aWNhbFN1YmRpdmlzaW9ucyA8IDEpIHtcbiAgICB0aHJvdyBFcnJvcigndmVydGljYWxTdWJkaXZpc2lvbnMgbXVzdCBiZSAxIG9yIGdyZWF0ZXInKTtcbiAgfVxuXG4gIHZhciB0b3BDYXAgPSBvcHRfdG9wQ2FwID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0X3RvcENhcDtcbiAgdmFyIGJvdHRvbUNhcCA9IG9wdF9ib3R0b21DYXAgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRfYm90dG9tQ2FwO1xuICB2YXIgZXh0cmEgPSAodG9wQ2FwID8gMiA6IDApICsgKGJvdHRvbUNhcCA/IDIgOiAwKTtcbiAgdmFyIG51bVZlcnRpY2VzID0gKHJhZGlhbFN1YmRpdmlzaW9ucyArIDEpICogKHZlcnRpY2FsU3ViZGl2aXNpb25zICsgMSArIGV4dHJhKTtcbiAgdmFyIHBvc2l0aW9ucyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICB2YXIgbm9ybWFscyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICB2YXIgdGV4Y29vcmRzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCBudW1WZXJ0aWNlcyk7XG4gIHZhciBpbmRpY2VzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCByYWRpYWxTdWJkaXZpc2lvbnMgKiAodmVydGljYWxTdWJkaXZpc2lvbnMgKyBleHRyYSkgKiAyLCBVaW50MTZBcnJheSk7XG4gIHZhciB2ZXJ0c0Fyb3VuZEVkZ2UgPSByYWRpYWxTdWJkaXZpc2lvbnMgKyAxOyAvLyBUaGUgc2xhbnQgb2YgdGhlIGNvbmUgaXMgY29uc3RhbnQgYWNyb3NzIGl0cyBzdXJmYWNlXG5cbiAgdmFyIHNsYW50ID0gTWF0aC5hdGFuMihib3R0b21SYWRpdXMgLSB0b3BSYWRpdXMsIGhlaWdodCk7XG4gIHZhciBjb3NTbGFudCA9IE1hdGguY29zKHNsYW50KTtcbiAgdmFyIHNpblNsYW50ID0gTWF0aC5zaW4oc2xhbnQpO1xuICB2YXIgc3RhcnQgPSB0b3BDYXAgPyAtMiA6IDA7XG4gIHZhciBlbmQgPSB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyArIChib3R0b21DYXAgPyAyIDogMCk7XG5cbiAgZm9yICh2YXIgeXkgPSBzdGFydDsgeXkgPD0gZW5kOyArK3l5KSB7XG4gICAgdmFyIHYgPSB5eSAvIHZlcnRpY2FsU3ViZGl2aXNpb25zO1xuICAgIHZhciB5ID0gaGVpZ2h0ICogdjtcbiAgICB2YXIgcmluZ1JhZGl1cyA9IHZvaWQgMDtcblxuICAgIGlmICh5eSA8IDApIHtcbiAgICAgIHkgPSAwO1xuICAgICAgdiA9IDE7XG4gICAgICByaW5nUmFkaXVzID0gYm90dG9tUmFkaXVzO1xuICAgIH0gZWxzZSBpZiAoeXkgPiB2ZXJ0aWNhbFN1YmRpdmlzaW9ucykge1xuICAgICAgeSA9IGhlaWdodDtcbiAgICAgIHYgPSAxO1xuICAgICAgcmluZ1JhZGl1cyA9IHRvcFJhZGl1cztcbiAgICB9IGVsc2Uge1xuICAgICAgcmluZ1JhZGl1cyA9IGJvdHRvbVJhZGl1cyArICh0b3BSYWRpdXMgLSBib3R0b21SYWRpdXMpICogKHl5IC8gdmVydGljYWxTdWJkaXZpc2lvbnMpO1xuICAgIH1cblxuICAgIGlmICh5eSA9PT0gLTIgfHwgeXkgPT09IHZlcnRpY2FsU3ViZGl2aXNpb25zICsgMikge1xuICAgICAgcmluZ1JhZGl1cyA9IDA7XG4gICAgICB2ID0gMDtcbiAgICB9XG5cbiAgICB5IC09IGhlaWdodCAvIDI7XG5cbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmVydHNBcm91bmRFZGdlOyArK2lpKSB7XG4gICAgICB2YXIgc2luID0gTWF0aC5zaW4oaWkgKiBNYXRoLlBJICogMiAvIHJhZGlhbFN1YmRpdmlzaW9ucyk7XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3MoaWkgKiBNYXRoLlBJICogMiAvIHJhZGlhbFN1YmRpdmlzaW9ucyk7XG4gICAgICBwb3NpdGlvbnMucHVzaChzaW4gKiByaW5nUmFkaXVzLCB5LCBjb3MgKiByaW5nUmFkaXVzKTtcbiAgICAgIG5vcm1hbHMucHVzaCh5eSA8IDAgfHwgeXkgPiB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyA/IDAgOiBzaW4gKiBjb3NTbGFudCwgeXkgPCAwID8gLTEgOiB5eSA+IHZlcnRpY2FsU3ViZGl2aXNpb25zID8gMSA6IHNpblNsYW50LCB5eSA8IDAgfHwgeXkgPiB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyA/IDAgOiBjb3MgKiBjb3NTbGFudCk7XG4gICAgICB0ZXhjb29yZHMucHVzaChpaSAvIHJhZGlhbFN1YmRpdmlzaW9ucywgMSAtIHYpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF95eSA9IDA7IF95eSA8IHZlcnRpY2FsU3ViZGl2aXNpb25zICsgZXh0cmE7ICsrX3l5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZvciAodmFyIF9paSA9IDA7IF9paSA8IHJhZGlhbFN1YmRpdmlzaW9uczsgKytfaWkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGluZGljZXMucHVzaCh2ZXJ0c0Fyb3VuZEVkZ2UgKiAoX3l5ICsgMCkgKyAwICsgX2lpLCB2ZXJ0c0Fyb3VuZEVkZ2UgKiAoX3l5ICsgMCkgKyAxICsgX2lpLCB2ZXJ0c0Fyb3VuZEVkZ2UgKiAoX3l5ICsgMSkgKyAxICsgX2lpKTtcbiAgICAgIGluZGljZXMucHVzaCh2ZXJ0c0Fyb3VuZEVkZ2UgKiAoX3l5ICsgMCkgKyAwICsgX2lpLCB2ZXJ0c0Fyb3VuZEVkZ2UgKiAoX3l5ICsgMSkgKyAxICsgX2lpLCB2ZXJ0c0Fyb3VuZEVkZ2UgKiAoX3l5ICsgMSkgKyAwICsgX2lpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbnMsXG4gICAgbm9ybWFsOiBub3JtYWxzLFxuICAgIHRleGNvb3JkOiB0ZXhjb29yZHMsXG4gICAgaW5kaWNlczogaW5kaWNlc1xuICB9O1xufVxuLyoqXG4gKiBFeHBhbmRzIFJMRSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcltdfSBybGVEYXRhIGRhdGEgaW4gZm9ybWF0IG9mIHJ1bi1sZW5ndGgsIHgsIHksIHosIHJ1bi1sZW5ndGgsIHgsIHksIHpcbiAqIEBwYXJhbSB7bnVtYmVyW119IFtwYWRkaW5nXSB2YWx1ZSB0byBhZGQgZWFjaCBlbnRyeSB3aXRoLlxuICogQHJldHVybiB7bnVtYmVyW119IHRoZSBleHBhbmRlZCBybGVEYXRhXG4gKi9cblxuXG5mdW5jdGlvbiBleHBhbmRSTEVEYXRhKHJsZURhdGEsIHBhZGRpbmcpIHtcbiAgcGFkZGluZyA9IHBhZGRpbmcgfHwgW107XG4gIHZhciBkYXRhID0gW107XG5cbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHJsZURhdGEubGVuZ3RoOyBpaSArPSA0KSB7XG4gICAgdmFyIHJ1bkxlbmd0aCA9IHJsZURhdGFbaWldO1xuICAgIHZhciBlbGVtZW50ID0gcmxlRGF0YS5zbGljZShpaSArIDEsIGlpICsgNCk7XG4gICAgZWxlbWVudC5wdXNoLmFwcGx5KGVsZW1lbnQsIHBhZGRpbmcpO1xuXG4gICAgZm9yICh2YXIgamogPSAwOyBqaiA8IHJ1bkxlbmd0aDsgKytqaikge1xuICAgICAgZGF0YS5wdXNoLmFwcGx5KGRhdGEsIGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDcmVhdGVzIDNEICdGJyBCdWZmZXJJbmZvLlxuICogQW4gJ0YnIGlzIHVzZWZ1bCBiZWNhdXNlIHlvdSBjYW4gZWFzaWx5IHRlbGwgd2hpY2ggd2F5IGl0IGlzIG9yaWVudGVkLlxuICogVGhlIGNyZWF0ZWQgJ0YnIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCB0ZXhjb29yZCwgYW5kIGNvbG9yIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBUaGUgY3JlYXRlZCBCdWZmZXJJbmZvLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGUzREZCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIDNEICdGJyBidWZmZXJzLlxuICogQW4gJ0YnIGlzIHVzZWZ1bCBiZWNhdXNlIHlvdSBjYW4gZWFzaWx5IHRlbGwgd2hpY2ggd2F5IGl0IGlzIG9yaWVudGVkLlxuICogVGhlIGNyZWF0ZWQgJ0YnIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCB0ZXhjb29yZCwgYW5kIGNvbG9yIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGUzREZCdWZmZXJzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIDNEICdGJyB2ZXJ0aWNlcy5cbiAqIEFuICdGJyBpcyB1c2VmdWwgYmVjYXVzZSB5b3UgY2FuIGVhc2lseSB0ZWxsIHdoaWNoIHdheSBpdCBpcyBvcmllbnRlZC5cbiAqIFRoZSBjcmVhdGVkICdGJyBoYXMgcG9zaXRpb24sIG5vcm1hbCwgdGV4Y29vcmQsIGFuZCBjb2xvciBhcnJheXMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGUzREZWZXJ0aWNlcygpIHtcbiAgdmFyIHBvc2l0aW9ucyA9IFsvLyBsZWZ0IGNvbHVtbiBmcm9udFxuICAwLCAwLCAwLCAwLCAxNTAsIDAsIDMwLCAwLCAwLCAwLCAxNTAsIDAsIDMwLCAxNTAsIDAsIDMwLCAwLCAwLCAvLyB0b3AgcnVuZyBmcm9udFxuICAzMCwgMCwgMCwgMzAsIDMwLCAwLCAxMDAsIDAsIDAsIDMwLCAzMCwgMCwgMTAwLCAzMCwgMCwgMTAwLCAwLCAwLCAvLyBtaWRkbGUgcnVuZyBmcm9udFxuICAzMCwgNjAsIDAsIDMwLCA5MCwgMCwgNjcsIDYwLCAwLCAzMCwgOTAsIDAsIDY3LCA5MCwgMCwgNjcsIDYwLCAwLCAvLyBsZWZ0IGNvbHVtbiBiYWNrXG4gIDAsIDAsIDMwLCAzMCwgMCwgMzAsIDAsIDE1MCwgMzAsIDAsIDE1MCwgMzAsIDMwLCAwLCAzMCwgMzAsIDE1MCwgMzAsIC8vIHRvcCBydW5nIGJhY2tcbiAgMzAsIDAsIDMwLCAxMDAsIDAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAxMDAsIDAsIDMwLCAxMDAsIDMwLCAzMCwgLy8gbWlkZGxlIHJ1bmcgYmFja1xuICAzMCwgNjAsIDMwLCA2NywgNjAsIDMwLCAzMCwgOTAsIDMwLCAzMCwgOTAsIDMwLCA2NywgNjAsIDMwLCA2NywgOTAsIDMwLCAvLyB0b3BcbiAgMCwgMCwgMCwgMTAwLCAwLCAwLCAxMDAsIDAsIDMwLCAwLCAwLCAwLCAxMDAsIDAsIDMwLCAwLCAwLCAzMCwgLy8gdG9wIHJ1bmcgZnJvbnRcbiAgMTAwLCAwLCAwLCAxMDAsIDMwLCAwLCAxMDAsIDMwLCAzMCwgMTAwLCAwLCAwLCAxMDAsIDMwLCAzMCwgMTAwLCAwLCAzMCwgLy8gdW5kZXIgdG9wIHJ1bmdcbiAgMzAsIDMwLCAwLCAzMCwgMzAsIDMwLCAxMDAsIDMwLCAzMCwgMzAsIDMwLCAwLCAxMDAsIDMwLCAzMCwgMTAwLCAzMCwgMCwgLy8gYmV0d2VlbiB0b3AgcnVuZyBhbmQgbWlkZGxlXG4gIDMwLCAzMCwgMCwgMzAsIDYwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAwLCAzMCwgNjAsIDAsIDMwLCA2MCwgMzAsIC8vIHRvcCBvZiBtaWRkbGUgcnVuZ1xuICAzMCwgNjAsIDAsIDY3LCA2MCwgMzAsIDMwLCA2MCwgMzAsIDMwLCA2MCwgMCwgNjcsIDYwLCAwLCA2NywgNjAsIDMwLCAvLyBmcm9udCBvZiBtaWRkbGUgcnVuZ1xuICA2NywgNjAsIDAsIDY3LCA5MCwgMzAsIDY3LCA2MCwgMzAsIDY3LCA2MCwgMCwgNjcsIDkwLCAwLCA2NywgOTAsIDMwLCAvLyBib3R0b20gb2YgbWlkZGxlIHJ1bmcuXG4gIDMwLCA5MCwgMCwgMzAsIDkwLCAzMCwgNjcsIDkwLCAzMCwgMzAsIDkwLCAwLCA2NywgOTAsIDMwLCA2NywgOTAsIDAsIC8vIGZyb250IG9mIGJvdHRvbVxuICAzMCwgOTAsIDAsIDMwLCAxNTAsIDMwLCAzMCwgOTAsIDMwLCAzMCwgOTAsIDAsIDMwLCAxNTAsIDAsIDMwLCAxNTAsIDMwLCAvLyBib3R0b21cbiAgMCwgMTUwLCAwLCAwLCAxNTAsIDMwLCAzMCwgMTUwLCAzMCwgMCwgMTUwLCAwLCAzMCwgMTUwLCAzMCwgMzAsIDE1MCwgMCwgLy8gbGVmdCBzaWRlXG4gIDAsIDAsIDAsIDAsIDAsIDMwLCAwLCAxNTAsIDMwLCAwLCAwLCAwLCAwLCAxNTAsIDMwLCAwLCAxNTAsIDBdO1xuICB2YXIgdGV4Y29vcmRzID0gWy8vIGxlZnQgY29sdW1uIGZyb250XG4gIDAuMjIsIDAuMTksIDAuMjIsIDAuNzksIDAuMzQsIDAuMTksIDAuMjIsIDAuNzksIDAuMzQsIDAuNzksIDAuMzQsIDAuMTksIC8vIHRvcCBydW5nIGZyb250XG4gIDAuMzQsIDAuMTksIDAuMzQsIDAuMzEsIDAuNjIsIDAuMTksIDAuMzQsIDAuMzEsIDAuNjIsIDAuMzEsIDAuNjIsIDAuMTksIC8vIG1pZGRsZSBydW5nIGZyb250XG4gIDAuMzQsIDAuNDMsIDAuMzQsIDAuNTUsIDAuNDksIDAuNDMsIDAuMzQsIDAuNTUsIDAuNDksIDAuNTUsIDAuNDksIDAuNDMsIC8vIGxlZnQgY29sdW1uIGJhY2tcbiAgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMSwgMSwgMCwgMSwgMSwgLy8gdG9wIHJ1bmcgYmFja1xuICAwLCAwLCAxLCAwLCAwLCAxLCAwLCAxLCAxLCAwLCAxLCAxLCAvLyBtaWRkbGUgcnVuZyBiYWNrXG4gIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDEsIDEsIDAsIDEsIDEsIC8vIHRvcFxuICAwLCAwLCAxLCAwLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAvLyB0b3AgcnVuZyBmcm9udFxuICAwLCAwLCAxLCAwLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAvLyB1bmRlciB0b3AgcnVuZ1xuICAwLCAwLCAwLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAxLCAwLCAvLyBiZXR3ZWVuIHRvcCBydW5nIGFuZCBtaWRkbGVcbiAgMCwgMCwgMSwgMSwgMCwgMSwgMCwgMCwgMSwgMCwgMSwgMSwgLy8gdG9wIG9mIG1pZGRsZSBydW5nXG4gIDAsIDAsIDEsIDEsIDAsIDEsIDAsIDAsIDEsIDAsIDEsIDEsIC8vIGZyb250IG9mIG1pZGRsZSBydW5nXG4gIDAsIDAsIDEsIDEsIDAsIDEsIDAsIDAsIDEsIDAsIDEsIDEsIC8vIGJvdHRvbSBvZiBtaWRkbGUgcnVuZy5cbiAgMCwgMCwgMCwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMSwgMCwgLy8gZnJvbnQgb2YgYm90dG9tXG4gIDAsIDAsIDEsIDEsIDAsIDEsIDAsIDAsIDEsIDAsIDEsIDEsIC8vIGJvdHRvbVxuICAwLCAwLCAwLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAxLCAwLCAvLyBsZWZ0IHNpZGVcbiAgMCwgMCwgMCwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMSwgMF07XG4gIHZhciBub3JtYWxzID0gZXhwYW5kUkxFRGF0YShbLy8gbGVmdCBjb2x1bW4gZnJvbnRcbiAgLy8gdG9wIHJ1bmcgZnJvbnRcbiAgLy8gbWlkZGxlIHJ1bmcgZnJvbnRcbiAgMTgsIDAsIDAsIDEsIC8vIGxlZnQgY29sdW1uIGJhY2tcbiAgLy8gdG9wIHJ1bmcgYmFja1xuICAvLyBtaWRkbGUgcnVuZyBiYWNrXG4gIDE4LCAwLCAwLCAtMSwgLy8gdG9wXG4gIDYsIDAsIDEsIDAsIC8vIHRvcCBydW5nIGZyb250XG4gIDYsIDEsIDAsIDAsIC8vIHVuZGVyIHRvcCBydW5nXG4gIDYsIDAsIC0xLCAwLCAvLyBiZXR3ZWVuIHRvcCBydW5nIGFuZCBtaWRkbGVcbiAgNiwgMSwgMCwgMCwgLy8gdG9wIG9mIG1pZGRsZSBydW5nXG4gIDYsIDAsIDEsIDAsIC8vIGZyb250IG9mIG1pZGRsZSBydW5nXG4gIDYsIDEsIDAsIDAsIC8vIGJvdHRvbSBvZiBtaWRkbGUgcnVuZy5cbiAgNiwgMCwgLTEsIDAsIC8vIGZyb250IG9mIGJvdHRvbVxuICA2LCAxLCAwLCAwLCAvLyBib3R0b21cbiAgNiwgMCwgLTEsIDAsIC8vIGxlZnQgc2lkZVxuICA2LCAtMSwgMCwgMF0pO1xuICB2YXIgY29sb3JzID0gZXhwYW5kUkxFRGF0YShbLy8gbGVmdCBjb2x1bW4gZnJvbnRcbiAgLy8gdG9wIHJ1bmcgZnJvbnRcbiAgLy8gbWlkZGxlIHJ1bmcgZnJvbnRcbiAgMTgsIDIwMCwgNzAsIDEyMCwgLy8gbGVmdCBjb2x1bW4gYmFja1xuICAvLyB0b3AgcnVuZyBiYWNrXG4gIC8vIG1pZGRsZSBydW5nIGJhY2tcbiAgMTgsIDgwLCA3MCwgMjAwLCAvLyB0b3BcbiAgNiwgNzAsIDIwMCwgMjEwLCAvLyB0b3AgcnVuZyBmcm9udFxuICA2LCAyMDAsIDIwMCwgNzAsIC8vIHVuZGVyIHRvcCBydW5nXG4gIDYsIDIxMCwgMTAwLCA3MCwgLy8gYmV0d2VlbiB0b3AgcnVuZyBhbmQgbWlkZGxlXG4gIDYsIDIxMCwgMTYwLCA3MCwgLy8gdG9wIG9mIG1pZGRsZSBydW5nXG4gIDYsIDcwLCAxODAsIDIxMCwgLy8gZnJvbnQgb2YgbWlkZGxlIHJ1bmdcbiAgNiwgMTAwLCA3MCwgMjEwLCAvLyBib3R0b20gb2YgbWlkZGxlIHJ1bmcuXG4gIDYsIDc2LCAyMTAsIDEwMCwgLy8gZnJvbnQgb2YgYm90dG9tXG4gIDYsIDE0MCwgMjEwLCA4MCwgLy8gYm90dG9tXG4gIDYsIDkwLCAxMzAsIDExMCwgLy8gbGVmdCBzaWRlXG4gIDYsIDE2MCwgMTYwLCAyMjBdLCBbMjU1XSk7XG4gIHZhciBudW1WZXJ0cyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuICB2YXIgYXJyYXlzID0ge1xuICAgIHBvc2l0aW9uOiBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRzKSxcbiAgICB0ZXhjb29yZDogY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCBudW1WZXJ0cyksXG4gICAgbm9ybWFsOiBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRzKSxcbiAgICBjb2xvcjogY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSg0LCBudW1WZXJ0cywgVWludDhBcnJheSksXG4gICAgaW5kaWNlczogY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0cyAvIDMsIFVpbnQxNkFycmF5KVxuICB9O1xuICBhcnJheXMucG9zaXRpb24ucHVzaChwb3NpdGlvbnMpO1xuICBhcnJheXMudGV4Y29vcmQucHVzaCh0ZXhjb29yZHMpO1xuICBhcnJheXMubm9ybWFsLnB1c2gobm9ybWFscyk7XG4gIGFycmF5cy5jb2xvci5wdXNoKGNvbG9ycyk7XG5cbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG51bVZlcnRzOyArK2lpKSB7XG4gICAgYXJyYXlzLmluZGljZXMucHVzaChpaSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXlzO1xufVxuLyoqXG4gKiBDcmVhdGVzIGNyZXNlbnQgQnVmZmVySW5mby5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFJhZGl1cyBUaGUgdmVydGljYWwgcmFkaXVzIG9mIHRoZSBjcmVzZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG91dGVyUmFkaXVzIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNyZXNlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5uZXJSYWRpdXMgVGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgY3Jlc2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGlja25lc3MgVGhlIHRoaWNrbmVzcyBvZiB0aGUgY3Jlc2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNEb3duIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIGNyZXNlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zVGhpY2sgbnVtYmVyIG9mIHZlcnRpY2FsbHkgb24gdGhlIGNyZXNlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0T2Zmc2V0XSBXaGVyZSB0byBzdGFydCBhcmMuIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kT2Zmc2V0XSBXaGVyZSB0byBlbmQgYXJnLiBEZWZhdWx0IDEuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBUaGUgY3JlYXRlZCBCdWZmZXJJbmZvLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDcmVzZW50QnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBjcmVzZW50IGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxSYWRpdXMgVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgY3Jlc2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRlclJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjcmVzZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGlubmVyUmFkaXVzIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIGNyZXNlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNyZXNlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zRG93biBudW1iZXIgb2Ygc3RlcHMgYXJvdW5kIHRoZSBjcmVzZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc1RoaWNrIG51bWJlciBvZiB2ZXJ0aWNhbGx5IG9uIHRoZSBjcmVzZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydE9mZnNldF0gV2hlcmUgdG8gc3RhcnQgYXJjLiBEZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZE9mZnNldF0gV2hlcmUgdG8gZW5kIGFyZy4gRGVmYXVsdCAxLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFdlYkdMQnVmZmVyPn0gVGhlIGNyZWF0ZWQgYnVmZmVycy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlQ3Jlc2VudEJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgY3Jlc2VudCB2ZXJ0aWNlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxSYWRpdXMgVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgY3Jlc2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRlclJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjcmVzZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGlubmVyUmFkaXVzIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIGNyZXNlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNyZXNlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zRG93biBudW1iZXIgb2Ygc3RlcHMgYXJvdW5kIHRoZSBjcmVzZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc1RoaWNrIG51bWJlciBvZiB2ZXJ0aWNhbGx5IG9uIHRoZSBjcmVzZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydE9mZnNldF0gV2hlcmUgdG8gc3RhcnQgYXJjLiBEZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZE9mZnNldF0gV2hlcmUgdG8gZW5kIGFyZy4gRGVmYXVsdCAxLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVDcmVzZW50VmVydGljZXModmVydGljYWxSYWRpdXMsIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1cywgdGhpY2tuZXNzLCBzdWJkaXZpc2lvbnNEb3duLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gIGlmIChzdWJkaXZpc2lvbnNEb3duIDw9IDApIHtcbiAgICB0aHJvdyBFcnJvcignc3ViZGl2aXNpb25Eb3duIG11c3QgYmUgPiAwJyk7XG4gIH1cblxuICBzdGFydE9mZnNldCA9IHN0YXJ0T2Zmc2V0IHx8IDA7XG4gIGVuZE9mZnNldCA9IGVuZE9mZnNldCB8fCAxO1xuICB2YXIgc3ViZGl2aXNpb25zVGhpY2sgPSAyO1xuICB2YXIgb2Zmc2V0UmFuZ2UgPSBlbmRPZmZzZXQgLSBzdGFydE9mZnNldDtcbiAgdmFyIG51bVZlcnRpY2VzID0gKHN1YmRpdmlzaW9uc0Rvd24gKyAxKSAqIDIgKiAoMiArIHN1YmRpdmlzaW9uc1RoaWNrKTtcbiAgdmFyIHBvc2l0aW9ucyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICB2YXIgbm9ybWFscyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICB2YXIgdGV4Y29vcmRzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCBudW1WZXJ0aWNlcyk7XG5cbiAgZnVuY3Rpb24gbGVycChhLCBiLCBzKSB7XG4gICAgcmV0dXJuIGEgKyAoYiAtIGEpICogcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFyYyhhcmNSYWRpdXMsIHgsIG5vcm1hbE11bHQsIG5vcm1hbEFkZCwgdU11bHQsIHVBZGQpIHtcbiAgICBmb3IgKHZhciB6ID0gMDsgeiA8PSBzdWJkaXZpc2lvbnNEb3duOyB6KyspIHtcbiAgICAgIHZhciB1QmFjayA9IHggLyAoc3ViZGl2aXNpb25zVGhpY2sgLSAxKTtcbiAgICAgIHZhciB2ID0geiAvIHN1YmRpdmlzaW9uc0Rvd247XG4gICAgICB2YXIgeEJhY2sgPSAodUJhY2sgLSAwLjUpICogMjtcbiAgICAgIHZhciBhbmdsZSA9IChzdGFydE9mZnNldCArIHYgKiBvZmZzZXRSYW5nZSkgKiBNYXRoLlBJO1xuICAgICAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHZhciByYWRpdXMgPSBsZXJwKHZlcnRpY2FsUmFkaXVzLCBhcmNSYWRpdXMsIHMpO1xuICAgICAgdmFyIHB4ID0geEJhY2sgKiB0aGlja25lc3M7XG4gICAgICB2YXIgcHkgPSBjICogdmVydGljYWxSYWRpdXM7XG4gICAgICB2YXIgcHogPSBzICogcmFkaXVzO1xuICAgICAgcG9zaXRpb25zLnB1c2gocHgsIHB5LCBweik7XG4gICAgICB2YXIgbiA9IHYzLmFkZCh2My5tdWx0aXBseShbMCwgcywgY10sIG5vcm1hbE11bHQpLCBub3JtYWxBZGQpO1xuICAgICAgbm9ybWFscy5wdXNoKG4pO1xuICAgICAgdGV4Y29vcmRzLnB1c2godUJhY2sgKiB1TXVsdCArIHVBZGQsIHYpO1xuICAgIH1cbiAgfSAvLyBHZW5lcmF0ZSB0aGUgaW5kaXZpZHVhbCB2ZXJ0aWNlcyBpbiBvdXIgdmVydGV4IGJ1ZmZlci5cblxuXG4gIGZvciAodmFyIHggPSAwOyB4IDwgc3ViZGl2aXNpb25zVGhpY2s7IHgrKykge1xuICAgIHZhciB1QmFjayA9ICh4IC8gKHN1YmRpdmlzaW9uc1RoaWNrIC0gMSkgLSAwLjUpICogMjtcbiAgICBjcmVhdGVBcmMob3V0ZXJSYWRpdXMsIHgsIFsxLCAxLCAxXSwgWzAsIDAsIDBdLCAxLCAwKTtcbiAgICBjcmVhdGVBcmMob3V0ZXJSYWRpdXMsIHgsIFswLCAwLCAwXSwgW3VCYWNrLCAwLCAwXSwgMCwgMCk7XG4gICAgY3JlYXRlQXJjKGlubmVyUmFkaXVzLCB4LCBbMSwgMSwgMV0sIFswLCAwLCAwXSwgMSwgMCk7XG4gICAgY3JlYXRlQXJjKGlubmVyUmFkaXVzLCB4LCBbMCwgMCwgMF0sIFt1QmFjaywgMCwgMF0sIDAsIDEpO1xuICB9IC8vIERvIG91dGVyIHN1cmZhY2UuXG5cblxuICB2YXIgaW5kaWNlcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgc3ViZGl2aXNpb25zRG93biAqIDIgKiAoMiArIHN1YmRpdmlzaW9uc1RoaWNrKSwgVWludDE2QXJyYXkpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN1cmZhY2UobGVmdEFyY09mZnNldCwgcmlnaHRBcmNPZmZzZXQpIHtcbiAgICBmb3IgKHZhciB6ID0gMDsgeiA8IHN1YmRpdmlzaW9uc0Rvd247ICsreikge1xuICAgICAgLy8gTWFrZSB0cmlhbmdsZSAxIG9mIHF1YWQuXG4gICAgICBpbmRpY2VzLnB1c2gobGVmdEFyY09mZnNldCArIHogKyAwLCBsZWZ0QXJjT2Zmc2V0ICsgeiArIDEsIHJpZ2h0QXJjT2Zmc2V0ICsgeiArIDApOyAvLyBNYWtlIHRyaWFuZ2xlIDIgb2YgcXVhZC5cblxuICAgICAgaW5kaWNlcy5wdXNoKGxlZnRBcmNPZmZzZXQgKyB6ICsgMSwgcmlnaHRBcmNPZmZzZXQgKyB6ICsgMSwgcmlnaHRBcmNPZmZzZXQgKyB6ICsgMCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG51bVZlcnRpY2VzRG93biA9IHN1YmRpdmlzaW9uc0Rvd24gKyAxOyAvLyBmcm9udFxuXG4gIGNyZWF0ZVN1cmZhY2UobnVtVmVydGljZXNEb3duICogMCwgbnVtVmVydGljZXNEb3duICogNCk7IC8vIHJpZ2h0XG5cbiAgY3JlYXRlU3VyZmFjZShudW1WZXJ0aWNlc0Rvd24gKiA1LCBudW1WZXJ0aWNlc0Rvd24gKiA3KTsgLy8gYmFja1xuXG4gIGNyZWF0ZVN1cmZhY2UobnVtVmVydGljZXNEb3duICogNiwgbnVtVmVydGljZXNEb3duICogMik7IC8vIGxlZnRcblxuICBjcmVhdGVTdXJmYWNlKG51bVZlcnRpY2VzRG93biAqIDMsIG51bVZlcnRpY2VzRG93biAqIDEpO1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbnMsXG4gICAgbm9ybWFsOiBub3JtYWxzLFxuICAgIHRleGNvb3JkOiB0ZXhjb29yZHMsXG4gICAgaW5kaWNlczogaW5kaWNlc1xuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGN5bGluZGVyIEJ1ZmZlckluZm8uIFRoZSBjeWxpbmRlciB3aWxsIGJlIGNyZWF0ZWQgYXJvdW5kIHRoZSBvcmlnaW5cbiAqIGFsb25nIHRoZSB5LWF4aXMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjeWxpbmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGRvd24gdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdG9wQ2FwXSBDcmVhdGUgdG9wIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUN5bGluZGVyQnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBjeWxpbmRlciBidWZmZXJzLiBUaGUgY3lsaW5kZXIgd2lsbCBiZSBjcmVhdGVkIGFyb3VuZCB0aGUgb3JpZ2luXG4gKiBhbG9uZyB0aGUgeS1heGlzLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgY3lsaW5kZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBjeWxpbmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZSBjeWxpbmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBkb3duIHRoZSBjeWxpbmRlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RvcENhcF0gQ3JlYXRlIHRvcCBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHBhcmFtIHtib29sZWFufSBbYm90dG9tQ2FwXSBDcmVhdGUgYm90dG9tIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDeWxpbmRlckJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgY3lsaW5kZXIgdmVydGljZXMuIFRoZSBjeWxpbmRlciB3aWxsIGJlIGNyZWF0ZWQgYXJvdW5kIHRoZSBvcmlnaW5cbiAqIGFsb25nIHRoZSB5LWF4aXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgY3lsaW5kZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBjeWxpbmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZSBjeWxpbmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBkb3duIHRoZSBjeWxpbmRlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RvcENhcF0gQ3JlYXRlIHRvcCBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHBhcmFtIHtib29sZWFufSBbYm90dG9tQ2FwXSBDcmVhdGUgYm90dG9tIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUN5bGluZGVyVmVydGljZXMocmFkaXVzLCBoZWlnaHQsIHJhZGlhbFN1YmRpdmlzaW9ucywgdmVydGljYWxTdWJkaXZpc2lvbnMsIHRvcENhcCwgYm90dG9tQ2FwKSB7XG4gIHJldHVybiBjcmVhdGVUcnVuY2F0ZWRDb25lVmVydGljZXMocmFkaXVzLCByYWRpdXMsIGhlaWdodCwgcmFkaWFsU3ViZGl2aXNpb25zLCB2ZXJ0aWNhbFN1YmRpdmlzaW9ucywgdG9wQ2FwLCBib3R0b21DYXApO1xufVxuLyoqXG4gKiBDcmVhdGVzIEJ1ZmZlckluZm8gZm9yIGEgdG9ydXNcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgcmFkaXVzIG9mIGNlbnRlciBvZiB0b3J1cyBjaXJjbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIHJhZGl1cyBvZiB0b3J1cyByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIHRvcnVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvZHlTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZSBib2R5IHRvcnVzLlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhcnRBbmdsZV0gc3RhcnQgYW5nbGUgaW4gcmFkaWFucy4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRBbmdsZV0gZW5kIGFuZ2xlIGluIHJhZGlhbnMuIERlZmF1bHQgPSBNYXRoLlBJICogMi5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVRvcnVzQnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBidWZmZXJzIGZvciBhIHRvcnVzXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIHJhZGl1cyBvZiBjZW50ZXIgb2YgdG9ydXMgY2lyY2xlLlxuICogQHBhcmFtIHtudW1iZXJ9IHRoaWNrbmVzcyByYWRpdXMgb2YgdG9ydXMgcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZSB0b3J1cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib2R5U3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGUgYm9keSB0b3J1cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YXJ0QW5nbGVdIHN0YXJ0IGFuZ2xlIGluIHJhZGlhbnMuIERlZmF1bHQgPSAwLlxuICogQHBhcmFtIHtib29sZWFufSBbZW5kQW5nbGVdIGVuZCBhbmdsZSBpbiByYWRpYW5zLiBEZWZhdWx0ID0gTWF0aC5QSSAqIDIuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVUb3J1c0J1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgdmVydGljZXMgZm9yIGEgdG9ydXNcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIHJhZGl1cyBvZiBjZW50ZXIgb2YgdG9ydXMgY2lyY2xlLlxuICogQHBhcmFtIHtudW1iZXJ9IHRoaWNrbmVzcyByYWRpdXMgb2YgdG9ydXMgcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZSB0b3J1cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib2R5U3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGUgYm9keSB0b3J1cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YXJ0QW5nbGVdIHN0YXJ0IGFuZ2xlIGluIHJhZGlhbnMuIERlZmF1bHQgPSAwLlxuICogQHBhcmFtIHtib29sZWFufSBbZW5kQW5nbGVdIGVuZCBhbmdsZSBpbiByYWRpYW5zLiBEZWZhdWx0ID0gTWF0aC5QSSAqIDIuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVRvcnVzVmVydGljZXMocmFkaXVzLCB0aGlja25lc3MsIHJhZGlhbFN1YmRpdmlzaW9ucywgYm9keVN1YmRpdmlzaW9ucywgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgaWYgKHJhZGlhbFN1YmRpdmlzaW9ucyA8IDMpIHtcbiAgICB0aHJvdyBFcnJvcigncmFkaWFsU3ViZGl2aXNpb25zIG11c3QgYmUgMyBvciBncmVhdGVyJyk7XG4gIH1cblxuICBpZiAoYm9keVN1YmRpdmlzaW9ucyA8IDMpIHtcbiAgICB0aHJvdyBFcnJvcigndmVydGljYWxTdWJkaXZpc2lvbnMgbXVzdCBiZSAzIG9yIGdyZWF0ZXInKTtcbiAgfVxuXG4gIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlIHx8IDA7XG4gIGVuZEFuZ2xlID0gZW5kQW5nbGUgfHwgTWF0aC5QSSAqIDI7XG4gIHZhciByYW5nZSA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgdmFyIHJhZGlhbFBhcnRzID0gcmFkaWFsU3ViZGl2aXNpb25zICsgMTtcbiAgdmFyIGJvZHlQYXJ0cyA9IGJvZHlTdWJkaXZpc2lvbnMgKyAxO1xuICB2YXIgbnVtVmVydGljZXMgPSByYWRpYWxQYXJ0cyAqIGJvZHlQYXJ0cztcbiAgdmFyIHBvc2l0aW9ucyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICB2YXIgbm9ybWFscyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICB2YXIgdGV4Y29vcmRzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCBudW1WZXJ0aWNlcyk7XG4gIHZhciBpbmRpY2VzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCByYWRpYWxTdWJkaXZpc2lvbnMgKiBib2R5U3ViZGl2aXNpb25zICogMiwgVWludDE2QXJyYXkpO1xuXG4gIGZvciAodmFyIHNsaWNlID0gMDsgc2xpY2UgPCBib2R5UGFydHM7ICsrc2xpY2UpIHtcbiAgICB2YXIgdiA9IHNsaWNlIC8gYm9keVN1YmRpdmlzaW9ucztcbiAgICB2YXIgc2xpY2VBbmdsZSA9IHYgKiBNYXRoLlBJICogMjtcbiAgICB2YXIgc2xpY2VTaW4gPSBNYXRoLnNpbihzbGljZUFuZ2xlKTtcbiAgICB2YXIgcmluZ1JhZGl1cyA9IHJhZGl1cyArIHNsaWNlU2luICogdGhpY2tuZXNzO1xuICAgIHZhciBueSA9IE1hdGguY29zKHNsaWNlQW5nbGUpO1xuICAgIHZhciB5ID0gbnkgKiB0aGlja25lc3M7XG5cbiAgICBmb3IgKHZhciByaW5nID0gMDsgcmluZyA8IHJhZGlhbFBhcnRzOyArK3JpbmcpIHtcbiAgICAgIHZhciB1ID0gcmluZyAvIHJhZGlhbFN1YmRpdmlzaW9ucztcbiAgICAgIHZhciByaW5nQW5nbGUgPSBzdGFydEFuZ2xlICsgdSAqIHJhbmdlO1xuICAgICAgdmFyIHhTaW4gPSBNYXRoLnNpbihyaW5nQW5nbGUpO1xuICAgICAgdmFyIHpDb3MgPSBNYXRoLmNvcyhyaW5nQW5nbGUpO1xuICAgICAgdmFyIHggPSB4U2luICogcmluZ1JhZGl1cztcbiAgICAgIHZhciB6ID0gekNvcyAqIHJpbmdSYWRpdXM7XG4gICAgICB2YXIgbnggPSB4U2luICogc2xpY2VTaW47XG4gICAgICB2YXIgbnogPSB6Q29zICogc2xpY2VTaW47XG4gICAgICBwb3NpdGlvbnMucHVzaCh4LCB5LCB6KTtcbiAgICAgIG5vcm1hbHMucHVzaChueCwgbnksIG56KTtcbiAgICAgIHRleGNvb3Jkcy5wdXNoKHUsIDEgLSB2KTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfc2xpY2UgPSAwOyBfc2xpY2UgPCBib2R5U3ViZGl2aXNpb25zOyArK19zbGljZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmb3IgKHZhciBfcmluZyA9IDA7IF9yaW5nIDwgcmFkaWFsU3ViZGl2aXNpb25zOyArK19yaW5nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB2YXIgbmV4dFJpbmdJbmRleCA9IDEgKyBfcmluZztcbiAgICAgIHZhciBuZXh0U2xpY2VJbmRleCA9IDEgKyBfc2xpY2U7XG4gICAgICBpbmRpY2VzLnB1c2gocmFkaWFsUGFydHMgKiBfc2xpY2UgKyBfcmluZywgcmFkaWFsUGFydHMgKiBuZXh0U2xpY2VJbmRleCArIF9yaW5nLCByYWRpYWxQYXJ0cyAqIF9zbGljZSArIG5leHRSaW5nSW5kZXgpO1xuICAgICAgaW5kaWNlcy5wdXNoKHJhZGlhbFBhcnRzICogbmV4dFNsaWNlSW5kZXggKyBfcmluZywgcmFkaWFsUGFydHMgKiBuZXh0U2xpY2VJbmRleCArIG5leHRSaW5nSW5kZXgsIHJhZGlhbFBhcnRzICogX3NsaWNlICsgbmV4dFJpbmdJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXNcbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGRpc2MgQnVmZmVySW5mby4gVGhlIGRpc2Mgd2lsbCBiZSBpbiB0aGUgeHogcGxhbmUsIGNlbnRlcmVkIGF0XG4gKiB0aGUgb3JpZ2luLiBXaGVuIGNyZWF0aW5nLCBhdCBsZWFzdCAzIGRpdmlzaW9ucywgb3IgcGllXG4gKiBwaWVjZXMsIG5lZWQgdG8gYmUgc3BlY2lmaWVkLCBvdGhlcndpc2UgdGhlIHRyaWFuZ2xlcyBtYWtpbmdcbiAqIHVwIHRoZSBkaXNjIHdpbGwgYmUgZGVnZW5lcmF0ZS4gWW91IGNhbiBhbHNvIHNwZWNpZnkgdGhlXG4gKiBudW1iZXIgb2YgcmFkaWFsIHBpZWNlcyBgc3RhY2tzYC4gQSB2YWx1ZSBvZiAxIGZvclxuICogc3RhY2tzIHdpbGwgZ2l2ZSB5b3UgYSBzaW1wbGUgZGlzYyBvZiBwaWUgcGllY2VzLiAgSWYgeW91XG4gKiB3YW50IHRvIGNyZWF0ZSBhbiBhbm51bHVzIHlvdSBjYW4gc2V0IGBpbm5lclJhZGl1c2AgdG8gYVxuICogdmFsdWUgPiAwLiBGaW5hbGx5LCBgc3RhY2tQb3dlcmAgYWxsb3dzIHlvdSB0byBoYXZlIHRoZSB3aWR0aHNcbiAqIGluY3JlYXNlIG9yIGRlY3JlYXNlIGFzIHlvdSBtb3ZlIGF3YXkgZnJvbSB0aGUgY2VudGVyLiBUaGlzXG4gKiBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gdXNpbmcgdGhlIGRpc2MgYXMgYSBncm91bmQgcGxhbmVcbiAqIHdpdGggYSBmaXhlZCBjYW1lcmEgc3VjaCB0aGF0IHlvdSBkb24ndCBuZWVkIHRoZSByZXNvbHV0aW9uXG4gKiBvZiBzbWFsbCB0cmlhbmdsZXMgbmVhciB0aGUgcGVyaW1ldGVyLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZVxuICogb2YgMiB3aWxsIHByb2R1Y2Ugc3RhY2tzIHdob3NlIG91c2lkZSByYWRpdXMgaW5jcmVhc2VzIHdpdGhcbiAqIHRoZSBzcXVhcmUgb2YgdGhlIHN0YWNrIGluZGV4LiBBIHZhbHVlIG9mIDEgd2lsbCBnaXZlIHVuaWZvcm1cbiAqIHN0YWNrcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIHRoZSBncm91bmQgcGxhbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gZGl2aXNpb25zIE51bWJlciBvZiB0cmlhbmdsZXMgaW4gdGhlIGdyb3VuZCBwbGFuZSAoYXQgbGVhc3QgMykuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YWNrc10gTnVtYmVyIG9mIHJhZGlhbCBkaXZpc2lvbnMgKGRlZmF1bHQ9MSkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2lubmVyUmFkaXVzXSBEZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YWNrUG93ZXJdIFBvd2VyIHRvIHJhaXNlIHN0YWNrIHNpemUgdG8gZm9yIGRlY3JlYXNpbmcgd2lkdGguXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBUaGUgY3JlYXRlZCBCdWZmZXJJbmZvLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVEaXNjQnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBkaXNjIGJ1ZmZlcnMuIFRoZSBkaXNjIHdpbGwgYmUgaW4gdGhlIHh6IHBsYW5lLCBjZW50ZXJlZCBhdFxuICogdGhlIG9yaWdpbi4gV2hlbiBjcmVhdGluZywgYXQgbGVhc3QgMyBkaXZpc2lvbnMsIG9yIHBpZVxuICogcGllY2VzLCBuZWVkIHRvIGJlIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHRoZSB0cmlhbmdsZXMgbWFraW5nXG4gKiB1cCB0aGUgZGlzYyB3aWxsIGJlIGRlZ2VuZXJhdGUuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IHRoZVxuICogbnVtYmVyIG9mIHJhZGlhbCBwaWVjZXMgYHN0YWNrc2AuIEEgdmFsdWUgb2YgMSBmb3JcbiAqIHN0YWNrcyB3aWxsIGdpdmUgeW91IGEgc2ltcGxlIGRpc2Mgb2YgcGllIHBpZWNlcy4gIElmIHlvdVxuICogd2FudCB0byBjcmVhdGUgYW4gYW5udWx1cyB5b3UgY2FuIHNldCBgaW5uZXJSYWRpdXNgIHRvIGFcbiAqIHZhbHVlID4gMC4gRmluYWxseSwgYHN0YWNrUG93ZXJgIGFsbG93cyB5b3UgdG8gaGF2ZSB0aGUgd2lkdGhzXG4gKiBpbmNyZWFzZSBvciBkZWNyZWFzZSBhcyB5b3UgbW92ZSBhd2F5IGZyb20gdGhlIGNlbnRlci4gVGhpc1xuICogaXMgcGFydGljdWxhcmx5IHVzZWZ1bCB3aGVuIHVzaW5nIHRoZSBkaXNjIGFzIGEgZ3JvdW5kIHBsYW5lXG4gKiB3aXRoIGEgZml4ZWQgY2FtZXJhIHN1Y2ggdGhhdCB5b3UgZG9uJ3QgbmVlZCB0aGUgcmVzb2x1dGlvblxuICogb2Ygc21hbGwgdHJpYW5nbGVzIG5lYXIgdGhlIHBlcmltZXRlci4gRm9yIGV4YW1wbGUsIGEgdmFsdWVcbiAqIG9mIDIgd2lsbCBwcm9kdWNlIHN0YWNrcyB3aG9zZSBvdXNpZGUgcmFkaXVzIGluY3JlYXNlcyB3aXRoXG4gKiB0aGUgc3F1YXJlIG9mIHRoZSBzdGFjayBpbmRleC4gQSB2YWx1ZSBvZiAxIHdpbGwgZ2l2ZSB1bmlmb3JtXG4gKiBzdGFja3MuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgZ3JvdW5kIHBsYW5lLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzaW9ucyBOdW1iZXIgb2YgdHJpYW5nbGVzIGluIHRoZSBncm91bmQgcGxhbmUgKGF0IGxlYXN0IDMpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja3NdIE51bWJlciBvZiByYWRpYWwgZGl2aXNpb25zIChkZWZhdWx0PTEpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtpbm5lclJhZGl1c10gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja1Bvd2VyXSBQb3dlciB0byByYWlzZSBzdGFjayBzaXplIHRvIGZvciBkZWNyZWFzaW5nIHdpZHRoLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFdlYkdMQnVmZmVyPn0gVGhlIGNyZWF0ZWQgYnVmZmVycy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlRGlzY0J1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgZGlzYyB2ZXJ0aWNlcy4gVGhlIGRpc2Mgd2lsbCBiZSBpbiB0aGUgeHogcGxhbmUsIGNlbnRlcmVkIGF0XG4gKiB0aGUgb3JpZ2luLiBXaGVuIGNyZWF0aW5nLCBhdCBsZWFzdCAzIGRpdmlzaW9ucywgb3IgcGllXG4gKiBwaWVjZXMsIG5lZWQgdG8gYmUgc3BlY2lmaWVkLCBvdGhlcndpc2UgdGhlIHRyaWFuZ2xlcyBtYWtpbmdcbiAqIHVwIHRoZSBkaXNjIHdpbGwgYmUgZGVnZW5lcmF0ZS4gWW91IGNhbiBhbHNvIHNwZWNpZnkgdGhlXG4gKiBudW1iZXIgb2YgcmFkaWFsIHBpZWNlcyBgc3RhY2tzYC4gQSB2YWx1ZSBvZiAxIGZvclxuICogc3RhY2tzIHdpbGwgZ2l2ZSB5b3UgYSBzaW1wbGUgZGlzYyBvZiBwaWUgcGllY2VzLiAgSWYgeW91XG4gKiB3YW50IHRvIGNyZWF0ZSBhbiBhbm51bHVzIHlvdSBjYW4gc2V0IGBpbm5lclJhZGl1c2AgdG8gYVxuICogdmFsdWUgPiAwLiBGaW5hbGx5LCBgc3RhY2tQb3dlcmAgYWxsb3dzIHlvdSB0byBoYXZlIHRoZSB3aWR0aHNcbiAqIGluY3JlYXNlIG9yIGRlY3JlYXNlIGFzIHlvdSBtb3ZlIGF3YXkgZnJvbSB0aGUgY2VudGVyLiBUaGlzXG4gKiBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gdXNpbmcgdGhlIGRpc2MgYXMgYSBncm91bmQgcGxhbmVcbiAqIHdpdGggYSBmaXhlZCBjYW1lcmEgc3VjaCB0aGF0IHlvdSBkb24ndCBuZWVkIHRoZSByZXNvbHV0aW9uXG4gKiBvZiBzbWFsbCB0cmlhbmdsZXMgbmVhciB0aGUgcGVyaW1ldGVyLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZVxuICogb2YgMiB3aWxsIHByb2R1Y2Ugc3RhY2tzIHdob3NlIG91c2lkZSByYWRpdXMgaW5jcmVhc2VzIHdpdGhcbiAqIHRoZSBzcXVhcmUgb2YgdGhlIHN0YWNrIGluZGV4LiBBIHZhbHVlIG9mIDEgd2lsbCBnaXZlIHVuaWZvcm1cbiAqIHN0YWNrcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgZ3JvdW5kIHBsYW5lLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzaW9ucyBOdW1iZXIgb2YgdHJpYW5nbGVzIGluIHRoZSBncm91bmQgcGxhbmUgKGF0IGxlYXN0IDMpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja3NdIE51bWJlciBvZiByYWRpYWwgZGl2aXNpb25zIChkZWZhdWx0PTEpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtpbm5lclJhZGl1c10gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja1Bvd2VyXSBQb3dlciB0byByYWlzZSBzdGFjayBzaXplIHRvIGZvciBkZWNyZWFzaW5nIHdpZHRoLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVEaXNjVmVydGljZXMocmFkaXVzLCBkaXZpc2lvbnMsIHN0YWNrcywgaW5uZXJSYWRpdXMsIHN0YWNrUG93ZXIpIHtcbiAgaWYgKGRpdmlzaW9ucyA8IDMpIHtcbiAgICB0aHJvdyBFcnJvcignZGl2aXNpb25zIG11c3QgYmUgYXQgbGVhc3QgMycpO1xuICB9XG5cbiAgc3RhY2tzID0gc3RhY2tzID8gc3RhY2tzIDogMTtcbiAgc3RhY2tQb3dlciA9IHN0YWNrUG93ZXIgPyBzdGFja1Bvd2VyIDogMTtcbiAgaW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cyA/IGlubmVyUmFkaXVzIDogMDsgLy8gTm90ZTogV2UgZG9uJ3Qgc2hhcmUgdGhlIGNlbnRlciB2ZXJ0ZXggYmVjYXVzZSB0aGF0IHdvdWxkXG4gIC8vIG1lc3MgdXAgdGV4dHVyZSBjb29yZGluYXRlcy5cblxuICB2YXIgbnVtVmVydGljZXMgPSAoZGl2aXNpb25zICsgMSkgKiAoc3RhY2tzICsgMSk7XG4gIHZhciBwb3NpdGlvbnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIG5vcm1hbHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgdmFyIHRleGNvb3JkcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgbnVtVmVydGljZXMpO1xuICB2YXIgaW5kaWNlcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgc3RhY2tzICogZGl2aXNpb25zICogMiwgVWludDE2QXJyYXkpO1xuICB2YXIgZmlyc3RJbmRleCA9IDA7XG4gIHZhciByYWRpdXNTcGFuID0gcmFkaXVzIC0gaW5uZXJSYWRpdXM7XG4gIHZhciBwb2ludHNQZXJTdGFjayA9IGRpdmlzaW9ucyArIDE7IC8vIEJ1aWxkIHRoZSBkaXNrIG9uZSBzdGFjayBhdCBhIHRpbWUuXG5cbiAgZm9yICh2YXIgc3RhY2sgPSAwOyBzdGFjayA8PSBzdGFja3M7ICsrc3RhY2spIHtcbiAgICB2YXIgc3RhY2tSYWRpdXMgPSBpbm5lclJhZGl1cyArIHJhZGl1c1NwYW4gKiBNYXRoLnBvdyhzdGFjayAvIHN0YWNrcywgc3RhY2tQb3dlcik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBkaXZpc2lvbnM7ICsraSkge1xuICAgICAgdmFyIHRoZXRhID0gMi4wICogTWF0aC5QSSAqIGkgLyBkaXZpc2lvbnM7XG4gICAgICB2YXIgeCA9IHN0YWNrUmFkaXVzICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHogPSBzdGFja1JhZGl1cyAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgIHBvc2l0aW9ucy5wdXNoKHgsIDAsIHopO1xuICAgICAgbm9ybWFscy5wdXNoKDAsIDEsIDApO1xuICAgICAgdGV4Y29vcmRzLnB1c2goMSAtIGkgLyBkaXZpc2lvbnMsIHN0YWNrIC8gc3RhY2tzKTtcblxuICAgICAgaWYgKHN0YWNrID4gMCAmJiBpICE9PSBkaXZpc2lvbnMpIHtcbiAgICAgICAgLy8gYSwgYiwgYyBhbmQgZCBhcmUgdGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzIG9mIGEgcXVhZC4gIHVubGVzc1xuICAgICAgICAvLyB0aGUgY3VycmVudCBzdGFjayBpcyB0aGUgb25lIGNsb3Nlc3QgdG8gdGhlIGNlbnRlciwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAvLyB0aGUgdmVydGljZXMgYSBhbmQgYiBjb25uZWN0IHRvIHRoZSBjZW50ZXIgdmVydGV4LlxuICAgICAgICB2YXIgYSA9IGZpcnN0SW5kZXggKyAoaSArIDEpO1xuICAgICAgICB2YXIgYiA9IGZpcnN0SW5kZXggKyBpO1xuICAgICAgICB2YXIgYyA9IGZpcnN0SW5kZXggKyBpIC0gcG9pbnRzUGVyU3RhY2s7XG4gICAgICAgIHZhciBkID0gZmlyc3RJbmRleCArIChpICsgMSkgLSBwb2ludHNQZXJTdGFjazsgLy8gTWFrZSBhIHF1YWQgb2YgdGhlIHZlcnRpY2VzIGEsIGIsIGMsIGQuXG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKGEsIGIsIGMpO1xuICAgICAgICBpbmRpY2VzLnB1c2goYSwgYywgZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmlyc3RJbmRleCArPSBkaXZpc2lvbnMgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXNcbiAgfTtcbn1cbi8qKlxuICogY3JlYXRlcyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgcmFuZ2UgLSAxIGluY2x1c2l2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZVxuICogQHJldHVybiB7bnVtYmVyfSByYW5kb20gdmFsdWUgYmV0d2VlbiAwIGFuZCByYW5nZSAtIDEgaW5jbHVzaXZlLlxuICovXG5cblxuZnVuY3Rpb24gcmFuZEludChyYW5nZSkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIHJhbmdlIHwgMDtcbn1cbi8qKlxuICogVXNlZCB0byBzdXBwbHkgcmFuZG9tIGNvbG9yc1xuICogQGNhbGxiYWNrIFJhbmRvbUNvbG9yRnVuY1xuICogQHBhcmFtIHtudW1iZXJ9IG5keCBpbmRleCBvZiB0cmlhbmdsZS9xdWFkIGlmIHVuaW5kZXhlZCBvciBpbmRleCBvZiB2ZXJ0ZXggaWYgaW5kZXhlZFxuICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWwgMCA9IHJlZCwgMSA9IGdyZWVuLCAyID0gYmx1ZSwgMyA9IGFscGhhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEgbnVtYmVyIGZyb20gMCB0byAyNTVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSYW5kb21WZXJ0aWNlc09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmVydHNQZXJDb2xvcl0gRGVmYXVsdHMgdG8gMyBmb3Igbm9uLWluZGV4ZWQgdmVydGljZXNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnR3Z2wvcHJpbWl0aXZlcy5SYW5kb21Db2xvckZ1bmN9IFtyYW5kXSBBIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHJhbmRvbSBudW1iZXJzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhdWdtZW50ZWRUeXBlZEFycmF5IG9mIHJhbmRvbSB2ZXJ0ZXggY29sb3JzLlxuICogSWYgdGhlIHZlcnRpY2VzIGFyZSBpbmRleGVkIChoYXZlIGFuIGluZGljZXMgYXJyYXkpIHRoZW4gd2lsbFxuICoganVzdCBtYWtlIHJhbmRvbSBjb2xvcnMuIE90aGVyd2lzZSBhc3N1bWVzIHRoZXkgYXJlIHRyaWFuZ2xlc1xuICogYW5kIG1ha2VzIG9uZSByYW5kb20gY29sb3IgZm9yIGV2ZXJ5IDMgdmVydGljZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBhdWdtZW50ZWRUeXBlZEFycmF5Pn0gdmVydGljZXMgVmVydGljZXMgYXMgcmV0dXJuZWQgZnJvbSBvbmUgb2YgdGhlIGNyZWF0ZVhYWFZlcnRpY2VzIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvcHJpbWl0aXZlcy5SYW5kb21WZXJ0aWNlc09wdGlvbnN9IFtvcHRpb25zXSBvcHRpb25zLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIGF1Z21lbnRlZFR5cGVkQXJyYXk+fSBzYW1lIHZlcnRpY2VzIGFzIHBhc3NlZCBpbiB3aXRoIGBjb2xvcmAgYWRkZWQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gbWFrZVJhbmRvbVZlcnRleENvbG9ycyh2ZXJ0aWNlcywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG51bUVsZW1lbnRzID0gdmVydGljZXMucG9zaXRpb24ubnVtRWxlbWVudHM7XG4gIHZhciB2Y29sb3JzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSg0LCBudW1FbGVtZW50cywgVWludDhBcnJheSk7XG5cbiAgdmFyIHJhbmQgPSBvcHRpb25zLnJhbmQgfHwgZnVuY3Rpb24gKG5keCwgY2hhbm5lbCkge1xuICAgIHJldHVybiBjaGFubmVsIDwgMyA/IHJhbmRJbnQoMjU2KSA6IDI1NTtcbiAgfTtcblxuICB2ZXJ0aWNlcy5jb2xvciA9IHZjb2xvcnM7XG5cbiAgaWYgKHZlcnRpY2VzLmluZGljZXMpIHtcbiAgICAvLyBqdXN0IG1ha2UgcmFuZG9tIGNvbG9ycyBpZiBpbmRleFxuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1FbGVtZW50czsgKytpaSkge1xuICAgICAgdmNvbG9ycy5wdXNoKHJhbmQoaWksIDApLCByYW5kKGlpLCAxKSwgcmFuZChpaSwgMiksIHJhbmQoaWksIDMpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFrZSByYW5kb20gY29sb3JzIHBlciB0cmlhbmdsZVxuICAgIHZhciBudW1WZXJ0c1BlckNvbG9yID0gb3B0aW9ucy52ZXJ0c1BlckNvbG9yIHx8IDM7XG4gICAgdmFyIG51bVNldHMgPSBudW1FbGVtZW50cyAvIG51bVZlcnRzUGVyQ29sb3I7XG5cbiAgICBmb3IgKHZhciBfaWkyID0gMDsgX2lpMiA8IG51bVNldHM7ICsrX2lpMikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgdmFyIGNvbG9yID0gW3JhbmQoX2lpMiwgMCksIHJhbmQoX2lpMiwgMSksIHJhbmQoX2lpMiwgMiksIHJhbmQoX2lpMiwgMyldO1xuXG4gICAgICBmb3IgKHZhciBqaiA9IDA7IGpqIDwgbnVtVmVydHNQZXJDb2xvcjsgKytqaikge1xuICAgICAgICB2Y29sb3JzLnB1c2goY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2ZXJ0aWNlcztcbn1cbi8qKlxuICogY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgZm4gdG8gY3JlYXRlIHZlcnRpY2VzIGFuZCB0aGVuXG4gKiBjcmVhdGVzIGEgYnVmZmVycyBmb3IgdGhlbVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyRnVuYyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGdsKSB7XG4gICAgdmFyIGFycmF5cyA9IGZuLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHJldHVybiBhdHRyaWJ1dGVzLmNyZWF0ZUJ1ZmZlcnNGcm9tQXJyYXlzKGdsLCBhcnJheXMpO1xuICB9O1xufVxuLyoqXG4gKiBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjYWxscyBmbiB0byBjcmVhdGUgdmVydGljZXMgYW5kIHRoZW5cbiAqIGNyZWF0ZXMgYSBidWZmZXJJbmZvIG9iamVjdCBmb3IgdGhlbVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVySW5mb0Z1bmMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChnbCkge1xuICAgIHZhciBhcnJheXMgPSBmbi5hcHBseShudWxsLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICByZXR1cm4gYXR0cmlidXRlcy5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwgYXJyYXlzKTtcbiAgfTtcbn1cblxudmFyIGFycmF5U3BlY1Byb3BlcnR5TmFtZXMgPSBbXCJudW1Db21wb25lbnRzXCIsIFwic2l6ZVwiLCBcInR5cGVcIiwgXCJub3JtYWxpemVcIiwgXCJzdHJpZGVcIiwgXCJvZmZzZXRcIiwgXCJhdHRyaWJcIiwgXCJuYW1lXCIsIFwiYXR0cmliTmFtZVwiXTtcbi8qKlxuICogQ29weSBlbGVtZW50cyBmcm9tIG9uZSBhcnJheSB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBzcmMgc291cmNlIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGRzdCBkZXN0IGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gZHN0TmR4IGluZGV4IGluIGRlc3QgdG8gY29weSBzcmNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0XSBvZmZzZXQgdG8gYWRkIHRvIGNvcGllZCB2YWx1ZXNcbiAqL1xuXG5mdW5jdGlvbiBjb3B5RWxlbWVudHMoc3JjLCBkc3QsIGRzdE5keCwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgbGVuZ3RoID0gc3JjLmxlbmd0aDtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuZ3RoOyArK2lpKSB7XG4gICAgZHN0W2RzdE5keCArIGlpXSA9IHNyY1tpaV0gKyBvZmZzZXQ7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgc2FtZSB0aW1lXG4gKlxuICogQHBhcmFtIHsobnVtYmVyW118QXJyYXlCdWZmZXJWaWV3fG1vZHVsZTp0d2dsLkZ1bGxBcnJheVNwZWMpfSBzcmNBcnJheSBhcnJheSB3aG8ncyB0eXBlIHRvIGNvcHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggc2l6ZSBvZiBuZXcgYXJyYXlcbiAqIEByZXR1cm4geyhudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd8bW9kdWxlOnR3Z2wuRnVsbEFycmF5U3BlYyl9IGFycmF5IHdpdGggc2FtZSB0eXBlIGFzIHNyY0FycmF5XG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVBcnJheU9mU2FtZVR5cGUoc3JjQXJyYXksIGxlbmd0aCkge1xuICB2YXIgYXJyYXlTcmMgPSBnZXRBcnJheShzcmNBcnJheSk7XG4gIHZhciBuZXdBcnJheSA9IG5ldyBhcnJheVNyYy5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuICB2YXIgbmV3QXJyYXlTcGVjID0gbmV3QXJyYXk7IC8vIElmIGl0IGFwcGVhcnMgdG8gaGF2ZSBiZWVuIGF1Z21lbnRlZCBtYWtlIG5ldyBvbmUgYXVnZW1lbnRlZFxuXG4gIGlmIChhcnJheVNyYy5udW1Db21wb25lbnRzICYmIGFycmF5U3JjLm51bUVsZW1lbnRzKSB7XG4gICAgYXVnbWVudFR5cGVkQXJyYXkobmV3QXJyYXksIGFycmF5U3JjLm51bUNvbXBvbmVudHMpO1xuICB9IC8vIElmIGl0IHdhcyBhIGZ1bGxzcGVjIG1ha2UgbmV3IG9uZSBhIGZ1bGxzcGVjXG5cblxuICBpZiAoc3JjQXJyYXkuZGF0YSkge1xuICAgIG5ld0FycmF5U3BlYyA9IHtcbiAgICAgIGRhdGE6IG5ld0FycmF5XG4gICAgfTtcbiAgICBoZWxwZXIuY29weU5hbWVkUHJvcGVydGllcyhhcnJheVNwZWNQcm9wZXJ0eU5hbWVzLCBzcmNBcnJheSwgbmV3QXJyYXlTcGVjKTtcbiAgfVxuXG4gIHJldHVybiBuZXdBcnJheVNwZWM7XG59XG4vKipcbiAqIENvbmNhdGluYXRlcyBzZXRzIG9mIHZlcnRpY2VzXG4gKlxuICogQXNzdW1lcyB0aGUgdmVydGljZXMgbWF0Y2ggaW4gY29tcG9zaXRpb24uIEZvciBleGFtcGxlXG4gKiBpZiBvbmUgc2V0IG9mIHZlcnRpY2VzIGhhcyBwb3NpdGlvbnMsIG5vcm1hbHMsIGFuZCBpbmRpY2VzXG4gKiBhbGwgc2V0cyBvZiB2ZXJ0aWNlcyBtdXN0IGhhdmUgcG9zaXRpb25zLCBub3JtYWxzLCBhbmQgaW5kaWNlc1xuICogYW5kIG9mIHRoZSBzYW1lIHR5cGUuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgIGNvbnN0IGN1YmVWZXJ0aWNlcyA9IHR3Z2wucHJpbXRpaXZlcy5jcmVhdGVDdWJlVmVydGljZXMoMik7XG4gKiAgICAgIGNvbnN0IHNwaGVyZVZlcnRpY2VzID0gdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVNwaGVyZVZlcnRpY2VzKDEsIDEwLCAxMCk7XG4gKiAgICAgIC8vIG1vdmUgdGhlIHNwaGVyZSAyIHVuaXRzIHVwXG4gKiAgICAgIHR3Z2wucHJpbWl0aXZlcy5yZW9yaWVudFZlcnRpY2VzKFxuICogICAgICAgICAgc3BoZXJlVmVydGljZXMsIHR3Z2wubTQudHJhbnNsYXRpb24oWzAsIDIsIDBdKSk7XG4gKiAgICAgIC8vIG1lcmdlIHRoZSBzcGhlcmUgd2l0aCB0aGUgY3ViZVxuICogICAgICBjb25zdCBjdWJlU3BoZXJlVmVydGljZXMgPSB0d2dsLnByaW1pdGl2ZXMuY29uY2F0VmVydGljZXMoXG4gKiAgICAgICAgICBbY3ViZVZlcnRpY2VzLCBzcGhlcmVWZXJ0aWNlc10pO1xuICogICAgICAvLyB0dXJuIHRoZW0gaW50byBXZWJHTCBidWZmZXJzIGFuZCBhdHRyaWIgZGF0YVxuICogICAgICBjb25zdCBidWZmZXJJbmZvID0gdHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwgY3ViZVNwaGVyZVZlcnRpY2VzKTtcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkFycmF5c1tdfSBhcnJheXMgQXJyYXkgb2YgYXJyYXlzIG9mIHZlcnRpY2VzXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5BcnJheXN9IFRoZSBjb25jYXRpbmF0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5cblxuZnVuY3Rpb24gY29uY2F0VmVydGljZXMoYXJyYXlPZkFycmF5cykge1xuICB2YXIgbmFtZXMgPSB7fTtcbiAgdmFyIGJhc2VOYW1lOyAvLyBnZXQgbmFtZXMgb2YgYWxsIGFycmF5cy5cbiAgLy8gYW5kIG51bUVsZW1lbnRzIGZvciBlYWNoIHNldCBvZiB2ZXJ0aWNlc1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGlpKSB7XG4gICAgdmFyIGFycmF5cyA9IGFycmF5T2ZBcnJheXNbaWldO1xuICAgIE9iamVjdC5rZXlzKGFycmF5cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKCFuYW1lc1tuYW1lXSkge1xuICAgICAgICBuYW1lc1tuYW1lXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWJhc2VOYW1lICYmIG5hbWUgIT09ICdpbmRpY2VzJykge1xuICAgICAgICBiYXNlTmFtZSA9IG5hbWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBhcnJheUluZm8gPSBhcnJheXNbbmFtZV07XG4gICAgICB2YXIgbnVtQ29tcG9uZW50cyA9IGdldE51bUNvbXBvbmVudHMoYXJyYXlJbmZvLCBuYW1lKTtcbiAgICAgIHZhciBhcnJheSA9IGdldEFycmF5KGFycmF5SW5mbyk7XG4gICAgICB2YXIgbnVtRWxlbWVudHMgPSBhcnJheS5sZW5ndGggLyBudW1Db21wb25lbnRzO1xuICAgICAgbmFtZXNbbmFtZV0ucHVzaChudW1FbGVtZW50cyk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGFycmF5T2ZBcnJheXMubGVuZ3RoOyArK2lpKSB7XG4gICAgX2xvb3AoaWkpO1xuICB9IC8vIGNvbXB1dGUgbGVuZ3RoIG9mIGNvbWJpbmVkIGFycmF5XG4gIC8vIGFuZCByZXR1cm4gb25lIGZvciByZWZlcmVuY2VcblxuXG4gIGZ1bmN0aW9uIGdldExlbmd0aE9mQ29tYmluZWRBcnJheXMobmFtZSkge1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHZhciBhcnJheVNwZWM7XG5cbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgYXJyYXlPZkFycmF5cy5sZW5ndGg7ICsraWkpIHtcbiAgICAgIHZhciBhcnJheXMgPSBhcnJheU9mQXJyYXlzW2lpXTtcbiAgICAgIHZhciBhcnJheUluZm8gPSBhcnJheXNbbmFtZV07XG4gICAgICB2YXIgYXJyYXkgPSBnZXRBcnJheShhcnJheUluZm8pO1xuICAgICAgbGVuZ3RoICs9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKCFhcnJheVNwZWMgfHwgYXJyYXlJbmZvLmRhdGEpIHtcbiAgICAgICAgYXJyYXlTcGVjID0gYXJyYXlJbmZvO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgIHNwZWM6IGFycmF5U3BlY1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5QXJyYXlzVG9OZXdBcnJheShuYW1lLCBiYXNlLCBuZXdBcnJheSkge1xuICAgIHZhciBiYXNlSW5kZXggPSAwO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGFycmF5T2ZBcnJheXMubGVuZ3RoOyArK2lpKSB7XG4gICAgICB2YXIgYXJyYXlzID0gYXJyYXlPZkFycmF5c1tpaV07XG4gICAgICB2YXIgYXJyYXlJbmZvID0gYXJyYXlzW25hbWVdO1xuICAgICAgdmFyIGFycmF5ID0gZ2V0QXJyYXkoYXJyYXlJbmZvKTtcblxuICAgICAgaWYgKG5hbWUgPT09ICdpbmRpY2VzJykge1xuICAgICAgICBjb3B5RWxlbWVudHMoYXJyYXksIG5ld0FycmF5LCBvZmZzZXQsIGJhc2VJbmRleCk7XG4gICAgICAgIGJhc2VJbmRleCArPSBiYXNlW2lpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlFbGVtZW50cyhhcnJheSwgbmV3QXJyYXksIG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCArPSBhcnJheS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSBuYW1lc1tiYXNlTmFtZV07XG4gIHZhciBuZXdBcnJheXMgPSB7fTtcbiAgT2JqZWN0LmtleXMobmFtZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgaW5mbyA9IGdldExlbmd0aE9mQ29tYmluZWRBcnJheXMobmFtZSk7XG4gICAgdmFyIG5ld0FycmF5U3BlYyA9IGNyZWF0ZUFycmF5T2ZTYW1lVHlwZShpbmZvLnNwZWMsIGluZm8ubGVuZ3RoKTtcbiAgICBjb3B5QXJyYXlzVG9OZXdBcnJheShuYW1lLCBiYXNlLCBnZXRBcnJheShuZXdBcnJheVNwZWMpKTtcbiAgICBuZXdBcnJheXNbbmFtZV0gPSBuZXdBcnJheVNwZWM7XG4gIH0pO1xuICByZXR1cm4gbmV3QXJyYXlzO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgZHVwbGljYXRlIHNldCBvZiB2ZXJ0aWNlc1xuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjYWxsaW5nIHJlb3JpZW50VmVydGljZXMgd2hlbiB5b3VcbiAqIGFsc28gd2FudCB0byBrZWVwIHRoZSBvcmlnaW5hbCBhdmFpbGFibGVcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkFycmF5c30gYXJyYXlzIG9mIHZlcnRpY2VzXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5BcnJheXN9IFRoZSBkdXBpbGljYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuXG5mdW5jdGlvbiBkdXBsaWNhdGVWZXJ0aWNlcyhhcnJheXMpIHtcbiAgdmFyIG5ld0FycmF5cyA9IHt9O1xuICBPYmplY3Qua2V5cyhhcnJheXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgYXJyYXlTcGVjID0gYXJyYXlzW25hbWVdO1xuICAgIHZhciBzcmNBcnJheSA9IGdldEFycmF5KGFycmF5U3BlYyk7XG4gICAgdmFyIG5ld0FycmF5U3BlYyA9IGNyZWF0ZUFycmF5T2ZTYW1lVHlwZShhcnJheVNwZWMsIHNyY0FycmF5Lmxlbmd0aCk7XG4gICAgY29weUVsZW1lbnRzKHNyY0FycmF5LCBnZXRBcnJheShuZXdBcnJheVNwZWMpLCAwKTtcbiAgICBuZXdBcnJheXNbbmFtZV0gPSBuZXdBcnJheVNwZWM7XG4gIH0pO1xuICByZXR1cm4gbmV3QXJyYXlzO1xufVxuXG52YXIgY3JlYXRlM0RGQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZTNERlZlcnRpY2VzKTtcbmV4cG9ydHMuY3JlYXRlM0RGQnVmZmVySW5mbyA9IGNyZWF0ZTNERkJ1ZmZlckluZm87XG52YXIgY3JlYXRlM0RGQnVmZmVycyA9IGNyZWF0ZUJ1ZmZlckZ1bmMoY3JlYXRlM0RGVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGUzREZCdWZmZXJzID0gY3JlYXRlM0RGQnVmZmVycztcbnZhciBjcmVhdGVDdWJlQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZUN1YmVWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZUN1YmVCdWZmZXJJbmZvID0gY3JlYXRlQ3ViZUJ1ZmZlckluZm87XG52YXIgY3JlYXRlQ3ViZUJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZUN1YmVWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZUN1YmVCdWZmZXJzID0gY3JlYXRlQ3ViZUJ1ZmZlcnM7XG52YXIgY3JlYXRlUGxhbmVCdWZmZXJJbmZvID0gY3JlYXRlQnVmZmVySW5mb0Z1bmMoY3JlYXRlUGxhbmVWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZVBsYW5lQnVmZmVySW5mbyA9IGNyZWF0ZVBsYW5lQnVmZmVySW5mbztcbnZhciBjcmVhdGVQbGFuZUJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZVBsYW5lVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVQbGFuZUJ1ZmZlcnMgPSBjcmVhdGVQbGFuZUJ1ZmZlcnM7XG52YXIgY3JlYXRlU3BoZXJlQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZVNwaGVyZVZlcnRpY2VzKTtcbmV4cG9ydHMuY3JlYXRlU3BoZXJlQnVmZmVySW5mbyA9IGNyZWF0ZVNwaGVyZUJ1ZmZlckluZm87XG52YXIgY3JlYXRlU3BoZXJlQnVmZmVycyA9IGNyZWF0ZUJ1ZmZlckZ1bmMoY3JlYXRlU3BoZXJlVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVTcGhlcmVCdWZmZXJzID0gY3JlYXRlU3BoZXJlQnVmZmVycztcbnZhciBjcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZVRydW5jYXRlZENvbmVWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJJbmZvID0gY3JlYXRlVHJ1bmNhdGVkQ29uZUJ1ZmZlckluZm87XG52YXIgY3JlYXRlVHJ1bmNhdGVkQ29uZUJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZVRydW5jYXRlZENvbmVWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJzID0gY3JlYXRlVHJ1bmNhdGVkQ29uZUJ1ZmZlcnM7XG52YXIgY3JlYXRlWFlRdWFkQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZVhZUXVhZFZlcnRpY2VzKTtcbmV4cG9ydHMuY3JlYXRlWFlRdWFkQnVmZmVySW5mbyA9IGNyZWF0ZVhZUXVhZEJ1ZmZlckluZm87XG52YXIgY3JlYXRlWFlRdWFkQnVmZmVycyA9IGNyZWF0ZUJ1ZmZlckZ1bmMoY3JlYXRlWFlRdWFkVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVYWVF1YWRCdWZmZXJzID0gY3JlYXRlWFlRdWFkQnVmZmVycztcbnZhciBjcmVhdGVDcmVzZW50QnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZUNyZXNlbnRWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZUNyZXNlbnRCdWZmZXJJbmZvID0gY3JlYXRlQ3Jlc2VudEJ1ZmZlckluZm87XG52YXIgY3JlYXRlQ3Jlc2VudEJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZUNyZXNlbnRWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZUNyZXNlbnRCdWZmZXJzID0gY3JlYXRlQ3Jlc2VudEJ1ZmZlcnM7XG52YXIgY3JlYXRlQ3lsaW5kZXJCdWZmZXJJbmZvID0gY3JlYXRlQnVmZmVySW5mb0Z1bmMoY3JlYXRlQ3lsaW5kZXJWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZUN5bGluZGVyQnVmZmVySW5mbyA9IGNyZWF0ZUN5bGluZGVyQnVmZmVySW5mbztcbnZhciBjcmVhdGVDeWxpbmRlckJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZUN5bGluZGVyVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVDeWxpbmRlckJ1ZmZlcnMgPSBjcmVhdGVDeWxpbmRlckJ1ZmZlcnM7XG52YXIgY3JlYXRlVG9ydXNCdWZmZXJJbmZvID0gY3JlYXRlQnVmZmVySW5mb0Z1bmMoY3JlYXRlVG9ydXNWZXJ0aWNlcyk7XG5leHBvcnRzLmNyZWF0ZVRvcnVzQnVmZmVySW5mbyA9IGNyZWF0ZVRvcnVzQnVmZmVySW5mbztcbnZhciBjcmVhdGVUb3J1c0J1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZVRvcnVzVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVUb3J1c0J1ZmZlcnMgPSBjcmVhdGVUb3J1c0J1ZmZlcnM7XG52YXIgY3JlYXRlRGlzY0J1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVEaXNjVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVEaXNjQnVmZmVySW5mbyA9IGNyZWF0ZURpc2NCdWZmZXJJbmZvO1xudmFyIGNyZWF0ZURpc2NCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVEaXNjVmVydGljZXMpO1xuZXhwb3J0cy5jcmVhdGVEaXNjQnVmZmVycyA9IGNyZWF0ZURpc2NCdWZmZXJzO1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgX2V4cG9ydE5hbWVzID0ge1xuICBhZGRFeHRlbnNpb25zVG9Db250ZXh0OiB0cnVlLFxuICBnZXRDb250ZXh0OiB0cnVlLFxuICBnZXRXZWJHTENvbnRleHQ6IHRydWUsXG4gIHJlc2l6ZUNhbnZhc1RvRGlzcGxheVNpemU6IHRydWUsXG4gIHNldERlZmF1bHRzOiB0cnVlXG59O1xuZXhwb3J0cy5hZGRFeHRlbnNpb25zVG9Db250ZXh0ID0gYWRkRXh0ZW5zaW9uc1RvQ29udGV4dDtcbmV4cG9ydHMuZ2V0Q29udGV4dCA9IGdldENvbnRleHQ7XG5leHBvcnRzLmdldFdlYkdMQ29udGV4dCA9IGdldFdlYkdMQ29udGV4dDtcbmV4cG9ydHMucmVzaXplQ2FudmFzVG9EaXNwbGF5U2l6ZSA9IHJlc2l6ZUNhbnZhc1RvRGlzcGxheVNpemU7XG5leHBvcnRzLnNldERlZmF1bHRzID0gc2V0RGVmYXVsdHM7XG5cbnZhciBhdHRyaWJ1dGVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG5cbk9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbn0pO1xuXG52YXIgdGV4dHVyZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcblxuT2JqZWN0LmtleXModGV4dHVyZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IHRleHR1cmVzW2tleV07XG59KTtcblxudmFyIGhlbHBlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oMCkpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcblxuT2JqZWN0LmtleXModXRpbHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IHV0aWxzW2tleV07XG59KTtcblxudmFyIF9kcmF3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbk9iamVjdC5rZXlzKF9kcmF3KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfZHJhd1trZXldO1xufSk7XG5cbnZhciBfZnJhbWVidWZmZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbk9iamVjdC5rZXlzKF9mcmFtZWJ1ZmZlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9mcmFtZWJ1ZmZlcnNba2V5XTtcbn0pO1xuXG52YXIgX3Byb2dyYW1zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuT2JqZWN0LmtleXMoX3Byb2dyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfcHJvZ3JhbXNba2V5XTtcbn0pO1xuXG52YXIgX3R5cGVkYXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuT2JqZWN0LmtleXMoX3R5cGVkYXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfdHlwZWRhcnJheXNba2V5XTtcbn0pO1xuXG52YXIgX3ZlcnRleEFycmF5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG5PYmplY3Qua2V5cyhfdmVydGV4QXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfdmVydGV4QXJyYXlzW2tleV07XG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMTUsIEdyZWdnIFRhdmFyZXMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4gKiBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4gKiBkaXN0cmlidXRpb24uXG4gKiAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdyZWdnIFRhdmFyZXMuIG5vciB0aGUgbmFtZXMgb2YgaGlzXG4gKiBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuLyoqXG4gKiBUaGUgbWFpbiBUV0dMIG1vZHVsZS5cbiAqXG4gKiBGb3IgbW9zdCB1c2UgY2FzZXMgeW91IHNob3VsZG4ndCBuZWVkIGFueXRoaW5nIG91dHNpZGUgdGhpcyBtb2R1bGUuXG4gKiBFeGNlcHRpb25zIGJldHdlZW4gdGhlIHN0dWZmIGFkZGVkIHRvIHR3Z2wtZnVsbCAodjMsIG00LCBwcmltaXRpdmVzKVxuICpcbiAqIEBtb2R1bGUgdHdnbFxuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvYXR0cmlidXRlcy5zZXRBdHRyaWJJbmZvQnVmZmVyRnJvbUFycmF5IGFzIHNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXlcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXMuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMgYXMgY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXNcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXMuY3JlYXRlVmVydGV4QXJyYXlJbmZvIGFzIGNyZWF0ZVZlcnRleEFycmF5SW5mb1xuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvZHJhdy5kcmF3QnVmZmVySW5mbyBhcyBkcmF3QnVmZmVySW5mb1xuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvZHJhdy5kcmF3T2JqZWN0TGlzdCBhcyBkcmF3T2JqZWN0TGlzdFxuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvZnJhbWVidWZmZXJzLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyBhcyBjcmVhdGVGcmFtZWJ1ZmZlckluZm9cbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL2ZyYW1lYnVmZmVycy5yZXNpemVGcmFtZWJ1ZmZlckluZm8gYXMgcmVzaXplRnJhbWVidWZmZXJJbmZvXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9mcmFtZWJ1ZmZlcnMuYmluZEZyYW1lYnVmZmVySW5mbyBhcyBiaW5kRnJhbWVidWZmZXJJbmZvXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9wcm9ncmFtcy5jcmVhdGVQcm9ncmFtSW5mbyBhcyBjcmVhdGVQcm9ncmFtSW5mb1xuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvcHJvZ3JhbXMuY3JlYXRlVW5pZm9ybUJsb2NrSW5mbyBhcyBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC9wcm9ncmFtcy5iaW5kVW5pZm9ybUJsb2NrIGFzIGJpbmRVbmlmb3JtQmxvY2tcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL3Byb2dyYW1zLnNldFVuaWZvcm1CbG9jayBhcyBzZXRVbmlmb3JtQmxvY2tcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL3Byb2dyYW1zLnNldEJsb2NrVW5pZm9ybXMgYXMgc2V0QmxvY2tVbmlmb3Jtc1xuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvcHJvZ3JhbXMuc2V0VW5pZm9ybXMgYXMgc2V0VW5pZm9ybXNcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL3Byb2dyYW1zLnNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzIGFzIHNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC90ZXh0dXJlcy5zZXRUZXh0dXJlRnJvbUFycmF5IGFzIHNldFRleHR1cmVGcm9tQXJyYXlcbiAqIEBib3Jyb3dzIG1vZHVsZTp0d2dsL3RleHR1cmVzLmNyZWF0ZVRleHR1cmUgYXMgY3JlYXRlVGV4dHVyZVxuICogQGJvcnJvd3MgbW9kdWxlOnR3Z2wvdGV4dHVyZXMucmVzaXplVGV4dHVyZSBhcyByZXNpemVUZXh0dXJlXG4gKiBAYm9ycm93cyBtb2R1bGU6dHdnbC90ZXh0dXJlcy5jcmVhdGVUZXh0dXJlcyBhcyBjcmVhdGVUZXh0dXJlc1xuICovXG4vLyBtYWtlIHN1cmUgd2UgZG9uJ3Qgc2VlIGEgZ2xvYmFsIGdsXG52YXIgZ2wgPSB1bmRlZmluZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGRFeHRlbnNpb25zVG9Db250ZXh0OiB0cnVlXG59O1xuLyoqXG4gKiBWYXJpb3VzIGRlZmF1bHQgc2V0dGluZ3MgZm9yIHR3Z2wuXG4gKlxuICogTm90ZTogWW91IGNhbiBjYWxsIHRoaXMgYW55IG51bWJlciBvZiB0aW1lcy4gRXhhbXBsZTpcbiAqXG4gKiAgICAgdHdnbC5zZXREZWZhdWx0cyh7IHRleHR1cmVDb2xvcjogWzEsIDAsIDAsIDFdIH0pO1xuICogICAgIHR3Z2wuc2V0RGVmYXVsdHMoeyBhdHRyaWJQcmVmaXg6ICdhXycgfSk7XG4gKlxuICogaXMgZXF1aXZhbGVudCB0b1xuICpcbiAqICAgICB0d2dsLnNldERlZmF1bHRzKHtcbiAqICAgICAgIHRleHR1cmVDb2xvcjogWzEsIDAsIDAsIDFdLFxuICogICAgICAgYXR0cmliUHJlZml4OiAnYV8nLFxuICogICAgIH0pO1xuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlZmF1bHRzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXR0cmliUHJlZml4IFRoZSBwcmVmaXggdG8gc3RpY2sgb24gYXR0cmlidXRlc1xuICpcbiAqICAgV2hlbiB3cml0aW5nIHNoYWRlcnMgSSBwcmVmZXIgdG8gbmFtZSBhdHRyaWJ1dGVzIHdpdGggYGFfYCwgdW5pZm9ybXMgd2l0aCBgdV9gIGFuZCB2YXJ5aW5ncyB3aXRoIGB2X2BcbiAqICAgYXMgaXQgbWFrZXMgaXQgY2xlYXIgd2hlcmUgdGhleSBjYW1lIGZyb20uIEJ1dCwgd2hlbiBidWlsZGluZyBnZW9tZXRyeSBJIHByZWZlciB1c2luZyB1bnByZWZpeGVkIG5hbWVzLlxuICpcbiAqICAgSW4gb3RoZXJ3b3JkcyBJJ2xsIGNyZWF0ZSBhcnJheXMgb2YgZ2VvbWV0cnkgbGlrZSB0aGlzXG4gKlxuICogICAgICAgY29uc3QgYXJyYXlzID0ge1xuICogICAgICAgICBwb3NpdGlvbjogLi4uXG4gKiAgICAgICAgIG5vcm1hbDogLi4uXG4gKiAgICAgICAgIHRleGNvb3JkOiAuLi5cbiAqICAgICAgIH07XG4gKlxuICogICBCdXQgbmVlZCB0aG9zZSBtYXBwZWQgdG8gYXR0cmlidXRlcyBhbmQgbXkgYXR0cmlidXRlcyBzdGFydCB3aXRoIGBhX2AuXG4gKlxuICogICBEZWZhdWx0OiBgXCJcImBcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcltdfSB0ZXh0dXJlQ29sb3IgQXJyYXkgb2YgNCB2YWx1ZXMgaW4gdGhlIHJhbmdlIDAgdG8gMVxuICpcbiAqICAgVGhlIGRlZmF1bHQgdGV4dHVyZSBjb2xvciBpcyB1c2VkIHdoZW4gbG9hZGluZyB0ZXh0dXJlcyBmcm9tXG4gKiAgIHVybHMuIEJlY2F1c2UgdGhlIFVSTCB3aWxsIGJlIGxvYWRlZCBhc3luYyB3ZSdkIGxpa2UgdG8gYmVcbiAqICAgYWJsZSB0byB1c2UgdGhlIHRleHR1cmUgaW1tZWRpYXRlbHkuIEJ5IHB1dHRpbmcgYSAxeDEgcGl4ZWxcbiAqICAgY29sb3IgaW4gdGhlIHRleHR1cmUgd2UgY2FuIHN0YXJ0IHVzaW5nIHRoZSB0ZXh0dXJlIGJlZm9yZVxuICogICB0aGUgVVJMIGhhcyBsb2FkZWQuXG4gKlxuICogICBEZWZhdWx0OiBgWzAuNSwgMC43NSwgMSwgMV1gXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNyb3NzT3JpZ2luXG4gKlxuICogICBJZiBub3QgdW5kZWZpbmVkIHNldHMgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBvbiBpbWFnZXNcbiAqICAgdGhhdCB0d2dsIGNyZWF0ZXMgd2hlbiBkb3dubG9hZGluZyBpbWFnZXMgZm9yIHRleHR1cmVzLlxuICpcbiAqICAgQWxzbyBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfS5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2x9IGFkZEV4dGVuc2lvbnNUb0NvbnRleHRcbiAqXG4gKiAgIElmIHRydWUsIHRoZW4sIHdoZW4gdHdnbCB3aWxsIHRyeSB0byBhZGQgYW55IHN1cHBvcnRlZCBXZWJHTCBleHRlbnNpb25zXG4gKiAgIGRpcmVjdGx5IHRvIHRoZSBjb250ZXh0IHVuZGVyIHRoZWlyIG5vcm1hbCBHTCBuYW1lcy4gRm9yIGV4YW1wbGVcbiAqICAgaWYgQU5HTEVfaW5zdGFuY2VzX2FycmF5cyBleGlzdHMgdGhlbiB0d2dsIHdvdWxkIGVuYWJsZSBpdCxcbiAqICAgYWRkIHRoZSBmdW5jdGlvbnMgYHZlcnRleEF0dHJpYkRpdmlzb3JgLCBgZHJhd0FycmF5c0luc3RhbmNlZGAsXG4gKiAgIGBkcmF3RWxlbWVudHNJbnN0YW5jZWRgLCBhbmQgdGhlIGNvbnN0YW50IGBWRVJURVhfQVRUUklCX0FSUkFZX0RJVklTT1JgXG4gKiAgIHRvIHRoZSBgV2ViR0xSZW5kZXJpbmdDb250ZXh0YC5cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIFNldHMgdmFyaW91cyBkZWZhdWx0cyBmb3IgdHdnbC5cbiAqXG4gKiBJbiB0aGUgaW50ZXJlc3Qgb2YgdGVyc2VuZXNzIHdoaWNoIGlzIGtpbmQgb2YgdGhlIHBvaW50XG4gKiBvZiB0d2dsIEkndmUgaW50ZWdyYXRlZCBhIGZldyBvZiB0aGUgb2xkZXIgZnVuY3Rpb25zIGhlcmVcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkRlZmF1bHRzfSBuZXdEZWZhdWx0cyBUaGUgZGVmYXVsdCBzZXR0aW5ncy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbmZ1bmN0aW9uIHNldERlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gIGhlbHBlci5jb3B5RXhpc3RpbmdQcm9wZXJ0aWVzKG5ld0RlZmF1bHRzLCBkZWZhdWx0cyk7XG4gIGF0dHJpYnV0ZXMuc2V0QXR0cmlidXRlRGVmYXVsdHNfKG5ld0RlZmF1bHRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIHRleHR1cmVzLnNldFRleHR1cmVEZWZhdWx0c18obmV3RGVmYXVsdHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59XG5cbnZhciBwcmVmaXhSRSA9IC9eKC4qPylfLztcblxuZnVuY3Rpb24gYWRkRXh0ZW5zaW9uVG9Db250ZXh0KGdsLCBleHRlbnNpb25OYW1lKSB7XG4gIHV0aWxzLmdsRW51bVRvU3RyaW5nKGdsLCAwKTtcbiAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihleHRlbnNpb25OYW1lKTtcblxuICBpZiAoZXh0KSB7XG4gICAgdmFyIGVudW1zID0ge307XG4gICAgdmFyIGZuU3VmZml4ID0gcHJlZml4UkUuZXhlYyhleHRlbnNpb25OYW1lKVsxXTtcbiAgICB2YXIgZW51bVN1ZmZpeCA9ICdfJyArIGZuU3VmZml4O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGV4dCkge1xuICAgICAgdmFyIHZhbHVlID0gZXh0W2tleV07XG4gICAgICB2YXIgaXNGdW5jID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHN1ZmZpeCA9IGlzRnVuYyA/IGZuU3VmZml4IDogZW51bVN1ZmZpeDtcbiAgICAgIHZhciBuYW1lID0ga2V5OyAvLyBleGFtcGxlcyBvZiB3aGVyZSB0aGlzIGlzIG5vdCB0cnVlIGFyZSBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xuICAgICAgLy8gYW5kIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xuXG4gICAgICBpZiAoa2V5LmVuZHNXaXRoKHN1ZmZpeCkpIHtcbiAgICAgICAgbmFtZSA9IGtleS5zdWJzdHJpbmcoMCwga2V5Lmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2xbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWlzRnVuYyAmJiBnbFtuYW1lXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBoZWxwZXIud2FybihuYW1lLCBnbFtuYW1lXSwgdmFsdWUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBnbFtuYW1lXSA9IGZ1bmN0aW9uIChvcmlnRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvcmlnRm4uYXBwbHkoZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIGVudW1zW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHBhc3MgdGhlIG1vZGlmaWVkIGVudW1zIHRvIGdsRW51bVRvU3RyaW5nXG5cblxuICAgIGVudW1zLmNvbnN0cnVjdG9yID0ge1xuICAgICAgbmFtZTogZXh0LmNvbnN0cnVjdG9yLm5hbWVcbiAgICB9O1xuICAgIHV0aWxzLmdsRW51bVRvU3RyaW5nKGVudW1zLCAwKTtcbiAgfVxuXG4gIHJldHVybiBleHQ7XG59XG4vKlxuICogSWYgeW91J3JlIHdvbmRlcmluZyB3aHkgdGhlIGNvZGUgZG9lc24ndCBqdXN0IGl0ZXJhdGVcbiAqIG92ZXIgYWxsIGV4dGVuc2lvbnMgdXNpbmcgYGdsLmdldEV4dGVuc2lvbnNgIGlzIHRoYXQgaXQncyBwb3NzaWJsZVxuICogc29tZSBmdXR1cmUgZXh0ZW5zaW9uIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoaXMgY29kZS4gUmF0aGVyIHRoYW5cbiAqIGhhdmUgdGhpbmcgc3VkZGVubHkgYnJlYWsgaXQgc2VlbXMgYmV0dGVyIHRvIG1hbnVhbGx5IGFkZCB0byB0aGlzXG4gKiBsaXN0LlxuICpcbiAqL1xuXG5cbnZhciBzdXBwb3J0ZWRFeHRlbnNpb25zID0gWydBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJywgJ0VYVF9ibGVuZF9taW5tYXgnLCAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcsICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnLCAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5JywgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInLCAnRVhUX2ZyYWdfZGVwdGgnLCAnRVhUX3NSR0InLCAnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcsICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnLCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcsICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnLCAnT0VTX3RleHR1cmVfZmxvYXQnLCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJywgJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnLCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInLCAnT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnLCAnV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JywgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hdGMnLCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnLCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJywgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJywgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2InLCAnV0VCR0xfZGVwdGhfdGV4dHVyZScsICdXRUJHTF9kcmF3X2J1ZmZlcnMnXTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5hYmxlIGFsbCBvZiB0aGUgZm9sbG93aW5nIGV4dGVuc2lvbnNcbiAqIGFuZCBhZGQgdGhlaXIgZnVuY3Rpb25zIGFuZCBjb25zdGFudHMgdG8gdGhlXG4gKiBgV2ViR0xSZW5kZXJpbmdDb250ZXh0YCB1c2luZyB0aGVpciBub3JtYWwgbm9uLWV4dGVuc2lvbiBsaWtlIG5hbWVzLlxuICpcbiAqICAgICAgQU5HTEVfaW5zdGFuY2VkX2FycmF5c1xuICogICAgICBFWFRfYmxlbmRfbWlubWF4XG4gKiAgICAgIEVYVF9jb2xvcl9idWZmZXJfZmxvYXRcbiAqICAgICAgRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XG4gKiAgICAgIEVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVxuICogICAgICBFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyXG4gKiAgICAgIEVYVF9mcmFnX2RlcHRoXG4gKiAgICAgIEVYVF9zUkdCXG4gKiAgICAgIEVYVF9zaGFkZXJfdGV4dHVyZV9sb2RcbiAqICAgICAgRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXG4gKiAgICAgIE9FU19lbGVtZW50X2luZGV4X3VpbnRcbiAqICAgICAgT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXG4gKiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0XG4gKiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclxuICogICAgICBPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XG4gKiAgICAgIE9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXG4gKiAgICAgIE9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XG4gKiAgICAgIFdFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdFxuICogICAgICBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXRjXG4gKiAgICAgIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxXG4gKiAgICAgIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xuICogICAgICBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xuICogICAgICBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiXG4gKiAgICAgIFdFQkdMX2RlcHRoX3RleHR1cmVcbiAqICAgICAgV0VCR0xfZHJhd19idWZmZXJzXG4gKlxuICogRm9yIGV4YW1wbGUgaWYgYEFOR0xFX2luc3RhbmNlZF9hcnJheXNgIGV4aXN0cyB0aGVuIHRoZSBmdW5jdGlvbnNcbiAqIGBkcmF3QXJyYXlzSW5zdGFuY2VkYCwgYGRyYXdFbGVtZW50c0luc3RhbmNlZGAsIGB2ZXJ0ZXhBdHRyaWJEaXZpc29yYFxuICogYW5kIHRoZSBjb25zdGFudCBgVkVSVEVYX0FUVFJJQl9BUlJBWV9ESVZJU09SYCBhcmUgYWRkZWQgdG8gdGhlXG4gKiBgV2ViR0xSZW5kZXJpbmdDb250ZXh0YC5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgeW91IHdhbnQgdG8ga25vdyBpZiB0aGUgZXh0ZW5zaW9uIGV4aXN0cyB5b3Ugc2hvdWxkXG4gKiBwcm9iYWJseSBjYWxsIGBnbC5nZXRFeHRlbnNpb25gIGZvciBlYWNoIGV4dGVuc2lvbi4gQWx0ZXJuYXRpdmVseVxuICogeW91IGNhbiBjaGVjayBmb3IgdGhlIGV4aXN0YW5jZSBvZiB0aGUgZnVuY3Rpb25zIG9yIGNvbnN0YW50cyB0aGF0XG4gKiBhcmUgZXhwZWN0ZWQgdG8gYmUgYWRkZWQuIEZvciBleGFtcGxlXG4gKlxuICogICAgaWYgKGdsLmRyYXdCdWZmZXJzKSB7XG4gKiAgICAgIC8vIEVpdGhlciBXRUJHTF9kcmF3X2J1ZmZlcnMgd2FzIGVuYWJsZWQgT1IgeW91J3JlIHJ1bm5pbmcgaW4gV2ViR0wyXG4gKiAgICAgIC4uLi5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbmZ1bmN0aW9uIGFkZEV4dGVuc2lvbnNUb0NvbnRleHQoZ2wpIHtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHN1cHBvcnRlZEV4dGVuc2lvbnMubGVuZ3RoOyArK2lpKSB7XG4gICAgYWRkRXh0ZW5zaW9uVG9Db250ZXh0KGdsLCBzdXBwb3J0ZWRFeHRlbnNpb25zW2lpXSk7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIHdlYmdsIGNvbnRleHQuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgVGhlIGNhbnZhcyB0YWcgdG8gZ2V0XG4gKiAgICAgY29udGV4dCBmcm9tLiBJZiBvbmUgaXMgbm90IHBhc3NlZCBpbiBvbmUgd2lsbCBiZVxuICogICAgIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjcmVhdGVkIGNvbnRleHQuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGUzRENvbnRleHQoY2FudmFzLCBvcHRfYXR0cmlicykge1xuICB2YXIgbmFtZXMgPSBbXCJ3ZWJnbFwiLCBcImV4cGVyaW1lbnRhbC13ZWJnbFwiXTtcbiAgdmFyIGNvbnRleHQgPSBudWxsO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBuYW1lcy5sZW5ndGg7ICsraWkpIHtcbiAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQobmFtZXNbaWldLCBvcHRfYXR0cmlicyk7XG5cbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgaWYgKGRlZmF1bHRzLmFkZEV4dGVuc2lvbnNUb0NvbnRleHQpIHtcbiAgICAgICAgYWRkRXh0ZW5zaW9uc1RvQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG4vKipcbiAqIEdldHMgYSBXZWJHTDEgY29udGV4dC5cbiAqXG4gKiBOb3RlOiBXaWxsIGF0dGVtcHQgdG8gZW5hYmxlIFZlcnRleCBBcnJheSBPYmplY3RzXG4gKiBhbmQgYWRkIFdlYkdMMiBlbnRyeSBwb2ludHMuICh1bmxlc3MgeW91IGZpcnN0IHNldCBkZWZhdWx0cyB3aXRoXG4gKiBgdHdnbC5zZXREZWZhdWx0cyh7ZW5hYmxlVmVydGV4QXJyYXlPYmplY3RzOiBmYWxzZX0pYDtcbiAqXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgYSBjYW52YXMgZWxlbWVudC5cbiAqIEBwYXJhbSB7V2ViR0xDb250ZXh0Q3JlYXRpb25BdHRpcmJ1dGVzfSBbb3B0X2F0dHJpYnNdIG9wdGlvbmFsIHdlYmdsIGNvbnRleHQgY3JlYXRpb24gYXR0cmlidXRlc1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRXZWJHTENvbnRleHQoY2FudmFzLCBvcHRfYXR0cmlicykge1xuICB2YXIgZ2wgPSBjcmVhdGUzRENvbnRleHQoY2FudmFzLCBvcHRfYXR0cmlicyk7XG4gIHJldHVybiBnbDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHdlYmdsIGNvbnRleHQuXG4gKlxuICogV2lsbCByZXR1cm4gYSBXZWJHTDIgY29udGV4dCBpZiBwb3NzaWJsZS5cbiAqXG4gKiBZb3UgY2FuIGNoZWNrIGlmIGl0J3MgV2ViR0wyIHdpdGhcbiAqXG4gKiAgICAgdHdnbC5pc1dlYkdMMihnbCk7XG4gKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIFRoZSBjYW52YXMgdGFnIHRvIGdldFxuICogICAgIGNvbnRleHQgZnJvbS4gSWYgb25lIGlzIG5vdCBwYXNzZWQgaW4gb25lIHdpbGwgYmVcbiAqICAgICBjcmVhdGVkLlxuICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3JlYXRlZCBjb250ZXh0LlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKSB7XG4gIHZhciBuYW1lcyA9IFtcIndlYmdsMlwiLCBcIndlYmdsXCIsIFwiZXhwZXJpbWVudGFsLXdlYmdsXCJdO1xuICB2YXIgY29udGV4dCA9IG51bGw7XG5cbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5hbWVzLmxlbmd0aDsgKytpaSkge1xuICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChuYW1lc1tpaV0sIG9wdF9hdHRyaWJzKTtcblxuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICBpZiAoZGVmYXVsdHMuYWRkRXh0ZW5zaW9uc1RvQ29udGV4dCkge1xuICAgICAgICBhZGRFeHRlbnNpb25zVG9Db250ZXh0KGNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cbi8qKlxuICogR2V0cyBhIFdlYkdMIGNvbnRleHQuICBXaWxsIGNyZWF0ZSBhIFdlYkdMMiBjb250ZXh0IGlmIHBvc3NpYmxlLlxuICpcbiAqIFlvdSBjYW4gY2hlY2sgaWYgaXQncyBXZWJHTDIgd2l0aFxuICpcbiAqICAgIGZ1bmN0aW9uIGlzV2ViR0wyKGdsKSB7XG4gKiAgICAgIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuVkVSU0lPTikuaW5kZXhPZihcIldlYkdMIDIuMCBcIikgPT0gMDtcbiAqICAgIH1cbiAqXG4gKiBOb3RlOiBGb3IgYSBXZWJHTDEgY29udGV4dCB3aWxsIGF0dGVtcHQgdG8gZW5hYmxlIFZlcnRleCBBcnJheSBPYmplY3RzXG4gKiBhbmQgYWRkIFdlYkdMMiBlbnRyeSBwb2ludHMuICh1bmxlc3MgeW91IGZpcnN0IHNldCBkZWZhdWx0cyB3aXRoXG4gKiBgdHdnbC5zZXREZWZhdWx0cyh7ZW5hYmxlVmVydGV4QXJyYXlPYmplY3RzOiBmYWxzZX0pYDtcbiAqXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgYSBjYW52YXMgZWxlbWVudC5cbiAqIEBwYXJhbSB7V2ViR0xDb250ZXh0Q3JlYXRpb25BdHRpcmJ1dGVzfSBbb3B0X2F0dHJpYnNdIG9wdGlvbmFsIHdlYmdsIGNvbnRleHQgY3JlYXRpb24gYXR0cmlidXRlc1xuICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3JlYXRlZCBjb250ZXh0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0KGNhbnZhcywgb3B0X2F0dHJpYnMpIHtcbiAgdmFyIGdsID0gY3JlYXRlQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKTtcbiAgcmV0dXJuIGdsO1xufVxuLyoqXG4gKiBSZXNpemUgYSBjYW52YXMgdG8gbWF0Y2ggdGhlIHNpemUgaXQncyBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgVGhlIGNhbnZhcyB0byByZXNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gW211bHRpcGxpZXJdIFNvIHlvdSBjYW4gcGFzcyBpbiBgd2luZG93LmRldmljZVBpeGVsUmF0aW9gIG9yIG90aGVyIHNjYWxlIHZhbHVlIGlmIHlvdSB3YW50IHRvLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2FudmFzIHdhcyByZXNpemVkLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG5mdW5jdGlvbiByZXNpemVDYW52YXNUb0Rpc3BsYXlTaXplKGNhbnZhcywgbXVsdGlwbGllcikge1xuICBtdWx0aXBsaWVyID0gbXVsdGlwbGllciB8fCAxO1xuICBtdWx0aXBsaWVyID0gTWF0aC5tYXgoMCwgbXVsdGlwbGllcik7XG4gIHZhciB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aCAqIG11bHRpcGxpZXIgfCAwO1xuICB2YXIgaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodCAqIG11bHRpcGxpZXIgfCAwO1xuXG4gIGlmIChjYW52YXMud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZHJhd0J1ZmZlckluZm8gPSBkcmF3QnVmZmVySW5mbztcbmV4cG9ydHMuZHJhd09iamVjdExpc3QgPSBkcmF3T2JqZWN0TGlzdDtcblxudmFyIHByb2dyYW1zID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXyg1KSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLypcbiAqIENvcHlyaWdodCAyMDE1LCBHcmVnZyBUYXZhcmVzLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuICogaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuICogZGlzdHJpYnV0aW9uLlxuICogICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiBHcmVnZyBUYXZhcmVzLiBub3IgdGhlIG5hbWVzIG9mIGhpc1xuICogY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qKlxuICogRHJhd2luZyByZWxhdGVkIGZ1bmN0aW9uc1xuICpcbiAqIEZvciBiYWNrd2FyZCBjb21wYXRpYmlseSB0aGV5IGFyZSBhdmFpbGFibGUgYXQgYm90aCBgdHdnbC5kcmF3YCBhbmQgYHR3Z2xgXG4gKiBpdHNlbGZcbiAqXG4gKiBTZWUge0BsaW5rIG1vZHVsZTp0d2dsfSBmb3IgY29yZSBmdW5jdGlvbnNcbiAqXG4gKiBAbW9kdWxlIHR3Z2wvZHJhd1xuICovXG5cbi8qKlxuICogQ2FsbHMgYGdsLmRyYXdFbGVtZW50c2Agb3IgYGdsLmRyYXdBcnJheXNgLCB3aGljaGV2ZXIgaXMgYXBwcm9wcmlhdGVcbiAqXG4gKiBub3JtYWxseSB5b3UnZCBjYWxsIGBnbC5kcmF3RWxlbWVudHNgIG9yIGBnbC5kcmF3QXJyYXlzYCB5b3Vyc2VsZlxuICogYnV0IGNhbGxpbmcgdGhpcyBtZWFucyBpZiB5b3Ugc3dpdGNoIGZyb20gaW5kZXhlZCBkYXRhIHRvIG5vbi1pbmRleGVkXG4gKiBkYXRhIHlvdSBkb24ndCBoYXZlIHRvIHJlbWVtYmVyIHRvIHVwZGF0ZSB5b3VyIGRyYXcgY2FsbC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLkJ1ZmZlckluZm98bW9kdWxlOnR3Z2wuVmVydGV4QXJyYXlJbmZvKX0gYnVmZmVySW5mbyBBIEJ1ZmZlckluZm8gYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXN9IG9yXG4gKiAgIGEgVmVydGV4QXJyYXlJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVZlcnRleEFycmF5SW5mb31cbiAqIEBwYXJhbSB7ZW51bX0gW3R5cGVdIGVnIChnbC5UUklBTkdMRVMsIGdsLkxJTkVTLCBnbC5QT0lOVFMsIGdsLlRSSUFOR0xFX1NUUklQLCAuLi4pLiBEZWZhdWx0cyB0byBgZ2wuVFJJQU5HTEVTYFxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF0gQW4gb3B0aW9uYWwgY291bnQuIERlZmF1bHRzIHRvIGJ1ZmZlckluZm8ubnVtRWxlbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0XSBBbiBvcHRpb25hbCBvZmZzZXQuIERlZmF1bHRzIHRvIDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2luc3RhbmNlQ291bnRdIEFuIG9wdGlvbmFsIGluc3RhbmNlQ291bnQuIGlmIHNldCB0aGVuIGBkcmF3QXJyYXlzSW5zdGFuY2VkYCBvciBgZHJhd0VsZW1lbnRzSW5zdGFuY2VkYCB3aWxsIGJlIGNhbGxlZFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2RyYXdcbiAqL1xuZnVuY3Rpb24gZHJhd0J1ZmZlckluZm8oZ2wsIGJ1ZmZlckluZm8sIHR5cGUsIGNvdW50LCBvZmZzZXQsIGluc3RhbmNlQ291bnQpIHtcbiAgdHlwZSA9IHR5cGUgPT09IHVuZGVmaW5lZCA/IGdsLlRSSUFOR0xFUyA6IHR5cGU7XG4gIHZhciBpbmRpY2VzID0gYnVmZmVySW5mby5pbmRpY2VzO1xuICB2YXIgZWxlbWVudFR5cGUgPSBidWZmZXJJbmZvLmVsZW1lbnRUeXBlO1xuICB2YXIgbnVtRWxlbWVudHMgPSBjb3VudCA9PT0gdW5kZWZpbmVkID8gYnVmZmVySW5mby5udW1FbGVtZW50cyA6IGNvdW50O1xuICBvZmZzZXQgPSBvZmZzZXQgPT09IHVuZGVmaW5lZCA/IDAgOiBvZmZzZXQ7XG5cbiAgaWYgKGVsZW1lbnRUeXBlIHx8IGluZGljZXMpIHtcbiAgICBpZiAoaW5zdGFuY2VDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBnbC5kcmF3RWxlbWVudHNJbnN0YW5jZWQodHlwZSwgbnVtRWxlbWVudHMsIGVsZW1lbnRUeXBlID09PSB1bmRlZmluZWQgPyBnbC5VTlNJR05FRF9TSE9SVCA6IGJ1ZmZlckluZm8uZWxlbWVudFR5cGUsIG9mZnNldCwgaW5zdGFuY2VDb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBudW1FbGVtZW50cywgZWxlbWVudFR5cGUgPT09IHVuZGVmaW5lZCA/IGdsLlVOU0lHTkVEX1NIT1JUIDogYnVmZmVySW5mby5lbGVtZW50VHlwZSwgb2Zmc2V0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGluc3RhbmNlQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZ2wuZHJhd0FycmF5c0luc3RhbmNlZCh0eXBlLCBvZmZzZXQsIG51bUVsZW1lbnRzLCBpbnN0YW5jZUNvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuZHJhd0FycmF5cyh0eXBlLCBvZmZzZXQsIG51bUVsZW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQSBEcmF3T2JqZWN0IGlzIHVzZWZ1bCBmb3IgcHV0dGluZyBvYmplY3RzIGluIHRvIGFuIGFycmF5IGFuZCBwYXNzaW5nIHRoZW0gdG8ge0BsaW5rIG1vZHVsZTp0d2dsLmRyYXdPYmplY3RMaXN0fS5cbiAqXG4gKiBZb3UgbmVlZCBlaXRoZXIgYSBgQnVmZmVySW5mb2Agb3IgYSBgVmVydGV4QXJyYXlJbmZvYC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEcmF3T2JqZWN0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthY3RpdmVdIHdoZXRoZXIgb3Igbm90IHRvIGRyYXcuIERlZmF1bHQgPSBgdHJ1ZWAgKG11c3QgYmUgYGZhbHNlYCB0byBiZSBub3QgdHJ1ZSkuIEluIG90aGVyd29yZHMgYHVuZGVmaW5lZGAgPSBgdHJ1ZWBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHlwZV0gdHlwZSB0byBkcmF3IGVnLiBgZ2wuVFJJQU5HTEVTYCwgYGdsLkxJTkVTYCwgZXRjLi4uXG4gKiBAcHJvcGVydHkge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBwcm9ncmFtSW5mbyBBIFByb2dyYW1JbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVByb2dyYW1JbmZvfVxuICogQHByb3BlcnR5IHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBbYnVmZmVySW5mb10gQSBCdWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzfVxuICogQHByb3BlcnR5IHttb2R1bGU6dHdnbC5WZXJ0ZXhBcnJheUluZm99IFt2ZXJ0ZXhBcnJheUluZm9dIEEgVmVydGV4QXJyYXlJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVZlcnRleEFycmF5SW5mb31cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgPz59IHVuaWZvcm1zIFRoZSB2YWx1ZXMgZm9yIHRoZSB1bmlmb3Jtcy5cbiAqICAgWW91IGNhbiBwYXNzIG11bHRpcGxlIG9iamVjdHMgYnkgcHV0dGluZyB0aGVtIGluIGFuIGFycmF5LiBGb3IgZXhhbXBsZVxuICpcbiAqICAgICB2YXIgc2hhcmVkVW5pZm9ybXMgPSB7XG4gKiAgICAgICB1X2ZvZ05lYXI6IDEwLFxuICogICAgICAgdV9wcm9qZWN0aW9uOiAuLi5cbiAqICAgICAgIC4uLlxuICogICAgIH07XG4gKlxuICogICAgIHZhciBsb2NhbFVuaWZvcm1zID0ge1xuICogICAgICAgdV93b3JsZDogLi4uXG4gKiAgICAgICB1X2RpZmZ1c2VDb2xvcjogLi4uXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgdmFyIGRyYXdPYmogPSB7XG4gKiAgICAgICAuLi5cbiAqICAgICAgIHVuaWZvcm1zOiBbc2hhcmVkVW5pZm9ybXMsIGxvY2FsVW5pZm9ybXNdLFxuICogICAgIH07XG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvZmZzZXRdIHRoZSBvZmZzZXQgdG8gcGFzcyB0byBgZ2wuZHJhd0FycmF5c2Agb3IgYGdsLmRyYXdFbGVtZW50c2AuIERlZmF1bHRzIHRvIDAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NvdW50XSB0aGUgY291bnQgdG8gcGFzcyB0byBgZ2wuZHJhd0FycmF5c2Agb3IgYGdsLmRyYXdFbGVtbnRzYC4gRGVmYXVsdHMgdG8gYnVmZmVySW5mby5udW1FbGVtZW50cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaW5zdGFuY2VDb3VudF0gdGhlIG51bWJlciBvZiBpbnN0YW5jZXMuIERlZmF1bHRzIHRvIHVuZGVmaW5lZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogRHJhd3MgYSBsaXN0IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7RHJhd09iamVjdFtdfSBvYmplY3RzVG9EcmF3IGFuIGFycmF5IG9mIG9iamVjdHMgdG8gZHJhdy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9kcmF3XG4gKi9cblxuXG5mdW5jdGlvbiBkcmF3T2JqZWN0TGlzdChnbCwgb2JqZWN0c1RvRHJhdykge1xuICB2YXIgbGFzdFVzZWRQcm9ncmFtSW5mbyA9IG51bGw7XG4gIHZhciBsYXN0VXNlZEJ1ZmZlckluZm8gPSBudWxsO1xuICBvYmplY3RzVG9EcmF3LmZvckVhY2goZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuYWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9ncmFtSW5mbyA9IG9iamVjdC5wcm9ncmFtSW5mbztcbiAgICB2YXIgYnVmZmVySW5mbyA9IG9iamVjdC52ZXJ0ZXhBcnJheUluZm8gfHwgb2JqZWN0LmJ1ZmZlckluZm87XG4gICAgdmFyIGJpbmRCdWZmZXJzID0gZmFsc2U7XG4gICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZSA9PT0gdW5kZWZpbmVkID8gZ2wuVFJJQU5HTEVTIDogb2JqZWN0LnR5cGU7XG5cbiAgICBpZiAocHJvZ3JhbUluZm8gIT09IGxhc3RVc2VkUHJvZ3JhbUluZm8pIHtcbiAgICAgIGxhc3RVc2VkUHJvZ3JhbUluZm8gPSBwcm9ncmFtSW5mbztcbiAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbUluZm8ucHJvZ3JhbSk7IC8vIFdlIGhhdmUgdG8gcmViaW5kIGJ1ZmZlcnMgd2hlbiBjaGFuZ2luZyBwcm9ncmFtcyBiZWNhdXNlIHdlXG4gICAgICAvLyBvbmx5IGJpbmQgYnVmZmVycyB0aGUgcHJvZ3JhbSB1c2VzLiBTbyBpZiAyIHByb2dyYW1zIHVzZSB0aGUgc2FtZVxuICAgICAgLy8gYnVmZmVySW5mbyBidXQgdGhlIDFzdCBvbmUgdXNlcyBvbmx5IHBvc2l0aW9ucyB0aGUgd2hlbiB0aGVcbiAgICAgIC8vIHdlIHN3aXRjaCB0byB0aGUgMm5kIG9uZSBzb21lIG9mIHRoZSBhdHRyaWJ1dGVzIHdpbGwgbm90IGJlIG9uLlxuXG4gICAgICBiaW5kQnVmZmVycyA9IHRydWU7XG4gICAgfSAvLyBTZXR1cCBhbGwgdGhlIG5lZWRlZCBhdHRyaWJ1dGVzLlxuXG5cbiAgICBpZiAoYmluZEJ1ZmZlcnMgfHwgYnVmZmVySW5mbyAhPT0gbGFzdFVzZWRCdWZmZXJJbmZvKSB7XG4gICAgICBpZiAobGFzdFVzZWRCdWZmZXJJbmZvICYmIGxhc3RVc2VkQnVmZmVySW5mby52ZXJ0ZXhBcnJheU9iamVjdCAmJiAhYnVmZmVySW5mby52ZXJ0ZXhBcnJheU9iamVjdCkge1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGxhc3RVc2VkQnVmZmVySW5mbyA9IGJ1ZmZlckluZm87XG4gICAgICBwcm9ncmFtcy5zZXRCdWZmZXJzQW5kQXR0cmlidXRlcyhnbCwgcHJvZ3JhbUluZm8sIGJ1ZmZlckluZm8pO1xuICAgIH0gLy8gU2V0IHRoZSB1bmlmb3Jtcy5cblxuXG4gICAgcHJvZ3JhbXMuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIG9iamVjdC51bmlmb3Jtcyk7IC8vIERyYXdcblxuICAgIGRyYXdCdWZmZXJJbmZvKGdsLCBidWZmZXJJbmZvLCB0eXBlLCBvYmplY3QuY291bnQsIG9iamVjdC5vZmZzZXQsIG9iamVjdC5pbnN0YW5jZUNvdW50KTtcbiAgfSk7XG5cbiAgaWYgKGxhc3RVc2VkQnVmZmVySW5mby52ZXJ0ZXhBcnJheU9iamVjdCkge1xuICAgIGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmJpbmRGcmFtZWJ1ZmZlckluZm8gPSBiaW5kRnJhbWVidWZmZXJJbmZvO1xuZXhwb3J0cy5jcmVhdGVGcmFtZWJ1ZmZlckluZm8gPSBjcmVhdGVGcmFtZWJ1ZmZlckluZm87XG5leHBvcnRzLnJlc2l6ZUZyYW1lYnVmZmVySW5mbyA9IHJlc2l6ZUZyYW1lYnVmZmVySW5mbztcblxudmFyIHRleHR1cmVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG5cbnZhciBoZWxwZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMTUsIEdyZWdnIFRhdmFyZXMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4gKiBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4gKiBkaXN0cmlidXRpb24uXG4gKiAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdyZWdnIFRhdmFyZXMuIG5vciB0aGUgbmFtZXMgb2YgaGlzXG4gKiBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuLyoqXG4gKiBGcmFtZWJ1ZmZlciByZWxhdGVkIGZ1bmN0aW9uc1xuICpcbiAqIEZvciBiYWNrd2FyZCBjb21wYXRpYmlseSB0aGV5IGFyZSBhdmFpbGFibGUgYXQgYm90aCBgdHdnbC5mcmFtZWJ1ZmZlcmAgYW5kIGB0d2dsYFxuICogaXRzZWxmXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6dHdnbH0gZm9yIGNvcmUgZnVuY3Rpb25zXG4gKlxuICogQG1vZHVsZSB0d2dsL2ZyYW1lYnVmZmVyc1xuICovXG4vLyBtYWtlIHN1cmUgd2UgZG9uJ3Qgc2VlIGEgZ2xvYmFsIGdsXG52YXIgZ2wgPSB1bmRlZmluZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxudmFyIFVOU0lHTkVEX0JZVEUgPSAweDE0MDE7XG4vKiBQaXhlbEZvcm1hdCAqL1xuXG52YXIgREVQVEhfQ09NUE9ORU5UID0gMHgxOTAyO1xudmFyIFJHQkEgPSAweDE5MDg7XG4vKiBGcmFtZWJ1ZmZlciBPYmplY3QuICovXG5cbnZhciBSR0JBNCA9IDB4ODA1NjtcbnZhciBSR0I1X0ExID0gMHg4MDU3O1xudmFyIFJHQjU2NSA9IDB4OEQ2MjtcbnZhciBERVBUSF9DT01QT05FTlQxNiA9IDB4ODFBNTtcbnZhciBTVEVOQ0lMX0lOREVYID0gMHgxOTAxO1xudmFyIFNURU5DSUxfSU5ERVg4ID0gMHg4RDQ4O1xudmFyIERFUFRIX1NURU5DSUwgPSAweDg0Rjk7XG52YXIgQ09MT1JfQVRUQUNITUVOVDAgPSAweDhDRTA7XG52YXIgREVQVEhfQVRUQUNITUVOVCA9IDB4OEQwMDtcbnZhciBTVEVOQ0lMX0FUVEFDSE1FTlQgPSAweDhEMjA7XG52YXIgREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UID0gMHg4MjFBO1xuLyogVGV4dHVyZVdyYXBNb2RlICovXG5cbnZhciBSRVBFQVQgPSAweDI5MDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxudmFyIENMQU1QX1RPX0VER0UgPSAweDgxMkY7XG52YXIgTUlSUk9SRURfUkVQRUFUID0gMHg4MzcwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qIFRleHR1cmVNYWdGaWx0ZXIgKi9cblxudmFyIE5FQVJFU1QgPSAweDI2MDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxudmFyIExJTkVBUiA9IDB4MjYwMTtcbi8qIFRleHR1cmVNaW5GaWx0ZXIgKi9cblxudmFyIE5FQVJFU1RfTUlQTUFQX05FQVJFU1QgPSAweDI3MDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxudmFyIExJTkVBUl9NSVBNQVBfTkVBUkVTVCA9IDB4MjcwMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG52YXIgTkVBUkVTVF9NSVBNQVBfTElORUFSID0gMHgyNzAyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbnZhciBMSU5FQVJfTUlQTUFQX0xJTkVBUiA9IDB4MjcwMzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIFRoZSBvcHRpb25zIGZvciBhIGZyYW1lYnVmZmVyIGF0dGFjaG1lbnQuXG4gKlxuICogTm90ZTogRm9yIGEgYGZvcm1hdGAgdGhhdCBpcyBhIHRleHR1cmUgaW5jbHVkZSBhbGwgdGhlIHRleHR1cmVcbiAqIG9wdGlvbnMgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IGZvciBleGFtcGxlXG4gKiBgbWluYCwgYG1hZ2AsIGBjbGFtcGAsIGV0Yy4uLiBOb3RlIHRoYXQgdW5saWtlIHtAbGluayBtb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc31cbiAqIGBhdXRvYCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBhdHRhY2htZW50IHRleHR1cmVzIGJ1dCBgbWluYCBhbmQgYG1hZ2AgZGVmYXVsdFxuICogdG8gYGdsLkxJTkVBUmAgYW5kIGB3cmFwYCBkZWZhdWx0cyB0byBgQ0xBTVBfVE9fRURHRWBcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBdHRhY2htZW50T3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFthdHRhY2hdIFRoZSBhdHRhY2htZW50IHBvaW50LiBEZWZhdWx0c1xuICogICB0byBgZ2wuQ09MT1JfQVRUQUNUTUVOVDAgKyBuZHhgIHVubGVzcyB0eXBlIGlzIGEgZGVwdGggb3Igc3RlbmNpbCB0eXBlXG4gKiAgIHRoZW4gaXQncyBnbC5ERVBUSF9BVFRBQ0hNRU5UIG9yIGBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlRgIGRlcGVuZGluZ1xuICogICBvbiB0aGUgZm9ybWF0IG9yIGF0dGFjaG1lbnQgdHlwZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZm9ybWF0XSBUaGUgZm9ybWF0LiBJZiBvbmUgb2YgYGdsLlJHQkE0YCxcbiAqICAgYGdsLlJHQjU2NWAsIGBnbC5SR0I1X0ExYCwgYGdsLkRFUFRIX0NPTVBPTkVOVDE2YCxcbiAqICAgYGdsLlNURU5DSUxfSU5ERVg4YCBvciBgZ2wuREVQVEhfU1RFTkNJTGAgdGhlbiB3aWxsIGNyZWF0ZSBhXG4gKiAgIHJlbmRlcmJ1ZmZlci4gT3RoZXJ3aXNlIHdpbGwgY3JlYXRlIGEgdGV4dHVyZS4gRGVmYXVsdCA9IGBnbC5SR0JBYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0eXBlXSBUaGUgdHlwZS4gVXNlZCBmb3IgdGV4dHVyZS4gRGVmYXVsdCA9IGBnbC5VTlNJR05FRF9CWVRFYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGFyZ2V0XSBUaGUgdGV4dHVyZSB0YXJnZXQgZm9yIGBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRGAuXG4gKiAgIERlZmF1bHRzIHRvIGBnbC5URVhUVVJFXzJEYC4gU2V0IHRvIGFwcHJvcHJpYXRlIGZhY2UgZm9yIGN1YmUgbWFwcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGV2ZWxdIGxldmVsIGZvciBgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkRgLiBEZWZhdWx0cyB0byAwLlxuICogQHByb3BlcnR5IHtXZWJHTE9iamVjdH0gW2F0dGFjaG1lbnRdIEFuIGV4aXN0aW5nIHJlbmRlcmJ1ZmZlciBvciB0ZXh0dXJlLlxuICogICAgSWYgcHJvdmlkZWQgd2lsbCBhdHRhY2ggdGhpcyBPYmplY3QuIFRoaXMgYWxsb3dzIHlvdSB0byBzaGFyZVxuICogICAgYXR0YWNoZW1udHMgYWNyb3NzIGZyYW1lYnVmZmVycy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbnZhciBkZWZhdWx0QXR0YWNobWVudHMgPSBbe1xuICBmb3JtYXQ6IFJHQkEsXG4gIHR5cGU6IFVOU0lHTkVEX0JZVEUsXG4gIG1pbjogTElORUFSLFxuICB3cmFwOiBDTEFNUF9UT19FREdFXG59LCB7XG4gIGZvcm1hdDogREVQVEhfU1RFTkNJTFxufV07XG52YXIgYXR0YWNobWVudHNCeUZvcm1hdCA9IHt9O1xuYXR0YWNobWVudHNCeUZvcm1hdFtERVBUSF9TVEVOQ0lMXSA9IERFUFRIX1NURU5DSUxfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbU1RFTkNJTF9JTkRFWF0gPSBTVEVOQ0lMX0FUVEFDSE1FTlQ7XG5hdHRhY2htZW50c0J5Rm9ybWF0W1NURU5DSUxfSU5ERVg4XSA9IFNURU5DSUxfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbREVQVEhfQ09NUE9ORU5UXSA9IERFUFRIX0FUVEFDSE1FTlQ7XG5hdHRhY2htZW50c0J5Rm9ybWF0W0RFUFRIX0NPTVBPTkVOVDE2XSA9IERFUFRIX0FUVEFDSE1FTlQ7XG5cbmZ1bmN0aW9uIGdldEF0dGFjaG1lbnRQb2ludEZvckZvcm1hdChmb3JtYXQpIHtcbiAgcmV0dXJuIGF0dGFjaG1lbnRzQnlGb3JtYXRbZm9ybWF0XTtcbn1cblxudmFyIHJlbmRlcmJ1ZmZlckZvcm1hdHMgPSB7fTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbUkdCQTRdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbUkdCNV9BMV0gPSB0cnVlO1xucmVuZGVyYnVmZmVyRm9ybWF0c1tSR0I1NjVdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbREVQVEhfU1RFTkNJTF0gPSB0cnVlO1xucmVuZGVyYnVmZmVyRm9ybWF0c1tERVBUSF9DT01QT05FTlQxNl0gPSB0cnVlO1xucmVuZGVyYnVmZmVyRm9ybWF0c1tTVEVOQ0lMX0lOREVYXSA9IHRydWU7XG5yZW5kZXJidWZmZXJGb3JtYXRzW1NURU5DSUxfSU5ERVg4XSA9IHRydWU7XG5cbmZ1bmN0aW9uIGlzUmVuZGVyYnVmZmVyRm9ybWF0KGZvcm1hdCkge1xuICByZXR1cm4gcmVuZGVyYnVmZmVyRm9ybWF0c1tmb3JtYXRdO1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGcmFtZWJ1ZmZlckluZm9cbiAqIEBwcm9wZXJ0eSB7V2ViR0xGcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXIgVGhlIFdlYkdMRnJhbWVidWZmZXIgZm9yIHRoaXMgZnJhbWVidWZmZXJJbmZvXG4gKiBAcHJvcGVydHkge1dlYkdMT2JqZWN0W119IGF0dGFjaG1lbnRzIFRoZSBjcmVhdGVkIGF0dGFjaG1lbnRzIGluIHRoZSBzYW1lIG9yZGVyIGFzIHBhc3NlZCBpbiB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlRnJhbWVidWZmZXJJbmZvfS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGZyYW1lYnVmZmVyIGFuZCBhdHRhY2htZW50cy5cbiAqXG4gKiBUaGlzIHJldHVybnMgYSB7QGxpbmsgbW9kdWxlOnR3Z2wuRnJhbWVidWZmZXJJbmZvfSBiZWNhdXNlIGl0IG5lZWRzIHRvIHJldHVybiB0aGUgYXR0YWNobWVudHMgYXMgd2VsbCBhcyB0aGUgZnJhbWVidWZmZXIuXG4gKlxuICogVGhlIHNpbXBsZXN0IHVzYWdlXG4gKlxuICogICAgIC8vIGNyZWF0ZSBhbiBSR0JBL1VOU0lHTkVEX0JZVEUgdGV4dHVyZSBhbmQgREVQVEhfU1RFTkNJTCByZW5kZXJidWZmZXJcbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCk7XG4gKlxuICogTW9yZSBjb21wbGV4IHVzYWdlXG4gKlxuICogICAgIC8vIGNyZWF0ZSBhbiBSR0I1NjUgcmVuZGVyYnVmZmVyIGFuZCBhIFNURU5DSUxfSU5ERVg4IHJlbmRlcmJ1ZmZlclxuICogICAgIGNvbnN0IGF0dGFjaG1lbnRzID0gW1xuICogICAgICAgeyBmb3JtYXQ6IFJHQjU2NSwgbWFnOiBORUFSRVNUIH0sXG4gKiAgICAgICB7IGZvcm1hdDogU1RFTkNJTF9JTkRFWDggfSxcbiAqICAgICBdXG4gKiAgICAgY29uc3QgZmJpID0gdHdnbC5jcmVhdGVGcmFtZWJ1ZmZlckluZm8oZ2wsIGF0dGFjaG1lbnRzKTtcbiAqXG4gKiBQYXNzaW5nIGluIGEgc3BlY2lmaWMgc2l6ZVxuICpcbiAqICAgICBjb25zdCB3aWR0aCA9IDI1NjtcbiAqICAgICBjb25zdCBoZWlnaHQgPSAyNTY7XG4gKiAgICAgY29uc3QgZmJpID0gdHdnbC5jcmVhdGVGcmFtZWJ1ZmZlckluZm8oZ2wsIGF0dGFjaG1lbnRzLCB3aWR0aCwgaGVpZ2h0KTtcbiAqXG4gKiAqKk5vdGUhISoqIEl0IGlzIHVwIHRvIHlvdSB0byBjaGVjayBpZiB0aGUgZnJhbWVidWZmZXIgaXMgcmVuZGVyYWJsZSBieSBjYWxsaW5nIGBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzYC5cbiAqIFtXZWJHTCBvbmx5IGd1YXJhbnRlZXMgMyBjb21iaW5hdGlvbnMgb2YgYXR0YWNobWVudHMgd29ya10oaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvc3BlY3MvbGF0ZXN0LzEuMC8jNi42KS5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5BdHRhY2htZW50T3B0aW9uc1tdfSBbYXR0YWNobWVudHNdIHdoaWNoIGF0dGFjaG1lbnRzIHRvIGNyZWF0ZS4gSWYgbm90IHByb3ZpZGVkIHRoZSBkZWZhdWx0IGlzIGEgZnJhbWVidWZmZXIgd2l0aCBhblxuICogICAgYFJHQkFgLCBgVU5TSUdORURfQllURWAgdGV4dHVyZSBgQ09MT1JfQVRUQUNITUVOVDBgIGFuZCBhIGBERVBUSF9TVEVOQ0lMYCByZW5kZXJidWZmZXIgYERFUFRIX1NURU5DSUxfQVRUQUNITUVOVGAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSB0aGUgd2lkdGggZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXVsdCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIHRoZSBoZWlnaHQgZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXV0dCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuRnJhbWVidWZmZXJJbmZvfSB0aGUgZnJhbWVidWZmZXIgYW5kIGF0dGFjaG1lbnRzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2ZyYW1lYnVmZmVyc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRnJhbWVidWZmZXJJbmZvKGdsLCBhdHRhY2htZW50cywgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgdGFyZ2V0ID0gZ2wuRlJBTUVCVUZGRVI7XG4gIHZhciBmYiA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gIGdsLmJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIGZiKTtcbiAgd2lkdGggPSB3aWR0aCB8fCBnbC5kcmF3aW5nQnVmZmVyV2lkdGg7XG4gIGhlaWdodCA9IGhlaWdodCB8fCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xuICBhdHRhY2htZW50cyA9IGF0dGFjaG1lbnRzIHx8IGRlZmF1bHRBdHRhY2htZW50cztcbiAgdmFyIGNvbG9yQXR0YWNobWVudENvdW50ID0gMDtcbiAgdmFyIGZyYW1lYnVmZmVySW5mbyA9IHtcbiAgICBmcmFtZWJ1ZmZlcjogZmIsXG4gICAgYXR0YWNobWVudHM6IFtdLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuICBhdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRhY2htZW50T3B0aW9ucykge1xuICAgIHZhciBhdHRhY2htZW50ID0gYXR0YWNobWVudE9wdGlvbnMuYXR0YWNobWVudDtcbiAgICB2YXIgZm9ybWF0ID0gYXR0YWNobWVudE9wdGlvbnMuZm9ybWF0O1xuICAgIHZhciBhdHRhY2htZW50UG9pbnQgPSBnZXRBdHRhY2htZW50UG9pbnRGb3JGb3JtYXQoZm9ybWF0KTtcblxuICAgIGlmICghYXR0YWNobWVudFBvaW50KSB7XG4gICAgICBhdHRhY2htZW50UG9pbnQgPSBDT0xPUl9BVFRBQ0hNRU5UMCArIGNvbG9yQXR0YWNobWVudENvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKCFhdHRhY2htZW50KSB7XG4gICAgICBpZiAoaXNSZW5kZXJidWZmZXJGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICBhdHRhY2htZW50ID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBhdHRhY2htZW50KTtcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGV4dHVyZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRhY2htZW50T3B0aW9ucyk7XG4gICAgICAgIHRleHR1cmVPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRleHR1cmVPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICBpZiAodGV4dHVyZU9wdGlvbnMuYXV0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGV4dHVyZU9wdGlvbnMuYXV0byA9IGZhbHNlO1xuICAgICAgICAgIHRleHR1cmVPcHRpb25zLm1pbiA9IHRleHR1cmVPcHRpb25zLm1pbiB8fCB0ZXh0dXJlT3B0aW9ucy5taW5NYWcgfHwgZ2wuTElORUFSO1xuICAgICAgICAgIHRleHR1cmVPcHRpb25zLm1hZyA9IHRleHR1cmVPcHRpb25zLm1hZyB8fCB0ZXh0dXJlT3B0aW9ucy5taW5NYWcgfHwgZ2wuTElORUFSO1xuICAgICAgICAgIHRleHR1cmVPcHRpb25zLndyYXBTID0gdGV4dHVyZU9wdGlvbnMud3JhcFMgfHwgdGV4dHVyZU9wdGlvbnMud3JhcCB8fCBnbC5DTEFNUF9UT19FREdFO1xuICAgICAgICAgIHRleHR1cmVPcHRpb25zLndyYXBUID0gdGV4dHVyZU9wdGlvbnMud3JhcFQgfHwgdGV4dHVyZU9wdGlvbnMud3JhcCB8fCBnbC5DTEFNUF9UT19FREdFO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0YWNobWVudCA9IHRleHR1cmVzLmNyZWF0ZVRleHR1cmUoZ2wsIHRleHR1cmVPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGVscGVyLmlzUmVuZGVyYnVmZmVyKGdsLCBhdHRhY2htZW50KSkge1xuICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIodGFyZ2V0LCBhdHRhY2htZW50UG9pbnQsIGdsLlJFTkRFUkJVRkZFUiwgYXR0YWNobWVudCk7XG4gICAgfSBlbHNlIGlmIChoZWxwZXIuaXNUZXh0dXJlKGdsLCBhdHRhY2htZW50KSkge1xuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGFyZ2V0LCBhdHRhY2htZW50UG9pbnQsIGF0dGFjaG1lbnRPcHRpb25zLnRleFRhcmdldCB8fCBnbC5URVhUVVJFXzJELCBhdHRhY2htZW50LCBhdHRhY2htZW50T3B0aW9ucy5sZXZlbCB8fCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJ1bmtub3duIGF0dGFjaG1lbnQgdHlwZVwiO1xuICAgIH1cblxuICAgIGZyYW1lYnVmZmVySW5mby5hdHRhY2htZW50cy5wdXNoKGF0dGFjaG1lbnQpO1xuICB9KTtcbiAgcmV0dXJuIGZyYW1lYnVmZmVySW5mbztcbn1cbi8qKlxuICogUmVzaXplcyB0aGUgYXR0YWNobWVudHMgb2YgYSBmcmFtZWJ1ZmZlci5cbiAqXG4gKiBZb3UgbmVlZCB0byBwYXNzIGluIHRoZSBzYW1lIGBhdHRhY2htZW50c2AgYXMgeW91IHBhc3NlZCBpbiB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlRnJhbWVidWZmZXJJbmZvfVxuICogYmVjYXVzZSBUV0dMIGhhcyBubyBpZGVhIHRoZSBmb3JtYXQvdHlwZSBvZiBlYWNoIGF0dGFjaG1lbnQuXG4gKlxuICogVGhlIHNpbXBsZXN0IHVzYWdlXG4gKlxuICogICAgIC8vIGNyZWF0ZSBhbiBSR0JBL1VOU0lHTkVEX0JZVEUgdGV4dHVyZSBhbmQgREVQVEhfU1RFTkNJTCByZW5kZXJidWZmZXJcbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCk7XG4gKlxuICogICAgIC4uLlxuICpcbiAqICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gKiAgICAgICBpZiAodHdnbC5yZXNpemVDYW52YXNUb0Rpc3BsYXlTaXplKGdsLmNhbnZhcykpIHtcbiAqICAgICAgICAgLy8gcmVzaXplIHRoZSBhdHRhY2htZW50c1xuICogICAgICAgICB0d2dsLnJlc2l6ZUZyYW1lYnVmZmVySW5mbyhnbCwgZmJpKTtcbiAqICAgICAgIH1cbiAqXG4gKiBNb3JlIGNvbXBsZXggdXNhZ2VcbiAqXG4gKiAgICAgLy8gY3JlYXRlIGFuIFJHQjU2NSByZW5kZXJidWZmZXIgYW5kIGEgU1RFTkNJTF9JTkRFWDggcmVuZGVyYnVmZmVyXG4gKiAgICAgY29uc3QgYXR0YWNobWVudHMgPSBbXG4gKiAgICAgICB7IGZvcm1hdDogUkdCNTY1LCBtYWc6IE5FQVJFU1QgfSxcbiAqICAgICAgIHsgZm9ybWF0OiBTVEVOQ0lMX0lOREVYOCB9LFxuICogICAgIF1cbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCwgYXR0YWNobWVudHMpO1xuICpcbiAqICAgICAuLi5cbiAqXG4gKiAgICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICogICAgICAgaWYgKHR3Z2wucmVzaXplQ2FudmFzVG9EaXNwbGF5U2l6ZShnbC5jYW52YXMpKSB7XG4gKiAgICAgICAgIC8vIHJlc2l6ZSB0aGUgYXR0YWNobWVudHMgdG8gbWF0Y2hcbiAqICAgICAgICAgdHdnbC5yZXNpemVGcmFtZWJ1ZmZlckluZm8oZ2wsIGZiaSwgYXR0YWNobWVudHMpO1xuICogICAgICAgfVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkZyYW1lYnVmZmVySW5mb30gZnJhbWVidWZmZXJJbmZvIGEgZnJhbWVidWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mb30uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkF0dGFjaG1lbnRPcHRpb25zW119IFthdHRhY2htZW50c10gdGhlIHNhbWUgYXR0YWNobWVudHMgb3B0aW9ucyBhcyBwYXNzZWQgdG8ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mb30uXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSB0aGUgd2lkdGggZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXVsdCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIHRoZSBoZWlnaHQgZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXV0dCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2ZyYW1lYnVmZmVyc1xuICovXG5cblxuZnVuY3Rpb24gcmVzaXplRnJhbWVidWZmZXJJbmZvKGdsLCBmcmFtZWJ1ZmZlckluZm8sIGF0dGFjaG1lbnRzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHdpZHRoID0gd2lkdGggfHwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoO1xuICBoZWlnaHQgPSBoZWlnaHQgfHwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcbiAgZnJhbWVidWZmZXJJbmZvLndpZHRoID0gd2lkdGg7XG4gIGZyYW1lYnVmZmVySW5mby5oZWlnaHQgPSBoZWlnaHQ7XG4gIGF0dGFjaG1lbnRzID0gYXR0YWNobWVudHMgfHwgZGVmYXVsdEF0dGFjaG1lbnRzO1xuICBhdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRhY2htZW50T3B0aW9ucywgbmR4KSB7XG4gICAgdmFyIGF0dGFjaG1lbnQgPSBmcmFtZWJ1ZmZlckluZm8uYXR0YWNobWVudHNbbmR4XTtcbiAgICB2YXIgZm9ybWF0ID0gYXR0YWNobWVudE9wdGlvbnMuZm9ybWF0O1xuXG4gICAgaWYgKGhlbHBlci5pc1JlbmRlcmJ1ZmZlcihnbCwgYXR0YWNobWVudCkpIHtcbiAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBhdHRhY2htZW50KTtcbiAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoaGVscGVyLmlzVGV4dHVyZShnbCwgYXR0YWNobWVudCkpIHtcbiAgICAgIHRleHR1cmVzLnJlc2l6ZVRleHR1cmUoZ2wsIGF0dGFjaG1lbnQsIGF0dGFjaG1lbnRPcHRpb25zLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJ1bmtub3duIGF0dGFjaG1lbnQgdHlwZVwiO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEJpbmRzIGEgZnJhbWVidWZmZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHByZXR0eSBtdWNoIHNvbGV5IGV4aXN0cyBiZWNhdXNlIEkgc3BlbnQgaG91cnNcbiAqIHRyeWluZyB0byBmaWd1cmUgb3V0IHdoeSBzb21ldGhpbmcgSSB3cm90ZSB3YXNuJ3Qgd29ya2luZyBvbmx5XG4gKiB0byByZWFsaXplIEkgZm9yZ2V0IHRvIHNldCB0aGUgdmlld3BvcnQgZGltZW5zaW9ucy5cbiAqIE15IGhvcGUgaXMgdGhpcyBmdW5jdGlvbiB3aWxsIGZpeCB0aGF0LlxuICpcbiAqIEl0IGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzXG4gKlxuICogICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgc29tZUZyYW1lYnVmZmVySW5mby5mcmFtZWJ1ZmZlcik7XG4gKiAgICAgZ2wudmlld3BvcnQoMCwgMCwgc29tZUZyYW1lYnVmZmVySW5mby53aWR0aCwgc29tZUZyYW1lYnVmZmVySW5mby5oZWlnaHQpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkZyYW1lYnVmZmVySW5mb30gW2ZyYW1lYnVmZmVySW5mb10gYSBmcmFtZWJ1ZmZlckluZm8gYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlRnJhbWVidWZmZXJJbmZvfS5cbiAqICAgSWYgbm90IHBhc3NlZCB3aWxsIGJpbmQgdGhlIGNhbnZhcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGFyZ2V0XSBUaGUgdGFyZ2V0LiBJZiBub3QgcGFzc2VkIGBnbC5GUkFNRUJVRkZFUmAgd2lsbCBiZSB1c2VkLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2ZyYW1lYnVmZmVyc1xuICovXG5cblxuZnVuY3Rpb24gYmluZEZyYW1lYnVmZmVySW5mbyhnbCwgZnJhbWVidWZmZXJJbmZvLCB0YXJnZXQpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0IHx8IGdsLkZSQU1FQlVGRkVSO1xuXG4gIGlmIChmcmFtZWJ1ZmZlckluZm8pIHtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIodGFyZ2V0LCBmcmFtZWJ1ZmZlckluZm8uZnJhbWVidWZmZXIpO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGZyYW1lYnVmZmVySW5mby53aWR0aCwgZnJhbWVidWZmZXJJbmZvLmhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgbnVsbCk7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNyZWF0ZVZlcnRleEFycmF5SW5mbyA9IGNyZWF0ZVZlcnRleEFycmF5SW5mbztcbmV4cG9ydHMuY3JlYXRlVkFPQW5kU2V0QXR0cmlidXRlcyA9IGNyZWF0ZVZBT0FuZFNldEF0dHJpYnV0ZXM7XG5leHBvcnRzLmNyZWF0ZVZBT0Zyb21CdWZmZXJJbmZvID0gY3JlYXRlVkFPRnJvbUJ1ZmZlckluZm87XG5cbnZhciBwcm9ncmFtcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oNSkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNSwgR3JlZ2cgVGF2YXJlcy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbiAqIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiAqIGRpc3RyaWJ1dGlvbi5cbiAqICAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR3JlZ2cgVGF2YXJlcy4gbm9yIHRoZSBuYW1lcyBvZiBoaXNcbiAqIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4vKipcbiAqIHZlcnRleCBhcnJheSBvYmplY3QgcmVsYXRlZCBmdW5jdGlvbnNcbiAqXG4gKiBZb3Ugc2hvdWxkIGdlbmVyYWxseSBub3QgbmVlZCB0byB1c2UgdGhlc2UgZnVuY3Rpb25zLiBUaGV5IGFyZSBwcm92aWRlZFxuICogZm9yIHRob3NlIGNhc2VzIHdoZXJlIHlvdSdyZSBkb2luZyBzb21ldGhpbmcgb3V0IG9mIHRoZSBvcmRpbmFyeVxuICogYW5kIHlvdSBuZWVkIGxvd2VyIGxldmVsIGFjY2Vzcy5cbiAqXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbHkgdGhleSBhcmUgYXZhaWxhYmxlIGF0IGJvdGggYHR3Z2wuYXR0cmlidXRlc2AgYW5kIGB0d2dsYFxuICogaXRzZWxmXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6dHdnbH0gZm9yIGNvcmUgZnVuY3Rpb25zXG4gKlxuICogQG1vZHVsZSB0d2dsL3ZlcnRleEFycmF5c1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVmVydGV4QXJyYXlJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gbnVtRWxlbWVudHMgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBwYXNzIHRvIGBnbC5kcmF3QXJyYXlzYCBvciBgZ2wuZHJhd0VsZW1lbnRzYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZWxlbWVudFR5cGVdIFRoZSB0eXBlIG9mIGluZGljZXMgYFVOU0lHTkVEX0JZVEVgLCBgVU5TSUdORURfU0hPUlRgIGV0Yy4uXG4gKiBAcHJvcGVydHkge1dlYkdMVmVydGV4QXJyYXlPYmplY3R9IFt2ZXJ0ZXhBcnJheU9iamVjdF0gYSB2ZXJ0ZXggYXJyYXkgb2JqZWN0XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBWZXJ0ZXhBcnJheUluZm8gZnJvbSBhIEJ1ZmZlckluZm8gYW5kIG9uZSBvciBtb3JlIFByb2dyYW1JbmZvc1xuICpcbiAqIFRoaXMgY2FuIGJlIHBhc3NlZCB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9IGFuZCB0b1xuICoge0BsaW5rIG1vZHVsZTp0d2dsOmRyYXdCdWZmZXJJbmZvfS5cbiAqXG4gKiA+ICoqSU1QT1JUQU5UOioqIFZlcnRleCBBcnJheSBPYmplY3RzIGFyZSAqKm5vdCoqIGEgZGlyZWN0IGFuYWxvZyBmb3IgYSBCdWZmZXJJbmZvLiBWZXJ0ZXggQXJyYXkgT2JqZWN0c1xuICogICBhc3NpZ24gYnVmZmVycyB0byBzcGVjaWZpYyBhdHRyaWJ1dGVzIGF0IGNyZWF0aW9uIHRpbWUuIFRoYXQgbWVhbnMgdGhleSBjYW4gb25seSBiZSB1c2VkIHdpdGggcHJvZ3JhbXNcbiAqICAgd2hvJ3MgYXR0cmlidXRlcyB1c2UgdGhlIHNhbWUgYXR0cmlidXRlIGxvY2F0aW9ucyBmb3IgdGhlIHNhbWUgcHVycG9zZXMuXG4gKlxuICogPiBCaW5kIHlvdXIgYXR0cmlidXRlIGxvY2F0aW9ucyBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlUHJvZ3JhbUluZm99XG4gKiAgIG9yIHVzZSBXZWJHTCAyJ3MgR0xTTCBFUyAzJ3MgYGxheW91dChsb2NhdGlvbiA9IDxudW0+KWAgdG8gbWFrZSBzdXJlIGxvY2F0aW9ucyBtYXRjaC5cbiAqXG4gKiBhbHNvXG4gKlxuICogPiAqKklNUE9SVEFOVDoqKiBBZnRlciBjYWxsaW5nIHR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZSB3aXRoIGEgQnVmZmVySW5mbyB0aGF0IHVzZXMgYSBWZXJ0ZXggQXJyYXkgT2JqZWN0XG4gKiAgIHRoYXQgVmVydGV4IEFycmF5IE9iamVjdCB3aWxsIGJlIGJvdW5kLiBUaGF0IG1lYW5zICoqQU5ZIE1BTklQVUxBVElPTiBPRiBFTEVNRU5UX0FSUkFZX0JVRkZFUiBvciBBVFRSSUJVVEVTKipcbiAqICAgd2lsbCBhZmZlY3QgdGhlIFZlcnRleCBBcnJheSBPYmplY3Qgc3RhdGUuXG4gKlxuICogPiBDYWxsIGBnbC5iaW5kVmVydGV4QXJyYXkobnVsbClgIHRvIGdldCBiYWNrIG1hbmlwdWxhdGluZyB0aGUgZ2xvYmFsIGF0dHJpYnV0ZXMgYW5kIEVMRU1FTlRfQVJSQVlfQlVGRkVSLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb1tdfSBwcm9ncmFtSW5mbyBhIHByb2dyYW1JbmZvIG9yIGFycmF5IG9mIHByb2dyYW1JbmZvc1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBidWZmZXJJbmZvIEJ1ZmZlckluZm8gYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyBldGMuLi5cbiAqXG4gKiAgICBZb3UgbmVlZCB0byBtYWtlIHN1cmUgZXZlcnkgYXR0cmlidXRlIHRoYXQgd2lsbCBiZSB1c2VkIGlzIGJvdW5kLiBTbyBmb3IgZXhhbXBsZSBhc3N1bWUgc2hhZGVyIDFcbiAqICAgIHVzZXMgYXR0cmlidXRlcyBBLCBCLCBDIGFuZCBzaGFkZXIgMiB1c2VzIGF0dHJpYnV0ZXMgQSwgQiwgRC4gSWYgeW91IG9ubHkgcGFzcyBpbiB0aGUgcHJvZ3JhbUluZm9cbiAqICAgIGZvciBzaGFkZXIgMSB0aGVuIG9ubHkgYXR0cmlidXRlcyBBLCBCLCBhbmQgQyB3aWxsIGhhdmUgdGhlaXIgYXR0cmlidXRlcyBzZXQgYmVjYXVzZSBUV0dMIGRvZXNuJ3RcbiAqICAgIG5vdyBhdHRyaWJ1dGUgRCdzIGxvY2F0aW9uLlxuICpcbiAqICAgIFNvLCB5b3UgY2FuIHBhc3MgaW4gYm90aCBzaGFkZXIgMSBhbmQgc2hhZGVyIDIncyBwcm9ncmFtSW5mb1xuICpcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLlZlcnRleEFycmF5SW5mb30gVGhlIGNyZWF0ZWQgVmVydGV4QXJyYXlJbmZvXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ZlcnRleEFycmF5c1xuICovXG5mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhBcnJheUluZm8oZ2wsIHByb2dyYW1JbmZvcywgYnVmZmVySW5mbykge1xuICB2YXIgdmFvID0gZ2wuY3JlYXRlVmVydGV4QXJyYXkoKTtcbiAgZ2wuYmluZFZlcnRleEFycmF5KHZhbyk7XG5cbiAgaWYgKCFwcm9ncmFtSW5mb3MubGVuZ3RoKSB7XG4gICAgcHJvZ3JhbUluZm9zID0gW3Byb2dyYW1JbmZvc107XG4gIH1cblxuICBwcm9ncmFtSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbUluZm8pIHtcbiAgICBwcm9ncmFtcy5zZXRCdWZmZXJzQW5kQXR0cmlidXRlcyhnbCwgcHJvZ3JhbUluZm8sIGJ1ZmZlckluZm8pO1xuICB9KTtcbiAgZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICByZXR1cm4ge1xuICAgIG51bUVsZW1lbnRzOiBidWZmZXJJbmZvLm51bUVsZW1lbnRzLFxuICAgIGVsZW1lbnRUeXBlOiBidWZmZXJJbmZvLmVsZW1lbnRUeXBlLFxuICAgIHZlcnRleEFycmF5T2JqZWN0OiB2YW9cbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHZlcnRleCBhcnJheSBvYmplY3QgYW5kIHRoZW4gc2V0cyB0aGUgYXR0cmlidXRlcyBvbiBpdFxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHRvIHVzZS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn0gc2V0dGVycyBBdHRyaWJ1dGUgc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUF0dHJpYnV0ZVNldHRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+fSBhdHRyaWJzIEF0dHJpYkluZm9zIG1hcHBlZCBieSBhdHRyaWJ1dGUgbmFtZS5cbiAqIEBwYXJhbSB7V2ViR0xCdWZmZXJ9IFtpbmRpY2VzXSBhbiBvcHRpb25hbCBFTEVNRU5UX0FSUkFZX0JVRkZFUiBvZiBpbmRpY2VzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdmVydGV4QXJyYXlzXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVWQU9BbmRTZXRBdHRyaWJ1dGVzKGdsLCBzZXR0ZXJzLCBhdHRyaWJzLCBpbmRpY2VzKSB7XG4gIHZhciB2YW8gPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcbiAgcHJvZ3JhbXMuc2V0QXR0cmlidXRlcyhzZXR0ZXJzLCBhdHRyaWJzKTtcblxuICBpZiAoaW5kaWNlcykge1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGljZXMpO1xuICB9IC8vIFdlIHVuYmluZCB0aGlzIGJlY2F1c2Ugb3RoZXJ3aXNlIGFueSBjaGFuZ2UgdG8gRUxFTUVOVF9BUlJBWV9CVUZGRVJcbiAgLy8gbGlrZSB3aGVuIGNyZWF0aW5nIGJ1ZmZlcnMgZm9yIG90aGVyIHN0dWZmIHdpbGwgbWVzcyB1cCB0aGlzIFZBTydzIGJpbmRpbmdcblxuXG4gIGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcbiAgcmV0dXJuIHZhbztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHZlcnRleCBhcnJheSBvYmplY3QgYW5kIHRoZW4gc2V0cyB0aGUgYXR0cmlidXRlc1xuICogb24gaXRcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogICAgICAgIHRvIHVzZS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPnwgbW9kdWxlOnR3Z2wuUHJvZ3JhbUluZm99IHByb2dyYW1JbmZvIGFzIHJldHVybmVkIGZyb20gY3JlYXRlUHJvZ3JhbUluZm8gb3IgQXR0cmlidXRlIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IGJ1ZmZlckluZm8gQnVmZmVySW5mbyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzIGV0Yy4uLlxuICogQHBhcmFtIHtXZWJHTEJ1ZmZlcn0gW2luZGljZXNdIGFuIG9wdGlvbmFsIEVMRU1FTlRfQVJSQVlfQlVGRkVSIG9mIGluZGljZXNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92ZXJ0ZXhBcnJheXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVZBT0Zyb21CdWZmZXJJbmZvKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbykge1xuICByZXR1cm4gY3JlYXRlVkFPQW5kU2V0QXR0cmlidXRlcyhnbCwgcHJvZ3JhbUluZm8uYXR0cmliU2V0dGVycyB8fCBwcm9ncmFtSW5mbywgYnVmZmVySW5mby5hdHRyaWJzLCBidWZmZXJJbmZvLmluZGljZXMpO1xufVxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90d2dsLmpzL2Rpc3QvNC54L3R3Z2wtZnVsbC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY2xhc3MgQ29vcmQzIHtcblx0eDogbnVtYmVyO1xuXHR5OiBudW1iZXI7XG5cdHo6IG51bWJlcjtcblxuXHRjb25zdHJ1Y3Rvcihjb29yZDogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgejogbnVtYmVyIH0pIHtcblx0XHR0aGlzLnggPSBjb29yZC54O1xuXHRcdHRoaXMueSA9IGNvb3JkLnk7XG5cdFx0dGhpcy56ID0gY29vcmQuejtcblx0fVxuXG5cdHNjYWxlZChmYWN0b3I6IG51bWJlcikge1xuXHRcdHJldHVybiBDb29yZDMuc2NhbGUodGhpcywgZmFjdG9yKTtcblx0fVxuXG5cdGxlbmd0aCgpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueik7XG5cdH1cblxuXHRub3JtYWxpemVkKCkge1xuXHRcdHJldHVybiBDb29yZDMuc2NhbGUodGhpcywgMSAvIHRoaXMubGVuZ3RoKCkpO1xuXHR9XG5cblx0c3RhdGljIGRpc3RhbmNlKGE6IENvb3JkMywgYjogQ29vcmQzKSB7XG5cdFx0cmV0dXJuIENvb3JkMy5zdWJ0cmFjdChhLCBiKS5sZW5ndGgoKTtcblx0fVxuXG5cdHN0YXRpYyBhZGQoYTogQ29vcmQzLCBiOiBDb29yZDMpIHtcblx0XHRyZXR1cm4gbmV3IENvb3JkMyh7XG5cdFx0XHR4OiBhLnggKyBiLngsXG5cdFx0XHR5OiBhLnkgKyBiLnksXG5cdFx0XHR6OiBhLnogKyBiLnosXG5cdFx0fSk7XG5cdH1cblxuXHRzdGF0aWMgc3VidHJhY3QoYTogQ29vcmQzLCBiOiBDb29yZDMpIHtcblx0XHRyZXR1cm4gbmV3IENvb3JkMyh7XG5cdFx0XHR4OiBhLnggLSBiLngsXG5cdFx0XHR5OiBhLnkgLSBiLnksXG5cdFx0XHR6OiBhLnogLSBiLnosXG5cdFx0fSk7XG5cdH1cblxuXHRzdGF0aWMgc2NhbGUoY29vcmQ6IENvb3JkMywgZmFjdG9yOiBudW1iZXIpIHtcblx0XHRyZXR1cm4gbmV3IENvb3JkMyh7XG5cdFx0XHR4OiBjb29yZC54ICogZmFjdG9yLFxuXHRcdFx0eTogY29vcmQueSAqIGZhY3Rvcixcblx0XHRcdHo6IGNvb3JkLnogKiBmYWN0b3IsXG5cdFx0fSk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Db29yZDMudHMiLCJleHBvcnQgY2xhc3MgQ29vcmQyIHtcblx0eDogbnVtYmVyO1xuXHR5OiBudW1iZXI7XG5cblx0Y29uc3RydWN0b3IoY29vcmQ6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSkge1xuXHRcdHRoaXMueCA9IGNvb3JkLng7XG5cdFx0dGhpcy55ID0gY29vcmQueTtcblx0fVxuXG5cdHNjYWxlZChmYWN0b3I6IG51bWJlcikge1xuXHRcdHJldHVybiBDb29yZDIuc2NhbGUodGhpcywgZmFjdG9yKTtcblx0fVxuXG5cdGxlbmd0aCgpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG5cdH1cblxuXHRub3JtYWxpemVkKCkge1xuXHRcdHJldHVybiBDb29yZDIuc2NhbGUodGhpcywgMSAvIHRoaXMubGVuZ3RoKCkpO1xuXHR9XG5cblx0c3RhdGljIGRpc3RhbmNlKGE6IENvb3JkMiwgYjogQ29vcmQyKSB7XG5cdFx0cmV0dXJuIENvb3JkMi5zdWJ0cmFjdChhLCBiKS5sZW5ndGgoKTtcblx0fVxuXG5cdHN0YXRpYyBhZGQoYTogQ29vcmQyLCBiOiBDb29yZDIpIHtcblx0XHRyZXR1cm4gbmV3IENvb3JkMih7XG5cdFx0XHR4OiBhLnggKyBiLngsXG5cdFx0XHR5OiBhLnkgKyBiLnksXG5cdFx0fSk7XG5cdH1cblxuXHRzdGF0aWMgc3VidHJhY3QoYTogQ29vcmQyLCBiOiBDb29yZDIpIHtcblx0XHRyZXR1cm4gbmV3IENvb3JkMih7XG5cdFx0XHR4OiBhLnggLSBiLngsXG5cdFx0XHR5OiBhLnkgLSBiLnksXG5cdFx0fSk7XG5cdH1cblxuXHRzdGF0aWMgc2NhbGUoY29vcmQ6IENvb3JkMiwgZmFjdG9yOiBudW1iZXIpIHtcblx0XHRyZXR1cm4gbmV3IENvb3JkMih7XG5cdFx0XHR4OiBjb29yZC54ICogZmFjdG9yLFxuXHRcdFx0eTogY29vcmQueSAqIGZhY3Rvcixcblx0XHR9KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0Nvb3JkMi50cyIsImltcG9ydCB7IENvb3JkMiB9IGZyb20gXCIuL0Nvb3JkMlwiO1xuaW1wb3J0IHsgd2FpdE1zIH0gZnJvbSBcIi4vZnVuY3Rpb25zXCI7XG5pbXBvcnQgKiBhcyBSZW5kZXJlciBmcm9tIFwiLi9SZW5kZXJlclwiO1xuXG5leHBvcnQgY2xhc3MgUGllY2Uge1xuXHRjb2xvcjogbnVtYmVyO1xuXHRjb2xvcklzVmlzaWJsZTogYm9vbGVhbjtcblx0cGlja2VkOiBib29sZWFuO1xuXHRmcmFtZUNvcm91dGluZTogSXRlcmFibGVJdGVyYXRvcjx2b2lkPjtcblxuXHRjb25zdHJ1Y3RvcihvcHRpb25zOiB7IGNvbG9yOiBudW1iZXIgfSkge1xuXHRcdHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuXHRcdHRoaXMuY29sb3JJc1Zpc2libGUgPSB0cnVlO1xuXHRcdHRoaXMucGlja2VkID0gZmFsc2U7XG5cdFx0dGhpcy5mcmFtZUNvcm91dGluZSA9IHRoaXMubWFrZUZyYW1lQ29yb3V0aW5lKCk7XG5cdH1cblxuXHRzZXRQaWNrZWQocGlja2VkOiBib29sZWFuKSB7XG5cdFx0dGhpcy5waWNrZWQgPSBwaWNrZWQ7XG5cdH1cblxuXHQqbWFrZUZyYW1lQ29yb3V0aW5lKCk6IEl0ZXJhYmxlSXRlcmF0b3I8dm9pZD4ge1xuXHRcdHlpZWxkKiB3YWl0TXMoMTAwMCk7XG5cdFx0dGhpcy5jb2xvcklzVmlzaWJsZSA9IGZhbHNlO1xuXHR9XG5cblx0ZHJhdyhwb3NpdGlvbjogQ29vcmQyKSB7XG5cdFx0UmVuZGVyZXIuZHJhdyhcblx0XHRcdHRoaXMucGlja2VkIHx8IHRoaXMuY29sb3JJc1Zpc2libGUgPyB0aGlzLmNvbG9yIDogLTEsXG5cdFx0XHRwb3NpdGlvbixcblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvUGllY2UudHMiLCJpbXBvcnQgeyBCb2FyZCB9IGZyb20gXCIuL0JvYXJkXCI7XG5pbXBvcnQgeyBHYW1lTW9kZSB9IGZyb20gXCIuL0dhbWVNb2RlXCI7XG5cbmV4cG9ydCBjbGFzcyBHYW1lTW9kZTFwIGltcGxlbWVudHMgR2FtZU1vZGUge1xuXHRib2FyZDogQm9hcmQ7XG5cdGZyYW1lQ29yb3V0aW5lOiBJdGVyYWJsZUl0ZXJhdG9yPHZvaWQ+O1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuYm9hcmQgPSBuZXcgQm9hcmQoeyBnYW1lTW9kZTogdGhpcyB9KTtcblx0XHR0aGlzLmZyYW1lQ29yb3V0aW5lID0gdGhpcy5tYWtlRnJhbWVDb3JvdXRpbmUoKTtcblx0fVxuXG5cdG9uVW5sb2NrZWRQYWlyKF9ib2FyZDogQm9hcmQpIHtcblx0XHRjb25zb2xlLmxvZyhcInVubG9ja2VkIHBhaXJcIik7XG5cdFx0Ly8gVE9ET1xuXHR9XG5cblx0b25HYW1lT3ZlcihfYm9hcmQ6IEJvYXJkKSB7XG5cdFx0Y29uc29sZS5sb2coXCJnYW1lIG92ZXJcIik7XG5cdFx0Ly8gVE9ET1xuXHR9XG5cblx0b25XaW4oX2JvYXJkOiBCb2FyZCkge1xuXHRcdGNvbnNvbGUubG9nKFwid2luXCIpO1xuXHRcdC8vIFRPRE9cblx0fVxuXG5cdCptYWtlRnJhbWVDb3JvdXRpbmUoKTogSXRlcmFibGVJdGVyYXRvcjx2b2lkPiB7XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0Ly8gVGhlIHBsYXllciBib2FyZC5cblx0XHRcdGNvbnN0IGRlbHRhVGltZTogbnVtYmVyID0geWllbGQ7XG5cdFx0XHRjb25zdCBuZXh0ID0gdGhpcy5ib2FyZC5mcmFtZUNvcm91dGluZS5uZXh0KGRlbHRhVGltZSk7XG5cblx0XHRcdC8vIFllcywgSSBjb3VsZCBoYXZlIHVzZWQgYSBzaW1wbGUgZm9yLW9mLCBidXQgSSBleHBlY3QgdG8gYWRkIG1vcmUgc3R1ZmYgdG8gcnVuIGluIGNvbmN1cnJlbnRseS5cblx0XHRcdGlmIChuZXh0LmRvbmUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGRyYXcoKSB7XG5cdFx0Ly8gVGhlIHBsYXllciBib2FyZC5cblx0XHR0aGlzLmJvYXJkLmRyYXcoKTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0dhbWVNb2RlMXAudHMiXSwic291cmNlUm9vdCI6IiJ9